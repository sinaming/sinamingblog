{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[],"Cache":[{"_id":"source/_posts/Hexo插入图片.md","hash":"6c13025a8ffb6baa93bc393cc3d0b52be070946b","modified":1533534368570},{"_id":"source/_posts/Hexo教程.md","hash":"43c021ab8e814a364e2b8f85cc2f55c594605d71","modified":1533534368571},{"_id":"source/_posts/Masonry自适应tableHeaderView.md","hash":"a35a55f4cade71d35bc07bfadbf4ec6616d6ad0f","modified":1533534368571},{"_id":"source/_posts/Masonry设置UIScrollView的contentSize.md","hash":"6912e36c4ab19fff6c24b70982e6689dbdd862c4","modified":1533534368574},{"_id":"source/_posts/iOSPush任意新页面.md","hash":"faf3d247438a42d9afda31be76b5919fa2eaa004","modified":1533534368580},{"_id":"source/_posts/iOS偷懒-效率.md","hash":"d2a71e289b6af9b81222fa85d38c7d4ec0139474","modified":1533534368581},{"_id":"source/_posts/iOS开发之UITableView滚动方向.md","hash":"5ff88e297e6f53ca4b1c0153ce38073fc1b5ca11","modified":1533534368581},{"_id":"source/_posts/iOS仿淘宝详情页导航栏.md","hash":"5736344a251ada09ff9da2ae0af631046b74735c","modified":1533534368581},{"_id":"source/_posts/iOS强制横屏实践.md","hash":"caba55ac5f28e391774a4d85024695dfdeb564b1","modified":1533534368581},{"_id":"source/_posts/iOS模型嵌套模型.md","hash":"c867822cb746c4eb70358b2bd215a9f703a33f8d","modified":1533534368584},{"_id":"source/_posts/iOS横竖屏.md","hash":"c361febafd5fcb5ec72c66faa56b43c15b6297f9","modified":1533539899228},{"_id":"source/_posts/iOS熟悉-property和set方法和get方法.md","hash":"6eca96df0f6254039b6186501ea5f7f80b247651","modified":1533534368584},{"_id":"source/_posts/iOS熟悉UIEdgeInsetsMake使用.md","hash":"d7080d9ef48735e329d9d76bd626cdc29a1ecfcb","modified":1533534368584},{"_id":"source/_posts/ios之界面之间的数据正逆向传递方法.md","hash":"ba3abb684770f65ccefab682eaab3f79cc1293a5","modified":1533534368586},{"_id":"source/_posts/熟悉UIScrollView的contentSize-contentOffset-contentInset.md","hash":"f3824cdcbabf3a0b3f81d332a94629ecd89e6dee","modified":1533534368586},{"_id":"source/about/index.md","hash":"3f45e672826e9495f8648f06dc0f445a50d0789f","modified":1533534368587},{"_id":"source/categories/index.md","hash":"8286068dfa8a5becc6525df75f5d8de983d2bc8b","modified":1533534368587},{"_id":"source/tags/index.md","hash":"27558e22b9e509fe0a5ef26260ec3269fde66159","modified":1533534368587},{"_id":"source/_posts/Hexo插入图片/phone.jpg","hash":"71c59572a3fe08aa89c7cbfd70ddbd022771ca64","modified":1533534368571},{"_id":"source/_posts/iOS熟悉UIEdgeInsetsMake使用/按钮图片在上文字在下.png","hash":"67a58fb7a74abd8223a344cd7c3c3cece1d8dd6d","modified":1533534368585},{"_id":"source/_posts/iOS熟悉UIEdgeInsetsMake使用/按钮图片在下文字在上.png","hash":"c04696538a4fc9afa42f87f03ab33ed026d9772f","modified":1533534368585},{"_id":"source/_posts/iOS熟悉UIEdgeInsetsMake使用/按钮图片在右文字在左.png","hash":"94b2195755306f572bfc413ca959f16f32ca5f8b","modified":1533534368585},{"_id":"source/_posts/iOS熟悉UIEdgeInsetsMake使用/按钮图片文字居中.png","hash":"07505e6147b06fa01d55c354f2eae19f7a20282c","modified":1533534368586},{"_id":"source/_posts/iOS强制横屏实践/横竖屏1.png","hash":"8b88476b898dc27cb76081d1ca59d4c11ebb9f15","modified":1533534368582},{"_id":"source/_posts/熟悉UIScrollView的contentSize-contentOffset-contentInset/UIScrollView偏移图.png","hash":"b30c0f3983f12b36487cd7256b74441274f46a8c","modified":1533534368587},{"_id":"source/_posts/iOS强制横屏实践/横竖屏2.png","hash":"94fb93e3b2b0696d502e6a306ad975454cc33bf7","modified":1533534368583},{"_id":"source/_posts/Masonry自适应tableHeaderView/tableHeaderView.gif","hash":"86f53f11f28420223b285192a148d61c5c4569c0","modified":1533534368574},{"_id":"source/_posts/Masonry设置UIScrollView的contentSize/复杂UIScrollView.gif","hash":"f7e0b0d9bca3d61bf56d8a03c09715aad50fc9b6","modified":1533534368580},{"_id":"public/atom.xml","hash":"ad6366a7c448936f0708de5469dd6f8e9018db7a","modified":1533540111559},{"_id":"public/search.xml","hash":"460e69d1a58cbd523291b79667660001241e52c4","modified":1533540111559},{"_id":"public/about/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111564},{"_id":"public/categories/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111564},{"_id":"public/tags/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111564},{"_id":"public/2018/08/06/iOS横竖屏/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111564},{"_id":"public/2018/06/23/iOS模型嵌套模型/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111564},{"_id":"public/2018/06/08/ios之界面之间的数据正逆向传递方法/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111565},{"_id":"public/2018/06/05/iOS熟悉-property和set方法和get方法/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111565},{"_id":"public/2018/06/04/iOS强制横屏实践/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111565},{"_id":"public/2018/06/02/iOS仿淘宝详情页导航栏/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111565},{"_id":"public/2018/05/29/iOS开发之UITableView滚动方向/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111565},{"_id":"public/2018/05/17/熟悉UIScrollView的contentSize-contentOffset-contentInset/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111565},{"_id":"public/2018/05/13/iOS熟悉UIEdgeInsetsMake使用/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111565},{"_id":"public/2018/05/10/iOSPush任意新页面/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111565},{"_id":"public/2018/05/08/Masonry设置UIScrollView的contentSize/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111565},{"_id":"public/2018/05/05/Masonry自适应tableHeaderView/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111565},{"_id":"public/2018/05/05/Hexo插入图片/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111565},{"_id":"public/2018/05/04/iOS偷懒-效率/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111566},{"_id":"public/2018/05/03/Hexo教程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111566},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111566},{"_id":"public/archives/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111566},{"_id":"public/archives/2018/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111566},{"_id":"public/archives/2018/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111566},{"_id":"public/archives/2018/05/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111566},{"_id":"public/archives/2018/06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111566},{"_id":"public/archives/2018/08/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111566},{"_id":"public/categories/Hexo教程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111566},{"_id":"public/categories/iOS开发/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111566},{"_id":"public/categories/iOS效率/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111567},{"_id":"public/categories/iOS基础/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111567},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111567},{"_id":"public/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111567},{"_id":"public/tags/Hexo/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111568},{"_id":"public/tags/iOS/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111568},{"_id":"public/tags/iOS/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533540111568},{"_id":"public/2018/05/05/Hexo插入图片/phone.jpg","hash":"71c59572a3fe08aa89c7cbfd70ddbd022771ca64","modified":1533540111572},{"_id":"public/2018/05/13/iOS熟悉UIEdgeInsetsMake使用/按钮图片在下文字在上.png","hash":"c04696538a4fc9afa42f87f03ab33ed026d9772f","modified":1533540111572},{"_id":"public/2018/05/13/iOS熟悉UIEdgeInsetsMake使用/按钮图片在上文字在下.png","hash":"67a58fb7a74abd8223a344cd7c3c3cece1d8dd6d","modified":1533540111572},{"_id":"public/2018/05/13/iOS熟悉UIEdgeInsetsMake使用/按钮图片在右文字在左.png","hash":"94b2195755306f572bfc413ca959f16f32ca5f8b","modified":1533540111572},{"_id":"public/2018/05/13/iOS熟悉UIEdgeInsetsMake使用/按钮图片文字居中.png","hash":"07505e6147b06fa01d55c354f2eae19f7a20282c","modified":1533540111572},{"_id":"public/2018/05/17/熟悉UIScrollView的contentSize-contentOffset-contentInset/UIScrollView偏移图.png","hash":"b30c0f3983f12b36487cd7256b74441274f46a8c","modified":1533540111576},{"_id":"public/2018/06/04/iOS强制横屏实践/横竖屏1.png","hash":"8b88476b898dc27cb76081d1ca59d4c11ebb9f15","modified":1533540111576},{"_id":"public/2018/06/04/iOS强制横屏实践/横竖屏2.png","hash":"94fb93e3b2b0696d502e6a306ad975454cc33bf7","modified":1533540111578},{"_id":"public/2018/05/05/Masonry自适应tableHeaderView/tableHeaderView.gif","hash":"86f53f11f28420223b285192a148d61c5c4569c0","modified":1533540111587},{"_id":"public/2018/05/08/Masonry设置UIScrollView的contentSize/复杂UIScrollView.gif","hash":"f7e0b0d9bca3d61bf56d8a03c09715aad50fc9b6","modified":1533540111611}],"Category":[{"name":"Hexo教程","_id":"cjkhy6qu80004duu9f3raeozw"},{"name":"iOS开发","_id":"cjkhy6qul000eduu9g9bi12wp"},{"name":"iOS效率","_id":"cjkhy6quu0010duu95oqt88uq"},{"name":"iOS基础","_id":"cjkhy6qux001dduu9ltz3mv48"}],"Data":[],"Page":[{"title":"关于","date":"2018-05-03T06:20:01.000Z","_content":"## 介绍\n\n>陈明: 一个菜鸟iOS开发程序员,目前混迹深圳\n\n## 联系我\n- 简书: [蜡笔小新Zzz](https://www.jianshu.com/u/b4ae99514453)\n- GitHub: [sinaming](https://github.com/sinaming)\n- QQ：562510342\n- Email: sina137802855@163.com","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2018-05-03 14:20:01\n---\n## 介绍\n\n>陈明: 一个菜鸟iOS开发程序员,目前混迹深圳\n\n## 联系我\n- 简书: [蜡笔小新Zzz](https://www.jianshu.com/u/b4ae99514453)\n- GitHub: [sinaming](https://github.com/sinaming)\n- QQ：562510342\n- Email: sina137802855@163.com","updated":"2018-08-06T05:46:08.587Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjkhy6qu30001duu9rfqdxabi","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>陈明: 一个菜鸟iOS开发程序员,目前混迹深圳</p>\n</blockquote>\n<h2 id=\"联系我\"><a href=\"#联系我\" class=\"headerlink\" title=\"联系我\"></a>联系我</h2><ul>\n<li>简书: <a href=\"https://www.jianshu.com/u/b4ae99514453\" target=\"_blank\" rel=\"noopener\">蜡笔小新Zzz</a></li>\n<li>GitHub: <a href=\"https://github.com/sinaming\" target=\"_blank\" rel=\"noopener\">sinaming</a></li>\n<li>QQ：562510342</li>\n<li>Email: <a href=\"mailto:sina137802855@163.com\" target=\"_blank\" rel=\"noopener\">sina137802855@163.com</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>陈明: 一个菜鸟iOS开发程序员,目前混迹深圳</p>\n</blockquote>\n<h2 id=\"联系我\"><a href=\"#联系我\" class=\"headerlink\" title=\"联系我\"></a>联系我</h2><ul>\n<li>简书: <a href=\"https://www.jianshu.com/u/b4ae99514453\" target=\"_blank\" rel=\"noopener\">蜡笔小新Zzz</a></li>\n<li>GitHub: <a href=\"https://github.com/sinaming\" target=\"_blank\" rel=\"noopener\">sinaming</a></li>\n<li>QQ：562510342</li>\n<li>Email: <a href=\"mailto:sina137802855@163.com\" target=\"_blank\" rel=\"noopener\">sina137802855@163.com</a></li>\n</ul>\n"},{"title":"分类","date":"2018-05-03T07:44:29.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-05-03 15:44:29\ntype: \"categories\"\n---\n","updated":"2018-08-06T05:46:08.587Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjkhy6qu60003duu99p3utoxz","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-05-03T06:15:50.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-05-03 14:15:50\ntype: \"tags\"\n---\n","updated":"2018-08-06T05:46:08.587Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjkhy6qv2001pduu9ejl2stgh","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hexo插入图片","date":"2018-05-05T02:10:12.000Z","_content":"\n## 前言\n\n>当我们想在博客上上传图片,如果直接引用本地图片,会存在很多问题,图片损坏等\n\n\n## 解决\n\n- 在`hexo`文件夹中找到`_config.yml`里的`post_asset_folder`:这个选项设置为`true`\n\n- 在`hexo`目录下执行这样一句话`npm install hexo-asset-image --save`命令,来安装一个可以上传图片的插件\n\n<!--more-->\n\n- 命令创建`hexo -n xxxx.md`,执行完成之后,会在`/source/_posts`文件夹内除了`xxxx.md`文件还有一个同名的文件夹\n\n- 最后把图片复杂到`xxxx.md`的文件夹中,按照这样的方式`![你想输入的替代文字](xxxx/图片名.jpg)`\n\n## 举例\n![phone](Hexo插入图片/phone.jpg)\n\n>如果完成上面操作,会实现显示自己添加的图片,说明已经完成\n\n\n## 参考文档\n[hexo生成博文插入图片](https://blog.csdn.net/sugar_rainbow/article/details/57415705)","source":"_posts/Hexo插入图片.md","raw":"---\ntitle: Hexo插入图片\ndate: 2018-05-05 10:10:12\ntags: \"Hexo\"\ncategories: \"Hexo教程\"\n---\n\n## 前言\n\n>当我们想在博客上上传图片,如果直接引用本地图片,会存在很多问题,图片损坏等\n\n\n## 解决\n\n- 在`hexo`文件夹中找到`_config.yml`里的`post_asset_folder`:这个选项设置为`true`\n\n- 在`hexo`目录下执行这样一句话`npm install hexo-asset-image --save`命令,来安装一个可以上传图片的插件\n\n<!--more-->\n\n- 命令创建`hexo -n xxxx.md`,执行完成之后,会在`/source/_posts`文件夹内除了`xxxx.md`文件还有一个同名的文件夹\n\n- 最后把图片复杂到`xxxx.md`的文件夹中,按照这样的方式`![你想输入的替代文字](xxxx/图片名.jpg)`\n\n## 举例\n![phone](Hexo插入图片/phone.jpg)\n\n>如果完成上面操作,会实现显示自己添加的图片,说明已经完成\n\n\n## 参考文档\n[hexo生成博文插入图片](https://blog.csdn.net/sugar_rainbow/article/details/57415705)","slug":"Hexo插入图片","published":1,"updated":"2018-08-06T05:46:08.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkhy6qu00000duu9imooznf3","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>当我们想在博客上上传图片,如果直接引用本地图片,会存在很多问题,图片损坏等</p>\n</blockquote>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><ul>\n<li><p>在<code>hexo</code>文件夹中找到<code>_config.yml</code>里的<code>post_asset_folder</code>:这个选项设置为<code>true</code></p>\n</li>\n<li><p>在<code>hexo</code>目录下执行这样一句话<code>npm install hexo-asset-image --save</code>命令,来安装一个可以上传图片的插件</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p>命令创建<code>hexo -n xxxx.md</code>,执行完成之后,会在<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹</p>\n</li>\n<li><p>最后把图片复杂到<code>xxxx.md</code>的文件夹中,按照这样的方式<code>![你想输入的替代文字](xxxx/图片名.jpg)</code></p>\n</li>\n</ul>\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><p><img src=\"/2018/05/05/Hexo插入图片/phone.jpg\" alt=\"phone\"></p>\n<blockquote>\n<p>如果完成上面操作,会实现显示自己添加的图片,说明已经完成</p>\n</blockquote>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://blog.csdn.net/sugar_rainbow/article/details/57415705\" target=\"_blank\" rel=\"noopener\">hexo生成博文插入图片</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>当我们想在博客上上传图片,如果直接引用本地图片,会存在很多问题,图片损坏等</p>\n</blockquote>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><ul>\n<li><p>在<code>hexo</code>文件夹中找到<code>_config.yml</code>里的<code>post_asset_folder</code>:这个选项设置为<code>true</code></p>\n</li>\n<li><p>在<code>hexo</code>目录下执行这样一句话<code>npm install hexo-asset-image --save</code>命令,来安装一个可以上传图片的插件</p>\n</li>\n</ul>","more":"<ul>\n<li><p>命令创建<code>hexo -n xxxx.md</code>,执行完成之后,会在<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹</p>\n</li>\n<li><p>最后把图片复杂到<code>xxxx.md</code>的文件夹中,按照这样的方式<code>![你想输入的替代文字](xxxx/图片名.jpg)</code></p>\n</li>\n</ul>\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><p><img src=\"/2018/05/05/Hexo插入图片/phone.jpg\" alt=\"phone\"></p>\n<blockquote>\n<p>如果完成上面操作,会实现显示自己添加的图片,说明已经完成</p>\n</blockquote>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://blog.csdn.net/sugar_rainbow/article/details/57415705\" target=\"_blank\" rel=\"noopener\">hexo生成博文插入图片</a></p>"},{"title":"Hexo教程","date":"2018-05-03T08:28:19.000Z","_content":"\n## 配置Node.js环境\n\n**Node.js: [Node.js官网](https://nodejs.org/en/#download)**\n\n![图片](http://upload-images.jianshu.io/upload_images/727768-fb3a458f1555ea46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!--more-->\n\n**下载成功之后是这样的一个文件:**\n\n![图片](http://upload-images.jianshu.io/upload_images/727768-de9f36c841717341.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 安装 Node.js 和npm\n\n![图片](http://upload-images.jianshu.io/upload_images/727768-2cf4a54b45c7bf90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**终端下测试下Node.js是否可以使用:**\n\n```\nnode -v\n```\n\n**如果Node.js 成功安装，可以看到类似如下的信息:**\n\n```\n$ node -v\nv10.0.0\n```\n\n**终端下测试下npm是否可以使用:**\n\n```\nnpm -v\n```\n\n**如果npm成功安装，可以看到类似如下的信息:**\n\n```\n$ npm -v\n5.6.0\n```\n\n>全部完成上面的配置,已经完成第一步\n\n## 搭建GitHub博客\n\n进入`GitHub`,我们新建一个名为`用户名.github.io`的仓库,`用户名`其实就是你自己`GitHub用户名`\n\n## 安装Hexo\n\n- 终端中执行`npm install hexo-cli -g`\n\n- `桌面`或者`自己熟悉的地方`,通过`终端`创建mkdir`hexo`文件夹\n\n- 进入`hexo`文件夹,执行`hexo init`\n\n**完成之后执行下面方法:**\n```\nhexo generate\t创建静态页面\t\nhexo server\t启动服务\n```\n\n- 缩写`hexo g | hexo s`\n\n- 登录本地`localhost:4000`\n\n** 启动服务,会显示下面页面 **\n![图片](http://onq81n53u.bkt.clouddn.com/YY%E5%9B%BE%E7%89%8720180110175140.jpg)\n\n\n- 接下来,我们就是把创建好的`hexo`项目,配置上传`GitHub`的前提条件\n\n- 找到`hexo`文件夹下面的`_config.yml`文件\n\n## 配置Hexo主题\n\n- 把这段代码放置`_config.yml`文件的最后面,其中`GitHub用户名`是你自己在`GitHub`中创建的仓库对于的`信息`\n\n```\ndeploy:\n  type: git\n  repository:\n            github: https://github.com/GitHub用户名/GitHub用户名.github.io.git\n  branch: master\n```\n\n >这样我们就完成了对`hexo`的基础搭建和配置\n\n## 同步GitHub\n\n- 终端执行`npm install hexo-deployer-git --save`\n\n- 完成上面的全部操作,我们博客基本完成,相应的主题配置自行`百度`,`Google`\n\n**开始同步**\n```\nhexo clean\n\nhexo generate\n\nhexo deployer\n```\n\n- 缩写`hexo d -g`执行\n\n- 浏览器中输入`https://GitHub用户名.github.io`,如果成功会显示上面同样的页面\n\n## 最后\n- 如果你已经看到这里,说明已经完成了对博客的搭建,我们就可以开心的撸博客了!!!","source":"_posts/Hexo教程.md","raw":"---\ntitle: Hexo教程\ndate: 2018-05-03 16:28:19\ntags: \"Hexo\"\ncategories: \"Hexo教程\"\n---\n\n## 配置Node.js环境\n\n**Node.js: [Node.js官网](https://nodejs.org/en/#download)**\n\n![图片](http://upload-images.jianshu.io/upload_images/727768-fb3a458f1555ea46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!--more-->\n\n**下载成功之后是这样的一个文件:**\n\n![图片](http://upload-images.jianshu.io/upload_images/727768-de9f36c841717341.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 安装 Node.js 和npm\n\n![图片](http://upload-images.jianshu.io/upload_images/727768-2cf4a54b45c7bf90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**终端下测试下Node.js是否可以使用:**\n\n```\nnode -v\n```\n\n**如果Node.js 成功安装，可以看到类似如下的信息:**\n\n```\n$ node -v\nv10.0.0\n```\n\n**终端下测试下npm是否可以使用:**\n\n```\nnpm -v\n```\n\n**如果npm成功安装，可以看到类似如下的信息:**\n\n```\n$ npm -v\n5.6.0\n```\n\n>全部完成上面的配置,已经完成第一步\n\n## 搭建GitHub博客\n\n进入`GitHub`,我们新建一个名为`用户名.github.io`的仓库,`用户名`其实就是你自己`GitHub用户名`\n\n## 安装Hexo\n\n- 终端中执行`npm install hexo-cli -g`\n\n- `桌面`或者`自己熟悉的地方`,通过`终端`创建mkdir`hexo`文件夹\n\n- 进入`hexo`文件夹,执行`hexo init`\n\n**完成之后执行下面方法:**\n```\nhexo generate\t创建静态页面\t\nhexo server\t启动服务\n```\n\n- 缩写`hexo g | hexo s`\n\n- 登录本地`localhost:4000`\n\n** 启动服务,会显示下面页面 **\n![图片](http://onq81n53u.bkt.clouddn.com/YY%E5%9B%BE%E7%89%8720180110175140.jpg)\n\n\n- 接下来,我们就是把创建好的`hexo`项目,配置上传`GitHub`的前提条件\n\n- 找到`hexo`文件夹下面的`_config.yml`文件\n\n## 配置Hexo主题\n\n- 把这段代码放置`_config.yml`文件的最后面,其中`GitHub用户名`是你自己在`GitHub`中创建的仓库对于的`信息`\n\n```\ndeploy:\n  type: git\n  repository:\n            github: https://github.com/GitHub用户名/GitHub用户名.github.io.git\n  branch: master\n```\n\n >这样我们就完成了对`hexo`的基础搭建和配置\n\n## 同步GitHub\n\n- 终端执行`npm install hexo-deployer-git --save`\n\n- 完成上面的全部操作,我们博客基本完成,相应的主题配置自行`百度`,`Google`\n\n**开始同步**\n```\nhexo clean\n\nhexo generate\n\nhexo deployer\n```\n\n- 缩写`hexo d -g`执行\n\n- 浏览器中输入`https://GitHub用户名.github.io`,如果成功会显示上面同样的页面\n\n## 最后\n- 如果你已经看到这里,说明已经完成了对博客的搭建,我们就可以开心的撸博客了!!!","slug":"Hexo教程","published":1,"updated":"2018-08-06T05:46:08.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkhy6qu40002duu9idlmf0a1","content":"<h2 id=\"配置Node-js环境\"><a href=\"#配置Node-js环境\" class=\"headerlink\" title=\"配置Node.js环境\"></a>配置Node.js环境</h2><p><strong>Node.js: <a href=\"https://nodejs.org/en/#download\" target=\"_blank\" rel=\"noopener\">Node.js官网</a></strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/727768-fb3a458f1555ea46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片\"></p>\n<a id=\"more\"></a>\n<p><strong>下载成功之后是这样的一个文件:</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/727768-de9f36c841717341.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片\"></p>\n<h2 id=\"安装-Node-js-和npm\"><a href=\"#安装-Node-js-和npm\" class=\"headerlink\" title=\"安装 Node.js 和npm\"></a>安装 Node.js 和npm</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/727768-2cf4a54b45c7bf90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片\"></p>\n<p><strong>终端下测试下Node.js是否可以使用:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br></pre></td></tr></table></figure>\n<p><strong>如果Node.js 成功安装，可以看到类似如下的信息:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br><span class=\"line\">v10.0.0</span><br></pre></td></tr></table></figure>\n<p><strong>终端下测试下npm是否可以使用:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm -v</span><br></pre></td></tr></table></figure>\n<p><strong>如果npm成功安装，可以看到类似如下的信息:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm -v</span><br><span class=\"line\">5.6.0</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>全部完成上面的配置,已经完成第一步</p>\n</blockquote>\n<h2 id=\"搭建GitHub博客\"><a href=\"#搭建GitHub博客\" class=\"headerlink\" title=\"搭建GitHub博客\"></a>搭建GitHub博客</h2><p>进入<code>GitHub</code>,我们新建一个名为<code>用户名.github.io</code>的仓库,<code>用户名</code>其实就是你自己<code>GitHub用户名</code></p>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><ul>\n<li><p>终端中执行<code>npm install hexo-cli -g</code></p>\n</li>\n<li><p><code>桌面</code>或者<code>自己熟悉的地方</code>,通过<code>终端</code>创建mkdir<code>hexo</code>文件夹</p>\n</li>\n<li><p>进入<code>hexo</code>文件夹,执行<code>hexo init</code></p>\n</li>\n</ul>\n<p><strong>完成之后执行下面方法:</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate\t创建静态页面\t</span><br><span class=\"line\">hexo server\t启动服务</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>缩写<code>hexo g | hexo s</code></p>\n</li>\n<li><p>登录本地<code>localhost:4000</code></p>\n</li>\n</ul>\n<p><strong> 启动服务,会显示下面页面 </strong><br><img src=\"http://onq81n53u.bkt.clouddn.com/YY%E5%9B%BE%E7%89%8720180110175140.jpg\" alt=\"图片\"></p>\n<ul>\n<li><p>接下来,我们就是把创建好的<code>hexo</code>项目,配置上传<code>GitHub</code>的前提条件</p>\n</li>\n<li><p>找到<code>hexo</code>文件夹下面的<code>_config.yml</code>文件</p>\n</li>\n</ul>\n<h2 id=\"配置Hexo主题\"><a href=\"#配置Hexo主题\" class=\"headerlink\" title=\"配置Hexo主题\"></a>配置Hexo主题</h2><ul>\n<li>把这段代码放置<code>_config.yml</code>文件的最后面,其中<code>GitHub用户名</code>是你自己在<code>GitHub</code>中创建的仓库对于的<code>信息</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository:</span><br><span class=\"line\">            github: https://github.com/GitHub用户名/GitHub用户名.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这样我们就完成了对<code>hexo</code>的基础搭建和配置</p>\n</blockquote>\n<h2 id=\"同步GitHub\"><a href=\"#同步GitHub\" class=\"headerlink\" title=\"同步GitHub\"></a>同步GitHub</h2><ul>\n<li><p>终端执行<code>npm install hexo-deployer-git --save</code></p>\n</li>\n<li><p>完成上面的全部操作,我们博客基本完成,相应的主题配置自行<code>百度</code>,<code>Google</code></p>\n</li>\n</ul>\n<p><strong>开始同步</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\"></span><br><span class=\"line\">hexo generate</span><br><span class=\"line\"></span><br><span class=\"line\">hexo deployer</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>缩写<code>hexo d -g</code>执行</p>\n</li>\n<li><p>浏览器中输入<code>https://GitHub用户名.github.io</code>,如果成功会显示上面同样的页面</p>\n</li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><ul>\n<li>如果你已经看到这里,说明已经完成了对博客的搭建,我们就可以开心的撸博客了!!!</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"配置Node-js环境\"><a href=\"#配置Node-js环境\" class=\"headerlink\" title=\"配置Node.js环境\"></a>配置Node.js环境</h2><p><strong>Node.js: <a href=\"https://nodejs.org/en/#download\" target=\"_blank\" rel=\"noopener\">Node.js官网</a></strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/727768-fb3a458f1555ea46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片\"></p>","more":"<p><strong>下载成功之后是这样的一个文件:</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/727768-de9f36c841717341.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片\"></p>\n<h2 id=\"安装-Node-js-和npm\"><a href=\"#安装-Node-js-和npm\" class=\"headerlink\" title=\"安装 Node.js 和npm\"></a>安装 Node.js 和npm</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/727768-2cf4a54b45c7bf90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片\"></p>\n<p><strong>终端下测试下Node.js是否可以使用:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br></pre></td></tr></table></figure>\n<p><strong>如果Node.js 成功安装，可以看到类似如下的信息:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br><span class=\"line\">v10.0.0</span><br></pre></td></tr></table></figure>\n<p><strong>终端下测试下npm是否可以使用:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm -v</span><br></pre></td></tr></table></figure>\n<p><strong>如果npm成功安装，可以看到类似如下的信息:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm -v</span><br><span class=\"line\">5.6.0</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>全部完成上面的配置,已经完成第一步</p>\n</blockquote>\n<h2 id=\"搭建GitHub博客\"><a href=\"#搭建GitHub博客\" class=\"headerlink\" title=\"搭建GitHub博客\"></a>搭建GitHub博客</h2><p>进入<code>GitHub</code>,我们新建一个名为<code>用户名.github.io</code>的仓库,<code>用户名</code>其实就是你自己<code>GitHub用户名</code></p>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><ul>\n<li><p>终端中执行<code>npm install hexo-cli -g</code></p>\n</li>\n<li><p><code>桌面</code>或者<code>自己熟悉的地方</code>,通过<code>终端</code>创建mkdir<code>hexo</code>文件夹</p>\n</li>\n<li><p>进入<code>hexo</code>文件夹,执行<code>hexo init</code></p>\n</li>\n</ul>\n<p><strong>完成之后执行下面方法:</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate\t创建静态页面\t</span><br><span class=\"line\">hexo server\t启动服务</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>缩写<code>hexo g | hexo s</code></p>\n</li>\n<li><p>登录本地<code>localhost:4000</code></p>\n</li>\n</ul>\n<p><strong> 启动服务,会显示下面页面 </strong><br><img src=\"http://onq81n53u.bkt.clouddn.com/YY%E5%9B%BE%E7%89%8720180110175140.jpg\" alt=\"图片\"></p>\n<ul>\n<li><p>接下来,我们就是把创建好的<code>hexo</code>项目,配置上传<code>GitHub</code>的前提条件</p>\n</li>\n<li><p>找到<code>hexo</code>文件夹下面的<code>_config.yml</code>文件</p>\n</li>\n</ul>\n<h2 id=\"配置Hexo主题\"><a href=\"#配置Hexo主题\" class=\"headerlink\" title=\"配置Hexo主题\"></a>配置Hexo主题</h2><ul>\n<li>把这段代码放置<code>_config.yml</code>文件的最后面,其中<code>GitHub用户名</code>是你自己在<code>GitHub</code>中创建的仓库对于的<code>信息</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository:</span><br><span class=\"line\">            github: https://github.com/GitHub用户名/GitHub用户名.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这样我们就完成了对<code>hexo</code>的基础搭建和配置</p>\n</blockquote>\n<h2 id=\"同步GitHub\"><a href=\"#同步GitHub\" class=\"headerlink\" title=\"同步GitHub\"></a>同步GitHub</h2><ul>\n<li><p>终端执行<code>npm install hexo-deployer-git --save</code></p>\n</li>\n<li><p>完成上面的全部操作,我们博客基本完成,相应的主题配置自行<code>百度</code>,<code>Google</code></p>\n</li>\n</ul>\n<p><strong>开始同步</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\"></span><br><span class=\"line\">hexo generate</span><br><span class=\"line\"></span><br><span class=\"line\">hexo deployer</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>缩写<code>hexo d -g</code>执行</p>\n</li>\n<li><p>浏览器中输入<code>https://GitHub用户名.github.io</code>,如果成功会显示上面同样的页面</p>\n</li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><ul>\n<li>如果你已经看到这里,说明已经完成了对博客的搭建,我们就可以开心的撸博客了!!!</li>\n</ul>"},{"title":"Masonry自适应tableHeaderView","date":"2018-05-05T07:40:45.000Z","_content":"\n## 如题\n\n>从苹果开发约束,方便了我们快速适配iPhone手机,看到`Masonry`之后,我们就想要适配所有开发中所遇到的问题,今天就适配`Masonry`自适应`tableHeaderView`\n\n## 解答\n\n如果使用frame,计算的话肯定也是可以达到相同结果的,可是`麻烦`,所以今天就使用`Masonry`来完成这个需求\n\n- 首先, 我们一般都是自定义`View`,在这个`View`设置好约束\n\n<!--more-->\n\n**重要**\n\n- 这个自定义`View`,里面的子控件一定要有从`top`到`bottom`连起来的那一条线,就像盖房子一样的,第一个子控件到最后的个子控件,让`tableHeaderView`知道`top`到`bottom`的位置\n\n## 自定义`View`代码\n\n```\n// 这个是第一个子控件\n[self addSubview:self.oneLabel];\n[self.oneLabel mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.left.right.mas_equalTo(self).offset(0);\n}];\n\n// 这个是第二个子控件\n[self addSubview:self.oneImageView];\n[self.oneImageView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.mas_equalTo(self.oneLabel.mas_bottom).offset(0);\n    make.left.right.mas_equalTo(self).offset(0);\n}];\n\n// 重点,必须设置这个约束,告诉当前view的位置\n[self mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.bottom.mas_equalTo(self.oneImageView.mas_bottom).offset(0);\n}];\n```\n\n## `Controller`代码\n```\n// 必须给headerView设置宽度,不然headView是不知道到底有宽\nself.tableView.tableHeaderView = self.headView;\n[self.headView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.width.equalTo(self.tableView);\n}];\n```\n\n## 方案二\n>如果确定子控件底部到父视图的位置,就不需要设置父视图底部位置,如果不确定底部位置就需要设置父视图底部位置\n\n```\n[self addSubview:self.oneImageView];\n[self.oneImageView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.mas_equalTo(self.oneLabel.mas_bottom).offset(0);\n    make.left.right.bottom.mas_equalTo(self).offset(0);\n}];\n\n// 重点,必须设置这个约束,告诉当前view的位置\n//[self mas_makeConstraints:^(MASConstraintMaker *make) {\n//    make.bottom.mas_equalTo(self.oneImageView.mas_bottom).offset(0);\n//}];\n```\n\n## 方案三\n> 如果出现bug先设置好`Masonry`的`TableHeadView`,再调用`View`的`layoutIfNeeded`\n\n```\n[self.view addSubview:self.tableView];\n[self.tableView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.edges.mas_equalTo(self.view).insets(UIEdgeInsetsMake(0, 0, 0, 0));\n}];\n\n\nself.tableView.tableHeaderView = self.headView;\n[self.headView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.width.equalTo(self.tableView);\n}];\n\n[self.view setNeedsLayout];\n[self.view layoutIfNeeded];\n\nself.tableView.tableHeaderView = self.headView;\n```\n\n## 效果图\n![Masonry](Masonry自适应tableHeaderView/tableHeaderView.gif)","source":"_posts/Masonry自适应tableHeaderView.md","raw":"---\ntitle: Masonry自适应tableHeaderView\ndate: 2018-05-05 15:40:45\ntags: \"iOS\"\ncategories: \"iOS开发\"\n---\n\n## 如题\n\n>从苹果开发约束,方便了我们快速适配iPhone手机,看到`Masonry`之后,我们就想要适配所有开发中所遇到的问题,今天就适配`Masonry`自适应`tableHeaderView`\n\n## 解答\n\n如果使用frame,计算的话肯定也是可以达到相同结果的,可是`麻烦`,所以今天就使用`Masonry`来完成这个需求\n\n- 首先, 我们一般都是自定义`View`,在这个`View`设置好约束\n\n<!--more-->\n\n**重要**\n\n- 这个自定义`View`,里面的子控件一定要有从`top`到`bottom`连起来的那一条线,就像盖房子一样的,第一个子控件到最后的个子控件,让`tableHeaderView`知道`top`到`bottom`的位置\n\n## 自定义`View`代码\n\n```\n// 这个是第一个子控件\n[self addSubview:self.oneLabel];\n[self.oneLabel mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.left.right.mas_equalTo(self).offset(0);\n}];\n\n// 这个是第二个子控件\n[self addSubview:self.oneImageView];\n[self.oneImageView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.mas_equalTo(self.oneLabel.mas_bottom).offset(0);\n    make.left.right.mas_equalTo(self).offset(0);\n}];\n\n// 重点,必须设置这个约束,告诉当前view的位置\n[self mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.bottom.mas_equalTo(self.oneImageView.mas_bottom).offset(0);\n}];\n```\n\n## `Controller`代码\n```\n// 必须给headerView设置宽度,不然headView是不知道到底有宽\nself.tableView.tableHeaderView = self.headView;\n[self.headView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.width.equalTo(self.tableView);\n}];\n```\n\n## 方案二\n>如果确定子控件底部到父视图的位置,就不需要设置父视图底部位置,如果不确定底部位置就需要设置父视图底部位置\n\n```\n[self addSubview:self.oneImageView];\n[self.oneImageView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.mas_equalTo(self.oneLabel.mas_bottom).offset(0);\n    make.left.right.bottom.mas_equalTo(self).offset(0);\n}];\n\n// 重点,必须设置这个约束,告诉当前view的位置\n//[self mas_makeConstraints:^(MASConstraintMaker *make) {\n//    make.bottom.mas_equalTo(self.oneImageView.mas_bottom).offset(0);\n//}];\n```\n\n## 方案三\n> 如果出现bug先设置好`Masonry`的`TableHeadView`,再调用`View`的`layoutIfNeeded`\n\n```\n[self.view addSubview:self.tableView];\n[self.tableView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.edges.mas_equalTo(self.view).insets(UIEdgeInsetsMake(0, 0, 0, 0));\n}];\n\n\nself.tableView.tableHeaderView = self.headView;\n[self.headView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.width.equalTo(self.tableView);\n}];\n\n[self.view setNeedsLayout];\n[self.view layoutIfNeeded];\n\nself.tableView.tableHeaderView = self.headView;\n```\n\n## 效果图\n![Masonry](Masonry自适应tableHeaderView/tableHeaderView.gif)","slug":"Masonry自适应tableHeaderView","published":1,"updated":"2018-08-06T05:46:08.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkhy6qua0006duu9d3kmheaf","content":"<h2 id=\"如题\"><a href=\"#如题\" class=\"headerlink\" title=\"如题\"></a>如题</h2><blockquote>\n<p>从苹果开发约束,方便了我们快速适配iPhone手机,看到<code>Masonry</code>之后,我们就想要适配所有开发中所遇到的问题,今天就适配<code>Masonry</code>自适应<code>tableHeaderView</code></p>\n</blockquote>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>如果使用frame,计算的话肯定也是可以达到相同结果的,可是<code>麻烦</code>,所以今天就使用<code>Masonry</code>来完成这个需求</p>\n<ul>\n<li>首先, 我们一般都是自定义<code>View</code>,在这个<code>View</code>设置好约束</li>\n</ul>\n<a id=\"more\"></a>\n<p><strong>重要</strong></p>\n<ul>\n<li>这个自定义<code>View</code>,里面的子控件一定要有从<code>top</code>到<code>bottom</code>连起来的那一条线,就像盖房子一样的,第一个子控件到最后的个子控件,让<code>tableHeaderView</code>知道<code>top</code>到<code>bottom</code>的位置</li>\n</ul>\n<h2 id=\"自定义View代码\"><a href=\"#自定义View代码\" class=\"headerlink\" title=\"自定义View代码\"></a>自定义<code>View</code>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这个是第一个子控件</span><br><span class=\"line\">[self addSubview:self.oneLabel];</span><br><span class=\"line\">[self.oneLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.left.right.mas_equalTo(self).offset(0);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">// 这个是第二个子控件</span><br><span class=\"line\">[self addSubview:self.oneImageView];</span><br><span class=\"line\">[self.oneImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.mas_equalTo(self.oneLabel.mas_bottom).offset(0);</span><br><span class=\"line\">    make.left.right.mas_equalTo(self).offset(0);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">// 重点,必须设置这个约束,告诉当前view的位置</span><br><span class=\"line\">[self mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.bottom.mas_equalTo(self.oneImageView.mas_bottom).offset(0);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"Controller代码\"><a href=\"#Controller代码\" class=\"headerlink\" title=\"Controller代码\"></a><code>Controller</code>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 必须给headerView设置宽度,不然headView是不知道到底有宽</span><br><span class=\"line\">self.tableView.tableHeaderView = self.headView;</span><br><span class=\"line\">[self.headView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.width.equalTo(self.tableView);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h2><blockquote>\n<p>如果确定子控件底部到父视图的位置,就不需要设置父视图底部位置,如果不确定底部位置就需要设置父视图底部位置</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self addSubview:self.oneImageView];</span><br><span class=\"line\">[self.oneImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.mas_equalTo(self.oneLabel.mas_bottom).offset(0);</span><br><span class=\"line\">    make.left.right.bottom.mas_equalTo(self).offset(0);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">// 重点,必须设置这个约束,告诉当前view的位置</span><br><span class=\"line\">//[self mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">//    make.bottom.mas_equalTo(self.oneImageView.mas_bottom).offset(0);</span><br><span class=\"line\">//&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"方案三\"><a href=\"#方案三\" class=\"headerlink\" title=\"方案三\"></a>方案三</h2><blockquote>\n<p>如果出现bug先设置好<code>Masonry</code>的<code>TableHeadView</code>,再调用<code>View</code>的<code>layoutIfNeeded</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self.view addSubview:self.tableView];</span><br><span class=\"line\">[self.tableView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.edges.mas_equalTo(self.view).insets(UIEdgeInsetsMake(0, 0, 0, 0));</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">self.tableView.tableHeaderView = self.headView;</span><br><span class=\"line\">[self.headView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.width.equalTo(self.tableView);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[self.view setNeedsLayout];</span><br><span class=\"line\">[self.view layoutIfNeeded];</span><br><span class=\"line\"></span><br><span class=\"line\">self.tableView.tableHeaderView = self.headView;</span><br></pre></td></tr></table></figure>\n<h2 id=\"效果图\"><a href=\"#效果图\" class=\"headerlink\" title=\"效果图\"></a>效果图</h2><p><img src=\"/2018/05/05/Masonry自适应tableHeaderView/tableHeaderView.gif\" alt=\"Masonry\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"如题\"><a href=\"#如题\" class=\"headerlink\" title=\"如题\"></a>如题</h2><blockquote>\n<p>从苹果开发约束,方便了我们快速适配iPhone手机,看到<code>Masonry</code>之后,我们就想要适配所有开发中所遇到的问题,今天就适配<code>Masonry</code>自适应<code>tableHeaderView</code></p>\n</blockquote>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>如果使用frame,计算的话肯定也是可以达到相同结果的,可是<code>麻烦</code>,所以今天就使用<code>Masonry</code>来完成这个需求</p>\n<ul>\n<li>首先, 我们一般都是自定义<code>View</code>,在这个<code>View</code>设置好约束</li>\n</ul>","more":"<p><strong>重要</strong></p>\n<ul>\n<li>这个自定义<code>View</code>,里面的子控件一定要有从<code>top</code>到<code>bottom</code>连起来的那一条线,就像盖房子一样的,第一个子控件到最后的个子控件,让<code>tableHeaderView</code>知道<code>top</code>到<code>bottom</code>的位置</li>\n</ul>\n<h2 id=\"自定义View代码\"><a href=\"#自定义View代码\" class=\"headerlink\" title=\"自定义View代码\"></a>自定义<code>View</code>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这个是第一个子控件</span><br><span class=\"line\">[self addSubview:self.oneLabel];</span><br><span class=\"line\">[self.oneLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.left.right.mas_equalTo(self).offset(0);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">// 这个是第二个子控件</span><br><span class=\"line\">[self addSubview:self.oneImageView];</span><br><span class=\"line\">[self.oneImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.mas_equalTo(self.oneLabel.mas_bottom).offset(0);</span><br><span class=\"line\">    make.left.right.mas_equalTo(self).offset(0);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">// 重点,必须设置这个约束,告诉当前view的位置</span><br><span class=\"line\">[self mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.bottom.mas_equalTo(self.oneImageView.mas_bottom).offset(0);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"Controller代码\"><a href=\"#Controller代码\" class=\"headerlink\" title=\"Controller代码\"></a><code>Controller</code>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 必须给headerView设置宽度,不然headView是不知道到底有宽</span><br><span class=\"line\">self.tableView.tableHeaderView = self.headView;</span><br><span class=\"line\">[self.headView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.width.equalTo(self.tableView);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h2><blockquote>\n<p>如果确定子控件底部到父视图的位置,就不需要设置父视图底部位置,如果不确定底部位置就需要设置父视图底部位置</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self addSubview:self.oneImageView];</span><br><span class=\"line\">[self.oneImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.mas_equalTo(self.oneLabel.mas_bottom).offset(0);</span><br><span class=\"line\">    make.left.right.bottom.mas_equalTo(self).offset(0);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">// 重点,必须设置这个约束,告诉当前view的位置</span><br><span class=\"line\">//[self mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">//    make.bottom.mas_equalTo(self.oneImageView.mas_bottom).offset(0);</span><br><span class=\"line\">//&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"方案三\"><a href=\"#方案三\" class=\"headerlink\" title=\"方案三\"></a>方案三</h2><blockquote>\n<p>如果出现bug先设置好<code>Masonry</code>的<code>TableHeadView</code>,再调用<code>View</code>的<code>layoutIfNeeded</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self.view addSubview:self.tableView];</span><br><span class=\"line\">[self.tableView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.edges.mas_equalTo(self.view).insets(UIEdgeInsetsMake(0, 0, 0, 0));</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">self.tableView.tableHeaderView = self.headView;</span><br><span class=\"line\">[self.headView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.width.equalTo(self.tableView);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[self.view setNeedsLayout];</span><br><span class=\"line\">[self.view layoutIfNeeded];</span><br><span class=\"line\"></span><br><span class=\"line\">self.tableView.tableHeaderView = self.headView;</span><br></pre></td></tr></table></figure>\n<h2 id=\"效果图\"><a href=\"#效果图\" class=\"headerlink\" title=\"效果图\"></a>效果图</h2><p><img src=\"/2018/05/05/Masonry自适应tableHeaderView/tableHeaderView.gif\" alt=\"Masonry\"></p>"},{"title":"iOSPush任意新页面","date":"2018-05-10T02:19:01.000Z","_content":"## APP任意push新页面\n\n>平时`push`一般都是`[self.navigationController pushViewController:newVC animated:YES];`\n\n## 看黑板\n\n>现在通过`UIApplication`添加分类获取`UINavigationController`来实现`push`\n\n<!--more-->\n\n```\n- (UIWindow *)mainWindow {\n    return self.delegate.window;\n}\n\n- (UIViewController *)visibleViewController {\n    UIViewController *rootViewController = [self.mainWindow rootViewController];\n    return [self getVisibleViewControllerFrom:rootViewController];\n}\n\n- (UIViewController *) getVisibleViewControllerFrom:(UIViewController *) vc {\n    if ([vc isKindOfClass:[UINavigationController class]]) {\n        return [self getVisibleViewControllerFrom:[((UINavigationController *) vc) visibleViewController]];\n    } else if ([vc isKindOfClass:[UITabBarController class]]) {\n        return [self getVisibleViewControllerFrom:[((UITabBarController *) vc) selectedViewController]];\n    } else {\n        if (vc.presentedViewController) {\n            return [self getVisibleViewControllerFrom:vc.presentedViewController];\n        } else {\n            return vc;\n        }\n    }\n\n}\n\n- (UINavigationController *)visibleNavigationController {\n    return [[self visibleViewController] navigationController];\n}\n```\n\n## 调用\n\n```\nUINavigationController *navigationController = [[UIApplication sharedApplication] visibleNavigationController];\n[navigationController pushViewController:newVC animated:YES];\n```\n\n## 参考文档\n[iOS - APP任意push新页面那些事](https://blog.csdn.net/qq_34047841/article/details/59482767)","source":"_posts/iOSPush任意新页面.md","raw":"---\ntitle: iOSPush任意新页面\ndate: 2018-05-10 10:19:01\ntags: \"iOS\"\ncategories: \"iOS开发\"\n---\n## APP任意push新页面\n\n>平时`push`一般都是`[self.navigationController pushViewController:newVC animated:YES];`\n\n## 看黑板\n\n>现在通过`UIApplication`添加分类获取`UINavigationController`来实现`push`\n\n<!--more-->\n\n```\n- (UIWindow *)mainWindow {\n    return self.delegate.window;\n}\n\n- (UIViewController *)visibleViewController {\n    UIViewController *rootViewController = [self.mainWindow rootViewController];\n    return [self getVisibleViewControllerFrom:rootViewController];\n}\n\n- (UIViewController *) getVisibleViewControllerFrom:(UIViewController *) vc {\n    if ([vc isKindOfClass:[UINavigationController class]]) {\n        return [self getVisibleViewControllerFrom:[((UINavigationController *) vc) visibleViewController]];\n    } else if ([vc isKindOfClass:[UITabBarController class]]) {\n        return [self getVisibleViewControllerFrom:[((UITabBarController *) vc) selectedViewController]];\n    } else {\n        if (vc.presentedViewController) {\n            return [self getVisibleViewControllerFrom:vc.presentedViewController];\n        } else {\n            return vc;\n        }\n    }\n\n}\n\n- (UINavigationController *)visibleNavigationController {\n    return [[self visibleViewController] navigationController];\n}\n```\n\n## 调用\n\n```\nUINavigationController *navigationController = [[UIApplication sharedApplication] visibleNavigationController];\n[navigationController pushViewController:newVC animated:YES];\n```\n\n## 参考文档\n[iOS - APP任意push新页面那些事](https://blog.csdn.net/qq_34047841/article/details/59482767)","slug":"iOSPush任意新页面","published":1,"updated":"2018-08-06T05:46:08.580Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkhy6qud0007duu9ag5p3i0i","content":"<h2 id=\"APP任意push新页面\"><a href=\"#APP任意push新页面\" class=\"headerlink\" title=\"APP任意push新页面\"></a>APP任意push新页面</h2><blockquote>\n<p>平时<code>push</code>一般都是<code>[self.navigationController pushViewController:newVC animated:YES];</code></p>\n</blockquote>\n<h2 id=\"看黑板\"><a href=\"#看黑板\" class=\"headerlink\" title=\"看黑板\"></a>看黑板</h2><blockquote>\n<p>现在通过<code>UIApplication</code>添加分类获取<code>UINavigationController</code>来实现<code>push</code></p>\n</blockquote>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIWindow *)mainWindow &#123;</span><br><span class=\"line\">    return self.delegate.window;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIViewController *)visibleViewController &#123;</span><br><span class=\"line\">    UIViewController *rootViewController = [self.mainWindow rootViewController];</span><br><span class=\"line\">    return [self getVisibleViewControllerFrom:rootViewController];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIViewController *) getVisibleViewControllerFrom:(UIViewController *) vc &#123;</span><br><span class=\"line\">    if ([vc isKindOfClass:[UINavigationController class]]) &#123;</span><br><span class=\"line\">        return [self getVisibleViewControllerFrom:[((UINavigationController *) vc) visibleViewController]];</span><br><span class=\"line\">    &#125; else if ([vc isKindOfClass:[UITabBarController class]]) &#123;</span><br><span class=\"line\">        return [self getVisibleViewControllerFrom:[((UITabBarController *) vc) selectedViewController]];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        if (vc.presentedViewController) &#123;</span><br><span class=\"line\">            return [self getVisibleViewControllerFrom:vc.presentedViewController];</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return vc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (UINavigationController *)visibleNavigationController &#123;</span><br><span class=\"line\">    return [[self visibleViewController] navigationController];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UINavigationController *navigationController = [[UIApplication sharedApplication] visibleNavigationController];</span><br><span class=\"line\">[navigationController pushViewController:newVC animated:YES];</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://blog.csdn.net/qq_34047841/article/details/59482767\" target=\"_blank\" rel=\"noopener\">iOS - APP任意push新页面那些事</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"APP任意push新页面\"><a href=\"#APP任意push新页面\" class=\"headerlink\" title=\"APP任意push新页面\"></a>APP任意push新页面</h2><blockquote>\n<p>平时<code>push</code>一般都是<code>[self.navigationController pushViewController:newVC animated:YES];</code></p>\n</blockquote>\n<h2 id=\"看黑板\"><a href=\"#看黑板\" class=\"headerlink\" title=\"看黑板\"></a>看黑板</h2><blockquote>\n<p>现在通过<code>UIApplication</code>添加分类获取<code>UINavigationController</code>来实现<code>push</code></p>\n</blockquote>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIWindow *)mainWindow &#123;</span><br><span class=\"line\">    return self.delegate.window;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIViewController *)visibleViewController &#123;</span><br><span class=\"line\">    UIViewController *rootViewController = [self.mainWindow rootViewController];</span><br><span class=\"line\">    return [self getVisibleViewControllerFrom:rootViewController];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIViewController *) getVisibleViewControllerFrom:(UIViewController *) vc &#123;</span><br><span class=\"line\">    if ([vc isKindOfClass:[UINavigationController class]]) &#123;</span><br><span class=\"line\">        return [self getVisibleViewControllerFrom:[((UINavigationController *) vc) visibleViewController]];</span><br><span class=\"line\">    &#125; else if ([vc isKindOfClass:[UITabBarController class]]) &#123;</span><br><span class=\"line\">        return [self getVisibleViewControllerFrom:[((UITabBarController *) vc) selectedViewController]];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        if (vc.presentedViewController) &#123;</span><br><span class=\"line\">            return [self getVisibleViewControllerFrom:vc.presentedViewController];</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return vc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (UINavigationController *)visibleNavigationController &#123;</span><br><span class=\"line\">    return [[self visibleViewController] navigationController];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UINavigationController *navigationController = [[UIApplication sharedApplication] visibleNavigationController];</span><br><span class=\"line\">[navigationController pushViewController:newVC animated:YES];</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://blog.csdn.net/qq_34047841/article/details/59482767\" target=\"_blank\" rel=\"noopener\">iOS - APP任意push新页面那些事</a></p>"},{"title":"Masonry设置UIScrollView的contentSize,实现复杂页面开发","date":"2018-05-08T07:09:22.000Z","_content":"## 前言\n\n>开发项目中,遇到复杂页面开发,今天就使用`Masonry+UIScrollView`实现复杂页面开发\n\n## 实例图\n\n![复杂UIScrollView](Masonry设置UIScrollView的contentSize/复杂UIScrollView.gif)\n\n<!--more-->\n\n- 通过看上面的效果图,是否觉得这页面是否很复杂,不同的有不同的解答方法,今天,我就介绍下我个人的解决方案\n\n## 看黑板\n\n> 首先,我们先分析一波这个页面的具体内容和复杂程度,是否考虑使用`UITableView`或者`UIScrollView`来完成这个需求,我相信`UITableView`也是能实现这个方案,可能是我太懒!\n\n> 我们可以分为三个模块,从顶部到联系客服下面的横线为第一个模块,简称`TopView`,第二个模块图文详情模块,简称`CenterView`,第三个模块腕表参数模块,简称`BottomView`,命名请忽视,我们可以自定义三个View,分别实现里面的内容显示\n\n**`TopView`**\n\n```\n[self addSubview:self.testLabel];\n[self.testLabel mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.left.right.mas_equalTo(self).offset(0);\n}];\n\n[self addSubview:self.testButton];\n[self.testButton mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.mas_equalTo(self.testLabel.mas_bottom).offset(0);\n    make.left.right.mas_equalTo(self).offset(0);\n}];\n\n[self addSubview:self.testImageView];\n[self.testImageView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.mas_equalTo(self.testButton.mas_bottom).offset(0);\n    make.left.right.mas_equalTo(self).offset(0);\n}];\n\n// 重点,必须设置这个约束,确定底部的位置\n[self mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.bottom.mas_equalTo(self.testImageView.mas_bottom).offset(0);\n}];\n\n```\n\n* `CenterView`和`BottomView`同样设置从顶部和底部控件位置,确定当前`containerView`(容器)底部约束**这个尤为重要**\n\n**Controller**\n\n> 父视图\n`@property (nonatomic, strong) UIScrollView *scrollView;`\n\n> 容器视图\n`@property (nonatomic, strong) UIView *containerView;`\n\n> 分别创建好这两个\n\n```\n[self.view addSubview:self.scrollView];\n[self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.edges.equalTo(self.view);\n}];\n\n[self.scrollView addSubview:self.containerView];\n[self.containerView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.edges.equalTo(self.scrollView);\n    make.width.equalTo(self.scrollView);\n}];\n\n[self.containerView addSubview:self.topView];\n[self.topView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.left.right.top.mas_equalTo(self.containerView).offset(0);\n}];\n\n[self.containerView addSubview:self.centerView];\n[self.centerView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.mas_equalTo(self.topView.mas_bottom).offset(0);\n    make.left.right.mas_equalTo(self.containerView).offset(0);\n}];\n\n[self.containerView addSubview:self.bottomView];\n[self.bottomView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.mas_equalTo(self.centerView.mas_bottom).offset(0);\n    make.left.right.bottom.mas_equalTo(self.containerView).offset(0);\n}];\n\n// 这个很重要,controller里面同样需要确定containerView(容器)的底部约束\n[self.containerView mas_makeConstraints:^(MASConstraintMaker *make) {\n   make.bottom.mas_equalTo(self.bottomView.mas_bottom).offset(0);\n}];\n\n```\n\n## 最后\n- 布局页面我们已经全部都完成了,就是数据填充问题了,这样我们实行UIScrollView复杂页面开发的实现\n\n**重要的事情说三遍**\n\n1. 自定义`View`的子控件,约束必须是从`top`到`bottom`位置必须确定,接着确定自定义`View`的底部约束(就是自定义`View`底部控件的`bottom`的约束)\n\n2. 自定义`View`的子控件,约束必须是从`top`到`bottom`位置必须确定,接着确定自定义`View`的底部约束(就是自定义`View`底部控件的`bottom`的约束)\n\n3. 自定义`View`的子控件,约束必须是从`top`到`bottom`位置必须确定,接着确定自定义`View`的底部约束(就是自定义`View`底部控件的`bottom`的约束)\n\n## 修改`View`约束动画\n```\n- (void)updateConstraints {\n    // remake会将之前的全部移除，然后重新添加\n    __weak __typeof(self) weakSelf = self;\n    [self.testButton mas_remakeConstraints:^(MASConstraintMaker *make) {\n        make.top.mas_equalTo(self.testLabel.mas_bottom).offset(0);\n        make.left.right.mas_equalTo(self).offset(0);\n        if (weakSelf.isExpanded) {\n            make.height.mas_equalTo(200);\n        } else {\n            make.height.mas_equalTo(40);\n        }\n    }];\n    \n    [super updateConstraints];\n}\n\n// 响应时间处理\n- (void)onGrowButtonTaped:(UIButton *)sender {\n    self.isExpanded = !self.isExpanded;\n    if (!self.isExpanded) {\n        [self.testButton setTitle:@\"点我展开\" forState:UIControlStateNormal];\n    } else {\n        [self.testButton setTitle:@\"点我收起\" forState:UIControlStateNormal];\n    }\n\n    // 告诉self.view约束需要更新\n    [self setNeedsUpdateConstraints];\n    // 调用此方法告诉self.view检测是否需要更新约束，若需要则更新，下面添加动画效果才起作用\n    [self updateConstraintsIfNeeded];\n\n    [UIView animateWithDuration:0.3 animations:^{\n        [self layoutIfNeeded];\n    }];\n}\n```","source":"_posts/Masonry设置UIScrollView的contentSize.md","raw":"---\ntitle: Masonry设置UIScrollView的contentSize,实现复杂页面开发\ndate: 2018-05-08 15:09:22\ntags: \"iOS\"\ncategories: \"iOS开发\"\n---\n## 前言\n\n>开发项目中,遇到复杂页面开发,今天就使用`Masonry+UIScrollView`实现复杂页面开发\n\n## 实例图\n\n![复杂UIScrollView](Masonry设置UIScrollView的contentSize/复杂UIScrollView.gif)\n\n<!--more-->\n\n- 通过看上面的效果图,是否觉得这页面是否很复杂,不同的有不同的解答方法,今天,我就介绍下我个人的解决方案\n\n## 看黑板\n\n> 首先,我们先分析一波这个页面的具体内容和复杂程度,是否考虑使用`UITableView`或者`UIScrollView`来完成这个需求,我相信`UITableView`也是能实现这个方案,可能是我太懒!\n\n> 我们可以分为三个模块,从顶部到联系客服下面的横线为第一个模块,简称`TopView`,第二个模块图文详情模块,简称`CenterView`,第三个模块腕表参数模块,简称`BottomView`,命名请忽视,我们可以自定义三个View,分别实现里面的内容显示\n\n**`TopView`**\n\n```\n[self addSubview:self.testLabel];\n[self.testLabel mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.left.right.mas_equalTo(self).offset(0);\n}];\n\n[self addSubview:self.testButton];\n[self.testButton mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.mas_equalTo(self.testLabel.mas_bottom).offset(0);\n    make.left.right.mas_equalTo(self).offset(0);\n}];\n\n[self addSubview:self.testImageView];\n[self.testImageView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.mas_equalTo(self.testButton.mas_bottom).offset(0);\n    make.left.right.mas_equalTo(self).offset(0);\n}];\n\n// 重点,必须设置这个约束,确定底部的位置\n[self mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.bottom.mas_equalTo(self.testImageView.mas_bottom).offset(0);\n}];\n\n```\n\n* `CenterView`和`BottomView`同样设置从顶部和底部控件位置,确定当前`containerView`(容器)底部约束**这个尤为重要**\n\n**Controller**\n\n> 父视图\n`@property (nonatomic, strong) UIScrollView *scrollView;`\n\n> 容器视图\n`@property (nonatomic, strong) UIView *containerView;`\n\n> 分别创建好这两个\n\n```\n[self.view addSubview:self.scrollView];\n[self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.edges.equalTo(self.view);\n}];\n\n[self.scrollView addSubview:self.containerView];\n[self.containerView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.edges.equalTo(self.scrollView);\n    make.width.equalTo(self.scrollView);\n}];\n\n[self.containerView addSubview:self.topView];\n[self.topView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.left.right.top.mas_equalTo(self.containerView).offset(0);\n}];\n\n[self.containerView addSubview:self.centerView];\n[self.centerView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.mas_equalTo(self.topView.mas_bottom).offset(0);\n    make.left.right.mas_equalTo(self.containerView).offset(0);\n}];\n\n[self.containerView addSubview:self.bottomView];\n[self.bottomView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.mas_equalTo(self.centerView.mas_bottom).offset(0);\n    make.left.right.bottom.mas_equalTo(self.containerView).offset(0);\n}];\n\n// 这个很重要,controller里面同样需要确定containerView(容器)的底部约束\n[self.containerView mas_makeConstraints:^(MASConstraintMaker *make) {\n   make.bottom.mas_equalTo(self.bottomView.mas_bottom).offset(0);\n}];\n\n```\n\n## 最后\n- 布局页面我们已经全部都完成了,就是数据填充问题了,这样我们实行UIScrollView复杂页面开发的实现\n\n**重要的事情说三遍**\n\n1. 自定义`View`的子控件,约束必须是从`top`到`bottom`位置必须确定,接着确定自定义`View`的底部约束(就是自定义`View`底部控件的`bottom`的约束)\n\n2. 自定义`View`的子控件,约束必须是从`top`到`bottom`位置必须确定,接着确定自定义`View`的底部约束(就是自定义`View`底部控件的`bottom`的约束)\n\n3. 自定义`View`的子控件,约束必须是从`top`到`bottom`位置必须确定,接着确定自定义`View`的底部约束(就是自定义`View`底部控件的`bottom`的约束)\n\n## 修改`View`约束动画\n```\n- (void)updateConstraints {\n    // remake会将之前的全部移除，然后重新添加\n    __weak __typeof(self) weakSelf = self;\n    [self.testButton mas_remakeConstraints:^(MASConstraintMaker *make) {\n        make.top.mas_equalTo(self.testLabel.mas_bottom).offset(0);\n        make.left.right.mas_equalTo(self).offset(0);\n        if (weakSelf.isExpanded) {\n            make.height.mas_equalTo(200);\n        } else {\n            make.height.mas_equalTo(40);\n        }\n    }];\n    \n    [super updateConstraints];\n}\n\n// 响应时间处理\n- (void)onGrowButtonTaped:(UIButton *)sender {\n    self.isExpanded = !self.isExpanded;\n    if (!self.isExpanded) {\n        [self.testButton setTitle:@\"点我展开\" forState:UIControlStateNormal];\n    } else {\n        [self.testButton setTitle:@\"点我收起\" forState:UIControlStateNormal];\n    }\n\n    // 告诉self.view约束需要更新\n    [self setNeedsUpdateConstraints];\n    // 调用此方法告诉self.view检测是否需要更新约束，若需要则更新，下面添加动画效果才起作用\n    [self updateConstraintsIfNeeded];\n\n    [UIView animateWithDuration:0.3 animations:^{\n        [self layoutIfNeeded];\n    }];\n}\n```","slug":"Masonry设置UIScrollView的contentSize","published":1,"updated":"2018-08-06T05:46:08.574Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkhy6que0008duu9p2lxey2v","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>开发项目中,遇到复杂页面开发,今天就使用<code>Masonry+UIScrollView</code>实现复杂页面开发</p>\n</blockquote>\n<h2 id=\"实例图\"><a href=\"#实例图\" class=\"headerlink\" title=\"实例图\"></a>实例图</h2><p><img src=\"/2018/05/08/Masonry设置UIScrollView的contentSize/复杂UIScrollView.gif\" alt=\"复杂UIScrollView\"></p>\n<a id=\"more\"></a>\n<ul>\n<li>通过看上面的效果图,是否觉得这页面是否很复杂,不同的有不同的解答方法,今天,我就介绍下我个人的解决方案</li>\n</ul>\n<h2 id=\"看黑板\"><a href=\"#看黑板\" class=\"headerlink\" title=\"看黑板\"></a>看黑板</h2><blockquote>\n<p>首先,我们先分析一波这个页面的具体内容和复杂程度,是否考虑使用<code>UITableView</code>或者<code>UIScrollView</code>来完成这个需求,我相信<code>UITableView</code>也是能实现这个方案,可能是我太懒!</p>\n</blockquote>\n<blockquote>\n<p>我们可以分为三个模块,从顶部到联系客服下面的横线为第一个模块,简称<code>TopView</code>,第二个模块图文详情模块,简称<code>CenterView</code>,第三个模块腕表参数模块,简称<code>BottomView</code>,命名请忽视,我们可以自定义三个View,分别实现里面的内容显示</p>\n</blockquote>\n<p><strong><code>TopView</code></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self addSubview:self.testLabel];</span><br><span class=\"line\">[self.testLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.left.right.mas_equalTo(self).offset(0);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[self addSubview:self.testButton];</span><br><span class=\"line\">[self.testButton mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.mas_equalTo(self.testLabel.mas_bottom).offset(0);</span><br><span class=\"line\">    make.left.right.mas_equalTo(self).offset(0);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[self addSubview:self.testImageView];</span><br><span class=\"line\">[self.testImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.mas_equalTo(self.testButton.mas_bottom).offset(0);</span><br><span class=\"line\">    make.left.right.mas_equalTo(self).offset(0);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">// 重点,必须设置这个约束,确定底部的位置</span><br><span class=\"line\">[self mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.bottom.mas_equalTo(self.testImageView.mas_bottom).offset(0);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>CenterView</code>和<code>BottomView</code>同样设置从顶部和底部控件位置,确定当前<code>containerView</code>(容器)底部约束<strong>这个尤为重要</strong></li>\n</ul>\n<p><strong>Controller</strong></p>\n<blockquote>\n<p>父视图<br><code>@property (nonatomic, strong) UIScrollView *scrollView;</code></p>\n</blockquote>\n<blockquote>\n<p>容器视图<br><code>@property (nonatomic, strong) UIView *containerView;</code></p>\n</blockquote>\n<blockquote>\n<p>分别创建好这两个</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self.view addSubview:self.scrollView];</span><br><span class=\"line\">[self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.edges.equalTo(self.view);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[self.scrollView addSubview:self.containerView];</span><br><span class=\"line\">[self.containerView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.edges.equalTo(self.scrollView);</span><br><span class=\"line\">    make.width.equalTo(self.scrollView);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[self.containerView addSubview:self.topView];</span><br><span class=\"line\">[self.topView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.left.right.top.mas_equalTo(self.containerView).offset(0);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[self.containerView addSubview:self.centerView];</span><br><span class=\"line\">[self.centerView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.mas_equalTo(self.topView.mas_bottom).offset(0);</span><br><span class=\"line\">    make.left.right.mas_equalTo(self.containerView).offset(0);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[self.containerView addSubview:self.bottomView];</span><br><span class=\"line\">[self.bottomView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.mas_equalTo(self.centerView.mas_bottom).offset(0);</span><br><span class=\"line\">    make.left.right.bottom.mas_equalTo(self.containerView).offset(0);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">// 这个很重要,controller里面同样需要确定containerView(容器)的底部约束</span><br><span class=\"line\">[self.containerView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">   make.bottom.mas_equalTo(self.bottomView.mas_bottom).offset(0);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><ul>\n<li>布局页面我们已经全部都完成了,就是数据填充问题了,这样我们实行UIScrollView复杂页面开发的实现</li>\n</ul>\n<p><strong>重要的事情说三遍</strong></p>\n<ol>\n<li><p>自定义<code>View</code>的子控件,约束必须是从<code>top</code>到<code>bottom</code>位置必须确定,接着确定自定义<code>View</code>的底部约束(就是自定义<code>View</code>底部控件的<code>bottom</code>的约束)</p>\n</li>\n<li><p>自定义<code>View</code>的子控件,约束必须是从<code>top</code>到<code>bottom</code>位置必须确定,接着确定自定义<code>View</code>的底部约束(就是自定义<code>View</code>底部控件的<code>bottom</code>的约束)</p>\n</li>\n<li><p>自定义<code>View</code>的子控件,约束必须是从<code>top</code>到<code>bottom</code>位置必须确定,接着确定自定义<code>View</code>的底部约束(就是自定义<code>View</code>底部控件的<code>bottom</code>的约束)</p>\n</li>\n</ol>\n<h2 id=\"修改View约束动画\"><a href=\"#修改View约束动画\" class=\"headerlink\" title=\"修改View约束动画\"></a>修改<code>View</code>约束动画</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)updateConstraints &#123;</span><br><span class=\"line\">    // remake会将之前的全部移除，然后重新添加</span><br><span class=\"line\">    __weak __typeof(self) weakSelf = self;</span><br><span class=\"line\">    [self.testButton mas_remakeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">        make.top.mas_equalTo(self.testLabel.mas_bottom).offset(0);</span><br><span class=\"line\">        make.left.right.mas_equalTo(self).offset(0);</span><br><span class=\"line\">        if (weakSelf.isExpanded) &#123;</span><br><span class=\"line\">            make.height.mas_equalTo(200);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            make.height.mas_equalTo(40);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [super updateConstraints];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 响应时间处理</span><br><span class=\"line\">- (void)onGrowButtonTaped:(UIButton *)sender &#123;</span><br><span class=\"line\">    self.isExpanded = !self.isExpanded;</span><br><span class=\"line\">    if (!self.isExpanded) &#123;</span><br><span class=\"line\">        [self.testButton setTitle:@&quot;点我展开&quot; forState:UIControlStateNormal];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        [self.testButton setTitle:@&quot;点我收起&quot; forState:UIControlStateNormal];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 告诉self.view约束需要更新</span><br><span class=\"line\">    [self setNeedsUpdateConstraints];</span><br><span class=\"line\">    // 调用此方法告诉self.view检测是否需要更新约束，若需要则更新，下面添加动画效果才起作用</span><br><span class=\"line\">    [self updateConstraintsIfNeeded];</span><br><span class=\"line\"></span><br><span class=\"line\">    [UIView animateWithDuration:0.3 animations:^&#123;</span><br><span class=\"line\">        [self layoutIfNeeded];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>开发项目中,遇到复杂页面开发,今天就使用<code>Masonry+UIScrollView</code>实现复杂页面开发</p>\n</blockquote>\n<h2 id=\"实例图\"><a href=\"#实例图\" class=\"headerlink\" title=\"实例图\"></a>实例图</h2><p><img src=\"/2018/05/08/Masonry设置UIScrollView的contentSize/复杂UIScrollView.gif\" alt=\"复杂UIScrollView\"></p>","more":"<ul>\n<li>通过看上面的效果图,是否觉得这页面是否很复杂,不同的有不同的解答方法,今天,我就介绍下我个人的解决方案</li>\n</ul>\n<h2 id=\"看黑板\"><a href=\"#看黑板\" class=\"headerlink\" title=\"看黑板\"></a>看黑板</h2><blockquote>\n<p>首先,我们先分析一波这个页面的具体内容和复杂程度,是否考虑使用<code>UITableView</code>或者<code>UIScrollView</code>来完成这个需求,我相信<code>UITableView</code>也是能实现这个方案,可能是我太懒!</p>\n</blockquote>\n<blockquote>\n<p>我们可以分为三个模块,从顶部到联系客服下面的横线为第一个模块,简称<code>TopView</code>,第二个模块图文详情模块,简称<code>CenterView</code>,第三个模块腕表参数模块,简称<code>BottomView</code>,命名请忽视,我们可以自定义三个View,分别实现里面的内容显示</p>\n</blockquote>\n<p><strong><code>TopView</code></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self addSubview:self.testLabel];</span><br><span class=\"line\">[self.testLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.left.right.mas_equalTo(self).offset(0);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[self addSubview:self.testButton];</span><br><span class=\"line\">[self.testButton mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.mas_equalTo(self.testLabel.mas_bottom).offset(0);</span><br><span class=\"line\">    make.left.right.mas_equalTo(self).offset(0);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[self addSubview:self.testImageView];</span><br><span class=\"line\">[self.testImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.mas_equalTo(self.testButton.mas_bottom).offset(0);</span><br><span class=\"line\">    make.left.right.mas_equalTo(self).offset(0);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">// 重点,必须设置这个约束,确定底部的位置</span><br><span class=\"line\">[self mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.bottom.mas_equalTo(self.testImageView.mas_bottom).offset(0);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>CenterView</code>和<code>BottomView</code>同样设置从顶部和底部控件位置,确定当前<code>containerView</code>(容器)底部约束<strong>这个尤为重要</strong></li>\n</ul>\n<p><strong>Controller</strong></p>\n<blockquote>\n<p>父视图<br><code>@property (nonatomic, strong) UIScrollView *scrollView;</code></p>\n</blockquote>\n<blockquote>\n<p>容器视图<br><code>@property (nonatomic, strong) UIView *containerView;</code></p>\n</blockquote>\n<blockquote>\n<p>分别创建好这两个</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self.view addSubview:self.scrollView];</span><br><span class=\"line\">[self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.edges.equalTo(self.view);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[self.scrollView addSubview:self.containerView];</span><br><span class=\"line\">[self.containerView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.edges.equalTo(self.scrollView);</span><br><span class=\"line\">    make.width.equalTo(self.scrollView);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[self.containerView addSubview:self.topView];</span><br><span class=\"line\">[self.topView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.left.right.top.mas_equalTo(self.containerView).offset(0);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[self.containerView addSubview:self.centerView];</span><br><span class=\"line\">[self.centerView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.mas_equalTo(self.topView.mas_bottom).offset(0);</span><br><span class=\"line\">    make.left.right.mas_equalTo(self.containerView).offset(0);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[self.containerView addSubview:self.bottomView];</span><br><span class=\"line\">[self.bottomView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.mas_equalTo(self.centerView.mas_bottom).offset(0);</span><br><span class=\"line\">    make.left.right.bottom.mas_equalTo(self.containerView).offset(0);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">// 这个很重要,controller里面同样需要确定containerView(容器)的底部约束</span><br><span class=\"line\">[self.containerView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">   make.bottom.mas_equalTo(self.bottomView.mas_bottom).offset(0);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><ul>\n<li>布局页面我们已经全部都完成了,就是数据填充问题了,这样我们实行UIScrollView复杂页面开发的实现</li>\n</ul>\n<p><strong>重要的事情说三遍</strong></p>\n<ol>\n<li><p>自定义<code>View</code>的子控件,约束必须是从<code>top</code>到<code>bottom</code>位置必须确定,接着确定自定义<code>View</code>的底部约束(就是自定义<code>View</code>底部控件的<code>bottom</code>的约束)</p>\n</li>\n<li><p>自定义<code>View</code>的子控件,约束必须是从<code>top</code>到<code>bottom</code>位置必须确定,接着确定自定义<code>View</code>的底部约束(就是自定义<code>View</code>底部控件的<code>bottom</code>的约束)</p>\n</li>\n<li><p>自定义<code>View</code>的子控件,约束必须是从<code>top</code>到<code>bottom</code>位置必须确定,接着确定自定义<code>View</code>的底部约束(就是自定义<code>View</code>底部控件的<code>bottom</code>的约束)</p>\n</li>\n</ol>\n<h2 id=\"修改View约束动画\"><a href=\"#修改View约束动画\" class=\"headerlink\" title=\"修改View约束动画\"></a>修改<code>View</code>约束动画</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)updateConstraints &#123;</span><br><span class=\"line\">    // remake会将之前的全部移除，然后重新添加</span><br><span class=\"line\">    __weak __typeof(self) weakSelf = self;</span><br><span class=\"line\">    [self.testButton mas_remakeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">        make.top.mas_equalTo(self.testLabel.mas_bottom).offset(0);</span><br><span class=\"line\">        make.left.right.mas_equalTo(self).offset(0);</span><br><span class=\"line\">        if (weakSelf.isExpanded) &#123;</span><br><span class=\"line\">            make.height.mas_equalTo(200);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            make.height.mas_equalTo(40);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [super updateConstraints];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 响应时间处理</span><br><span class=\"line\">- (void)onGrowButtonTaped:(UIButton *)sender &#123;</span><br><span class=\"line\">    self.isExpanded = !self.isExpanded;</span><br><span class=\"line\">    if (!self.isExpanded) &#123;</span><br><span class=\"line\">        [self.testButton setTitle:@&quot;点我展开&quot; forState:UIControlStateNormal];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        [self.testButton setTitle:@&quot;点我收起&quot; forState:UIControlStateNormal];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 告诉self.view约束需要更新</span><br><span class=\"line\">    [self setNeedsUpdateConstraints];</span><br><span class=\"line\">    // 调用此方法告诉self.view检测是否需要更新约束，若需要则更新，下面添加动画效果才起作用</span><br><span class=\"line\">    [self updateConstraintsIfNeeded];</span><br><span class=\"line\"></span><br><span class=\"line\">    [UIView animateWithDuration:0.3 animations:^&#123;</span><br><span class=\"line\">        [self layoutIfNeeded];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"iOS偷懒_效率","date":"2018-05-04T03:05:36.000Z","_content":"\n## `import`导入`pod`第三方库不提示问题\n1. 选择`target` > `BuildSettings` > `search Paths`下的`User Header Search Paths`\n\n2. 双击后面的空白区域\n\n3. 点击\"+\"号添加一项:并且输入:`$(PODS_ROOT)`,选择:`recursive`(会在相应的目录递归搜索文件)\n\n<!--more-->\n\n## 添加`pch`文件\n\n1. `Xcode`正确创建`pch`文件\n\n2. 选择`target` > `BuildSettings` > `Apple LLVM 8.0 -Language`下的`Prefix Header`(或者搜索`Prefix Header`)\n\n3. 双击后面的空白区域\n\n4. 点击\"+\"号添加一项:并且输入:`$(SRCROOT)/项目中创建.pch`,选择:`recursive`(会在相应的目录递归搜索文件)\n\n5. `Precompile Prefix Header`为`YES`,预编译后的pch文件缓存起来\n\n## 扩展随机颜色\n```\n[UIColor colorWithRed:arc4random_uniform(255) / 255.0 green:arc4random_uniform(255) / 255.0 blue:arc4random_uniform(255) / 255.0 alpha:1];\n```\n\n## UIView常用setNeedsDisplay和setNeedsLayout\n\n**UIView的setNeedsDisplay和setNeedsLayout方法**\n\n>首先两个方法都是异步执行的。而`setNeedsDisplay`会调用自动调用`drawRect`方法，这样可以拿到`UIGraphicsGetCurrentContext`，就可以画画了。而`setNeedsLayout`会默认调用`layoutSubViews`，就可以处理子视图中的一些数据。\n\n>综上所诉，`setNeedsDisplay`方便绘图，而`layoutSubViews`方便出来数据。\n\n`layoutSubviews`在以下情况下会被调用：\n\n- `init`初始化不会触发`layoutSubviews`。\n- `addSubview`会触发`layoutSubviews`。\n- 设置`view`的`Frame`会触发`layoutSubviews`，当然前提是`frame`的值设置前后发生了变化。\n- 滚动一个`UIScrollView`会触发`layoutSubviews`。\n- 旋转`Screen`会触发父`UIView`上的`layoutSubviews`事件。\n- 改变一个`UIView`大小的时候也会触发父`UIView`上的`layoutSubviews`事件。\n- 直接调用`setLayoutSubviews`。\n\n\n`drawRect`在以下情况下会被调用：\n\n- 如果在`UIView`初始化时没有设置`rect`大小，将直接导致`drawRect`不被自动调用。`drawRect`调用是在`Controller->loadView, Controller->viewDidLoad `两方法之后掉用的.所以不用担心在控制器中,这些`View`的`drawRect`就开始画了.这样可以在控制器中设置一些值给`View`(如果这些`View draw`的时候需要用到某些变量值).\n- 该方法在调用`sizeToFit`后被调用，所以可以先调用`sizeToFit`计算出`size`。然后系统自动调用`drawRect:`方法。\n- 通过设置`contentMode`属性值为`UIViewContentModeRedraw`。那么将在每次设置或更改`frame`的时候自动调用`drawRect:`。\n- 直接调用`setNeedsDisplay`，或者`setNeedsDisplayInRect:`触发`drawRect:`，但是有个前提条件是`rect`不能为0。\n- 以上1,2推荐；而3,4不提倡\n\n\n`drawRect`方法使用注意点：\n\n- 若使用`UIView`绘图，只能在`drawRect：`方法中获取相应的`contextRef`并绘图。如果在其他方法中获取将获取到一个`invalidate`的`ref`并且不能用于画图。`drawRect：`方法不能手动显示调用，必须通过调用`setNeedsDisplay` 或者 `setNeedsDisplayInRect`，让系统自动调该方法。\n- 若使用`calayer`绘图，只能在`drawInContext:`中（类似于`drawRect`）绘制，或者在`delegate`中的相应方法绘制。同样也是调用`setNeedDisplay`等间接调用以上方法\n- 若要实时画图，不能使用`gestureRecognizer`，只能使用`touchbegan`等方法来掉用`setNeedsDisplay`实时刷新屏幕\n\n\n## UIView调用\n\n>`-(void)layoutSubviews`\n\n>`-(void)layoutIfNeeded`\n\n>`-(void)setNeedsLayout`\n\n>`-(CGSize)sizeThatFits:(CGSize)size`\n\n>`-(void)sizeToFit`\n\n>`-(void)setNeedsDisplay`\n\n>`-(void)drawRect`\n\n### `layoutSubviews`在以下情况下会被调用/被触发？？\n\n1. `init`初始化不会触发`layoutSubviews`，但是是用`initWithFrame`进行初始化时，当`rect`的值 非`CGRectZero`时,也会触发。\n\n2. `addSubview`会触发`layoutSubviews`\n\n3. 设置`view`的`Frame`会触发`layoutSubviews`，当然前提是`frame`的值设置前后发生了变化\n\n4. 滚动一个`UIScrollView`会触发`layoutSubviews`\n\n5. 旋转`Screen`会触发父`UIView`上的`layoutSubviews`事件\n\n6. 改变一个`UIView`大小的时候也会触发父`UIView`上的`layoutSubviews`事件\n\n\n**(在苹果的官方文档中强调)**\n\n`You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.layoutSubviews`,(当我们在某个类的内部调整子视图位置时，需要调用。反过来的意思就是说：如果你想要在外部设置`subviews`的位置，就不要重写。)\n\n## 刷新子对象布局??\n\n### 什么时候，需要重写？\n\n\n>view是系统的，不需要重写 `- (void)layoutSubviews`\n\n>view是自定义的，需要重写  `- (void)layoutSubviews`\n\n>`-layoutSubviews`方法：这个方法，默认没有做任何事情，需要子类进行重写，自定义`view`时，手动重写，这里面只能写`subview`的`frame`限制。\n\n### 手动调用这个方法，系统默认 我们不能手动直接调用这个方法，这能通过下列两种方式，调用/触发 `- (void)layoutSubviews`方法\n\n\n>`-setNeedsLayout`方法： 标记为需要重新布局，告诉系统未来某个时间点异步调用。不立即刷新，但`layoutSubviews`一定会被调用。\n\n>`-layoutIfNeeded`方法：如果，有需要刷新的标记，立即调用`layoutSubviews`进行布局（如果没有标记，不会调用`layoutSubviews`）\n\n>若需要立即刷新`view`的`frame`更改：（同时调用，注意先后顺序）\n\n>先调用`[view setNeedsLayout]`，把标记设为需要布局\n\n>然后马上调用`[view layoutIfNeeded]`，实现布局\n\n>在初始化方法`init`..。、或者view第一次显示之前，标记总是“需要刷新”的，可以直接调用`[view layoutIfNeeded]`\n\n### 重绘\n\n\n>`-drawRect:(CGRect)rect`方法：重写此方法，执行重绘任务\n\n>`-setNeedsDisplay`方法：标记为需要重绘，异步调用`drawRect`\n\n>`-setNeedsDisplayInRect:(CGRect)invalidRect`方法：标记为需要局部重绘\n\n- **（注意：`sizeToFit`会 自动调用`sizeThatFits`方法；**\n\n`sizeToFit`不应该在子类中被重写，应该重写`sizeThatFits`）\n\n>`sizeThatFits`传入的参数是`receiver`当前的`size`，返回一个适合的`size`\n\n>`sizeToFit`可以被手动直接调用,注意(系统默认的一些控件可以通过调用`sizeToFit`方法使其有尺寸,`egUIBarButtonItem,UITableView`的组头,组尾,表头,表尾,,,......)\n\n>`sizeToFit`和`sizeThatFits`方法都没有递归，对`subviews`也不负责，只负责自己\n\n>`layoutSubviews`对`subviews`重新布局\n\n>`layoutSubviews`方法调用先于`drawRect`\n\n>`setNeedsLayout`在`receiver`标上一个需要被重新布局的标记，在系统`runloop`的下一个周期自动调用`layoutSubviews`\n\n>`layoutIfNeeded`方法如其名，`UIKit`会判断该`receiver`是否需要`layout`.根据Apple官方文档,`layoutIfNeeded`方法应该是这样的\n\n>`layoutIfNeeded`遍历的不是`superview`链，应该是`subviews`链\n\n>`drawRect`是对`receiver`的重绘，能获得`context`\n\n>`setNeedDisplay`在`receiver`标上一个需要被重新绘图的标记，在下一个`draw`周期自动重绘，`iphone device的刷新频率是60hz`，也就是`1/60`秒后重绘\n\n\n## 参考文档\n[UIView常用的一些方法小记之setNeedsDisplay和setNeedsLayout](http://blog.sina.com.cn/s/blog_a573f7990101cdpe.html)","source":"_posts/iOS偷懒-效率.md","raw":"---\ntitle: iOS偷懒_效率\ndate: 2018-05-04 11:05:36\ntags: \"iOS\"\ncategories: \"iOS效率\"\n---\n\n## `import`导入`pod`第三方库不提示问题\n1. 选择`target` > `BuildSettings` > `search Paths`下的`User Header Search Paths`\n\n2. 双击后面的空白区域\n\n3. 点击\"+\"号添加一项:并且输入:`$(PODS_ROOT)`,选择:`recursive`(会在相应的目录递归搜索文件)\n\n<!--more-->\n\n## 添加`pch`文件\n\n1. `Xcode`正确创建`pch`文件\n\n2. 选择`target` > `BuildSettings` > `Apple LLVM 8.0 -Language`下的`Prefix Header`(或者搜索`Prefix Header`)\n\n3. 双击后面的空白区域\n\n4. 点击\"+\"号添加一项:并且输入:`$(SRCROOT)/项目中创建.pch`,选择:`recursive`(会在相应的目录递归搜索文件)\n\n5. `Precompile Prefix Header`为`YES`,预编译后的pch文件缓存起来\n\n## 扩展随机颜色\n```\n[UIColor colorWithRed:arc4random_uniform(255) / 255.0 green:arc4random_uniform(255) / 255.0 blue:arc4random_uniform(255) / 255.0 alpha:1];\n```\n\n## UIView常用setNeedsDisplay和setNeedsLayout\n\n**UIView的setNeedsDisplay和setNeedsLayout方法**\n\n>首先两个方法都是异步执行的。而`setNeedsDisplay`会调用自动调用`drawRect`方法，这样可以拿到`UIGraphicsGetCurrentContext`，就可以画画了。而`setNeedsLayout`会默认调用`layoutSubViews`，就可以处理子视图中的一些数据。\n\n>综上所诉，`setNeedsDisplay`方便绘图，而`layoutSubViews`方便出来数据。\n\n`layoutSubviews`在以下情况下会被调用：\n\n- `init`初始化不会触发`layoutSubviews`。\n- `addSubview`会触发`layoutSubviews`。\n- 设置`view`的`Frame`会触发`layoutSubviews`，当然前提是`frame`的值设置前后发生了变化。\n- 滚动一个`UIScrollView`会触发`layoutSubviews`。\n- 旋转`Screen`会触发父`UIView`上的`layoutSubviews`事件。\n- 改变一个`UIView`大小的时候也会触发父`UIView`上的`layoutSubviews`事件。\n- 直接调用`setLayoutSubviews`。\n\n\n`drawRect`在以下情况下会被调用：\n\n- 如果在`UIView`初始化时没有设置`rect`大小，将直接导致`drawRect`不被自动调用。`drawRect`调用是在`Controller->loadView, Controller->viewDidLoad `两方法之后掉用的.所以不用担心在控制器中,这些`View`的`drawRect`就开始画了.这样可以在控制器中设置一些值给`View`(如果这些`View draw`的时候需要用到某些变量值).\n- 该方法在调用`sizeToFit`后被调用，所以可以先调用`sizeToFit`计算出`size`。然后系统自动调用`drawRect:`方法。\n- 通过设置`contentMode`属性值为`UIViewContentModeRedraw`。那么将在每次设置或更改`frame`的时候自动调用`drawRect:`。\n- 直接调用`setNeedsDisplay`，或者`setNeedsDisplayInRect:`触发`drawRect:`，但是有个前提条件是`rect`不能为0。\n- 以上1,2推荐；而3,4不提倡\n\n\n`drawRect`方法使用注意点：\n\n- 若使用`UIView`绘图，只能在`drawRect：`方法中获取相应的`contextRef`并绘图。如果在其他方法中获取将获取到一个`invalidate`的`ref`并且不能用于画图。`drawRect：`方法不能手动显示调用，必须通过调用`setNeedsDisplay` 或者 `setNeedsDisplayInRect`，让系统自动调该方法。\n- 若使用`calayer`绘图，只能在`drawInContext:`中（类似于`drawRect`）绘制，或者在`delegate`中的相应方法绘制。同样也是调用`setNeedDisplay`等间接调用以上方法\n- 若要实时画图，不能使用`gestureRecognizer`，只能使用`touchbegan`等方法来掉用`setNeedsDisplay`实时刷新屏幕\n\n\n## UIView调用\n\n>`-(void)layoutSubviews`\n\n>`-(void)layoutIfNeeded`\n\n>`-(void)setNeedsLayout`\n\n>`-(CGSize)sizeThatFits:(CGSize)size`\n\n>`-(void)sizeToFit`\n\n>`-(void)setNeedsDisplay`\n\n>`-(void)drawRect`\n\n### `layoutSubviews`在以下情况下会被调用/被触发？？\n\n1. `init`初始化不会触发`layoutSubviews`，但是是用`initWithFrame`进行初始化时，当`rect`的值 非`CGRectZero`时,也会触发。\n\n2. `addSubview`会触发`layoutSubviews`\n\n3. 设置`view`的`Frame`会触发`layoutSubviews`，当然前提是`frame`的值设置前后发生了变化\n\n4. 滚动一个`UIScrollView`会触发`layoutSubviews`\n\n5. 旋转`Screen`会触发父`UIView`上的`layoutSubviews`事件\n\n6. 改变一个`UIView`大小的时候也会触发父`UIView`上的`layoutSubviews`事件\n\n\n**(在苹果的官方文档中强调)**\n\n`You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.layoutSubviews`,(当我们在某个类的内部调整子视图位置时，需要调用。反过来的意思就是说：如果你想要在外部设置`subviews`的位置，就不要重写。)\n\n## 刷新子对象布局??\n\n### 什么时候，需要重写？\n\n\n>view是系统的，不需要重写 `- (void)layoutSubviews`\n\n>view是自定义的，需要重写  `- (void)layoutSubviews`\n\n>`-layoutSubviews`方法：这个方法，默认没有做任何事情，需要子类进行重写，自定义`view`时，手动重写，这里面只能写`subview`的`frame`限制。\n\n### 手动调用这个方法，系统默认 我们不能手动直接调用这个方法，这能通过下列两种方式，调用/触发 `- (void)layoutSubviews`方法\n\n\n>`-setNeedsLayout`方法： 标记为需要重新布局，告诉系统未来某个时间点异步调用。不立即刷新，但`layoutSubviews`一定会被调用。\n\n>`-layoutIfNeeded`方法：如果，有需要刷新的标记，立即调用`layoutSubviews`进行布局（如果没有标记，不会调用`layoutSubviews`）\n\n>若需要立即刷新`view`的`frame`更改：（同时调用，注意先后顺序）\n\n>先调用`[view setNeedsLayout]`，把标记设为需要布局\n\n>然后马上调用`[view layoutIfNeeded]`，实现布局\n\n>在初始化方法`init`..。、或者view第一次显示之前，标记总是“需要刷新”的，可以直接调用`[view layoutIfNeeded]`\n\n### 重绘\n\n\n>`-drawRect:(CGRect)rect`方法：重写此方法，执行重绘任务\n\n>`-setNeedsDisplay`方法：标记为需要重绘，异步调用`drawRect`\n\n>`-setNeedsDisplayInRect:(CGRect)invalidRect`方法：标记为需要局部重绘\n\n- **（注意：`sizeToFit`会 自动调用`sizeThatFits`方法；**\n\n`sizeToFit`不应该在子类中被重写，应该重写`sizeThatFits`）\n\n>`sizeThatFits`传入的参数是`receiver`当前的`size`，返回一个适合的`size`\n\n>`sizeToFit`可以被手动直接调用,注意(系统默认的一些控件可以通过调用`sizeToFit`方法使其有尺寸,`egUIBarButtonItem,UITableView`的组头,组尾,表头,表尾,,,......)\n\n>`sizeToFit`和`sizeThatFits`方法都没有递归，对`subviews`也不负责，只负责自己\n\n>`layoutSubviews`对`subviews`重新布局\n\n>`layoutSubviews`方法调用先于`drawRect`\n\n>`setNeedsLayout`在`receiver`标上一个需要被重新布局的标记，在系统`runloop`的下一个周期自动调用`layoutSubviews`\n\n>`layoutIfNeeded`方法如其名，`UIKit`会判断该`receiver`是否需要`layout`.根据Apple官方文档,`layoutIfNeeded`方法应该是这样的\n\n>`layoutIfNeeded`遍历的不是`superview`链，应该是`subviews`链\n\n>`drawRect`是对`receiver`的重绘，能获得`context`\n\n>`setNeedDisplay`在`receiver`标上一个需要被重新绘图的标记，在下一个`draw`周期自动重绘，`iphone device的刷新频率是60hz`，也就是`1/60`秒后重绘\n\n\n## 参考文档\n[UIView常用的一些方法小记之setNeedsDisplay和setNeedsLayout](http://blog.sina.com.cn/s/blog_a573f7990101cdpe.html)","slug":"iOS偷懒-效率","published":1,"updated":"2018-08-06T05:46:08.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkhy6quh000cduu96476hnpy","content":"<h2 id=\"import导入pod第三方库不提示问题\"><a href=\"#import导入pod第三方库不提示问题\" class=\"headerlink\" title=\"import导入pod第三方库不提示问题\"></a><code>import</code>导入<code>pod</code>第三方库不提示问题</h2><ol>\n<li><p>选择<code>target</code> &gt; <code>BuildSettings</code> &gt; <code>search Paths</code>下的<code>User Header Search Paths</code></p>\n</li>\n<li><p>双击后面的空白区域</p>\n</li>\n<li><p>点击”+”号添加一项:并且输入:<code>$(PODS_ROOT)</code>,选择:<code>recursive</code>(会在相应的目录递归搜索文件)</p>\n</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"添加pch文件\"><a href=\"#添加pch文件\" class=\"headerlink\" title=\"添加pch文件\"></a>添加<code>pch</code>文件</h2><ol>\n<li><p><code>Xcode</code>正确创建<code>pch</code>文件</p>\n</li>\n<li><p>选择<code>target</code> &gt; <code>BuildSettings</code> &gt; <code>Apple LLVM 8.0 -Language</code>下的<code>Prefix Header</code>(或者搜索<code>Prefix Header</code>)</p>\n</li>\n<li><p>双击后面的空白区域</p>\n</li>\n<li><p>点击”+”号添加一项:并且输入:<code>$(SRCROOT)/项目中创建.pch</code>,选择:<code>recursive</code>(会在相应的目录递归搜索文件)</p>\n</li>\n<li><p><code>Precompile Prefix Header</code>为<code>YES</code>,预编译后的pch文件缓存起来</p>\n</li>\n</ol>\n<h2 id=\"扩展随机颜色\"><a href=\"#扩展随机颜色\" class=\"headerlink\" title=\"扩展随机颜色\"></a>扩展随机颜色</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[UIColor colorWithRed:arc4random_uniform(255) / 255.0 green:arc4random_uniform(255) / 255.0 blue:arc4random_uniform(255) / 255.0 alpha:1];</span><br></pre></td></tr></table></figure>\n<h2 id=\"UIView常用setNeedsDisplay和setNeedsLayout\"><a href=\"#UIView常用setNeedsDisplay和setNeedsLayout\" class=\"headerlink\" title=\"UIView常用setNeedsDisplay和setNeedsLayout\"></a>UIView常用setNeedsDisplay和setNeedsLayout</h2><p><strong>UIView的setNeedsDisplay和setNeedsLayout方法</strong></p>\n<blockquote>\n<p>首先两个方法都是异步执行的。而<code>setNeedsDisplay</code>会调用自动调用<code>drawRect</code>方法，这样可以拿到<code>UIGraphicsGetCurrentContext</code>，就可以画画了。而<code>setNeedsLayout</code>会默认调用<code>layoutSubViews</code>，就可以处理子视图中的一些数据。</p>\n</blockquote>\n<blockquote>\n<p>综上所诉，<code>setNeedsDisplay</code>方便绘图，而<code>layoutSubViews</code>方便出来数据。</p>\n</blockquote>\n<p><code>layoutSubviews</code>在以下情况下会被调用：</p>\n<ul>\n<li><code>init</code>初始化不会触发<code>layoutSubviews</code>。</li>\n<li><code>addSubview</code>会触发<code>layoutSubviews</code>。</li>\n<li>设置<code>view</code>的<code>Frame</code>会触发<code>layoutSubviews</code>，当然前提是<code>frame</code>的值设置前后发生了变化。</li>\n<li>滚动一个<code>UIScrollView</code>会触发<code>layoutSubviews</code>。</li>\n<li>旋转<code>Screen</code>会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件。</li>\n<li>改变一个<code>UIView</code>大小的时候也会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件。</li>\n<li>直接调用<code>setLayoutSubviews</code>。</li>\n</ul>\n<p><code>drawRect</code>在以下情况下会被调用：</p>\n<ul>\n<li>如果在<code>UIView</code>初始化时没有设置<code>rect</code>大小，将直接导致<code>drawRect</code>不被自动调用。<code>drawRect</code>调用是在<code>Controller-&gt;loadView, Controller-&gt;viewDidLoad</code>两方法之后掉用的.所以不用担心在控制器中,这些<code>View</code>的<code>drawRect</code>就开始画了.这样可以在控制器中设置一些值给<code>View</code>(如果这些<code>View draw</code>的时候需要用到某些变量值).</li>\n<li>该方法在调用<code>sizeToFit</code>后被调用，所以可以先调用<code>sizeToFit</code>计算出<code>size</code>。然后系统自动调用<code>drawRect:</code>方法。</li>\n<li>通过设置<code>contentMode</code>属性值为<code>UIViewContentModeRedraw</code>。那么将在每次设置或更改<code>frame</code>的时候自动调用<code>drawRect:</code>。</li>\n<li>直接调用<code>setNeedsDisplay</code>，或者<code>setNeedsDisplayInRect:</code>触发<code>drawRect:</code>，但是有个前提条件是<code>rect</code>不能为0。</li>\n<li>以上1,2推荐；而3,4不提倡</li>\n</ul>\n<p><code>drawRect</code>方法使用注意点：</p>\n<ul>\n<li>若使用<code>UIView</code>绘图，只能在<code>drawRect：</code>方法中获取相应的<code>contextRef</code>并绘图。如果在其他方法中获取将获取到一个<code>invalidate</code>的<code>ref</code>并且不能用于画图。<code>drawRect：</code>方法不能手动显示调用，必须通过调用<code>setNeedsDisplay</code> 或者 <code>setNeedsDisplayInRect</code>，让系统自动调该方法。</li>\n<li>若使用<code>calayer</code>绘图，只能在<code>drawInContext:</code>中（类似于<code>drawRect</code>）绘制，或者在<code>delegate</code>中的相应方法绘制。同样也是调用<code>setNeedDisplay</code>等间接调用以上方法</li>\n<li>若要实时画图，不能使用<code>gestureRecognizer</code>，只能使用<code>touchbegan</code>等方法来掉用<code>setNeedsDisplay</code>实时刷新屏幕</li>\n</ul>\n<h2 id=\"UIView调用\"><a href=\"#UIView调用\" class=\"headerlink\" title=\"UIView调用\"></a>UIView调用</h2><blockquote>\n<p><code>-(void)layoutSubviews</code></p>\n</blockquote>\n<blockquote>\n<p><code>-(void)layoutIfNeeded</code></p>\n</blockquote>\n<blockquote>\n<p><code>-(void)setNeedsLayout</code></p>\n</blockquote>\n<blockquote>\n<p><code>-(CGSize)sizeThatFits:(CGSize)size</code></p>\n</blockquote>\n<blockquote>\n<p><code>-(void)sizeToFit</code></p>\n</blockquote>\n<blockquote>\n<p><code>-(void)setNeedsDisplay</code></p>\n</blockquote>\n<blockquote>\n<p><code>-(void)drawRect</code></p>\n</blockquote>\n<h3 id=\"layoutSubviews在以下情况下会被调用-被触发？？\"><a href=\"#layoutSubviews在以下情况下会被调用-被触发？？\" class=\"headerlink\" title=\"layoutSubviews在以下情况下会被调用/被触发？？\"></a><code>layoutSubviews</code>在以下情况下会被调用/被触发？？</h3><ol>\n<li><p><code>init</code>初始化不会触发<code>layoutSubviews</code>，但是是用<code>initWithFrame</code>进行初始化时，当<code>rect</code>的值 非<code>CGRectZero</code>时,也会触发。</p>\n</li>\n<li><p><code>addSubview</code>会触发<code>layoutSubviews</code></p>\n</li>\n<li><p>设置<code>view</code>的<code>Frame</code>会触发<code>layoutSubviews</code>，当然前提是<code>frame</code>的值设置前后发生了变化</p>\n</li>\n<li><p>滚动一个<code>UIScrollView</code>会触发<code>layoutSubviews</code></p>\n</li>\n<li><p>旋转<code>Screen</code>会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件</p>\n</li>\n<li><p>改变一个<code>UIView</code>大小的时候也会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件</p>\n</li>\n</ol>\n<p><strong>(在苹果的官方文档中强调)</strong></p>\n<p><code>You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.layoutSubviews</code>,(当我们在某个类的内部调整子视图位置时，需要调用。反过来的意思就是说：如果你想要在外部设置<code>subviews</code>的位置，就不要重写。)</p>\n<h2 id=\"刷新子对象布局\"><a href=\"#刷新子对象布局\" class=\"headerlink\" title=\"刷新子对象布局??\"></a>刷新子对象布局??</h2><h3 id=\"什么时候，需要重写？\"><a href=\"#什么时候，需要重写？\" class=\"headerlink\" title=\"什么时候，需要重写？\"></a>什么时候，需要重写？</h3><blockquote>\n<p>view是系统的，不需要重写 <code>- (void)layoutSubviews</code></p>\n</blockquote>\n<blockquote>\n<p>view是自定义的，需要重写  <code>- (void)layoutSubviews</code></p>\n</blockquote>\n<blockquote>\n<p><code>-layoutSubviews</code>方法：这个方法，默认没有做任何事情，需要子类进行重写，自定义<code>view</code>时，手动重写，这里面只能写<code>subview</code>的<code>frame</code>限制。</p>\n</blockquote>\n<h3 id=\"手动调用这个方法，系统默认-我们不能手动直接调用这个方法，这能通过下列两种方式，调用-触发-void-layoutSubviews方法\"><a href=\"#手动调用这个方法，系统默认-我们不能手动直接调用这个方法，这能通过下列两种方式，调用-触发-void-layoutSubviews方法\" class=\"headerlink\" title=\"手动调用这个方法，系统默认 我们不能手动直接调用这个方法，这能通过下列两种方式，调用/触发 - (void)layoutSubviews方法\"></a>手动调用这个方法，系统默认 我们不能手动直接调用这个方法，这能通过下列两种方式，调用/触发 <code>- (void)layoutSubviews</code>方法</h3><blockquote>\n<p><code>-setNeedsLayout</code>方法： 标记为需要重新布局，告诉系统未来某个时间点异步调用。不立即刷新，但<code>layoutSubviews</code>一定会被调用。</p>\n</blockquote>\n<blockquote>\n<p><code>-layoutIfNeeded</code>方法：如果，有需要刷新的标记，立即调用<code>layoutSubviews</code>进行布局（如果没有标记，不会调用<code>layoutSubviews</code>）</p>\n</blockquote>\n<blockquote>\n<p>若需要立即刷新<code>view</code>的<code>frame</code>更改：（同时调用，注意先后顺序）</p>\n</blockquote>\n<blockquote>\n<p>先调用<code>[view setNeedsLayout]</code>，把标记设为需要布局</p>\n</blockquote>\n<blockquote>\n<p>然后马上调用<code>[view layoutIfNeeded]</code>，实现布局</p>\n</blockquote>\n<blockquote>\n<p>在初始化方法<code>init</code>..。、或者view第一次显示之前，标记总是“需要刷新”的，可以直接调用<code>[view layoutIfNeeded]</code></p>\n</blockquote>\n<h3 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h3><blockquote>\n<p><code>-drawRect:(CGRect)rect</code>方法：重写此方法，执行重绘任务</p>\n</blockquote>\n<blockquote>\n<p><code>-setNeedsDisplay</code>方法：标记为需要重绘，异步调用<code>drawRect</code></p>\n</blockquote>\n<blockquote>\n<p><code>-setNeedsDisplayInRect:(CGRect)invalidRect</code>方法：标记为需要局部重绘</p>\n</blockquote>\n<ul>\n<li><strong>（注意：<code>sizeToFit</code>会 自动调用<code>sizeThatFits</code>方法；</strong></li>\n</ul>\n<p><code>sizeToFit</code>不应该在子类中被重写，应该重写<code>sizeThatFits</code>）</p>\n<blockquote>\n<p><code>sizeThatFits</code>传入的参数是<code>receiver</code>当前的<code>size</code>，返回一个适合的<code>size</code></p>\n</blockquote>\n<blockquote>\n<p><code>sizeToFit</code>可以被手动直接调用,注意(系统默认的一些控件可以通过调用<code>sizeToFit</code>方法使其有尺寸,<code>egUIBarButtonItem,UITableView</code>的组头,组尾,表头,表尾,,,……)</p>\n</blockquote>\n<blockquote>\n<p><code>sizeToFit</code>和<code>sizeThatFits</code>方法都没有递归，对<code>subviews</code>也不负责，只负责自己</p>\n</blockquote>\n<blockquote>\n<p><code>layoutSubviews</code>对<code>subviews</code>重新布局</p>\n</blockquote>\n<blockquote>\n<p><code>layoutSubviews</code>方法调用先于<code>drawRect</code></p>\n</blockquote>\n<blockquote>\n<p><code>setNeedsLayout</code>在<code>receiver</code>标上一个需要被重新布局的标记，在系统<code>runloop</code>的下一个周期自动调用<code>layoutSubviews</code></p>\n</blockquote>\n<blockquote>\n<p><code>layoutIfNeeded</code>方法如其名，<code>UIKit</code>会判断该<code>receiver</code>是否需要<code>layout</code>.根据Apple官方文档,<code>layoutIfNeeded</code>方法应该是这样的</p>\n</blockquote>\n<blockquote>\n<p><code>layoutIfNeeded</code>遍历的不是<code>superview</code>链，应该是<code>subviews</code>链</p>\n</blockquote>\n<blockquote>\n<p><code>drawRect</code>是对<code>receiver</code>的重绘，能获得<code>context</code></p>\n</blockquote>\n<blockquote>\n<p><code>setNeedDisplay</code>在<code>receiver</code>标上一个需要被重新绘图的标记，在下一个<code>draw</code>周期自动重绘，<code>iphone device的刷新频率是60hz</code>，也就是<code>1/60</code>秒后重绘</p>\n</blockquote>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"http://blog.sina.com.cn/s/blog_a573f7990101cdpe.html\" target=\"_blank\" rel=\"noopener\">UIView常用的一些方法小记之setNeedsDisplay和setNeedsLayout</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"import导入pod第三方库不提示问题\"><a href=\"#import导入pod第三方库不提示问题\" class=\"headerlink\" title=\"import导入pod第三方库不提示问题\"></a><code>import</code>导入<code>pod</code>第三方库不提示问题</h2><ol>\n<li><p>选择<code>target</code> &gt; <code>BuildSettings</code> &gt; <code>search Paths</code>下的<code>User Header Search Paths</code></p>\n</li>\n<li><p>双击后面的空白区域</p>\n</li>\n<li><p>点击”+”号添加一项:并且输入:<code>$(PODS_ROOT)</code>,选择:<code>recursive</code>(会在相应的目录递归搜索文件)</p>\n</li>\n</ol>","more":"<h2 id=\"添加pch文件\"><a href=\"#添加pch文件\" class=\"headerlink\" title=\"添加pch文件\"></a>添加<code>pch</code>文件</h2><ol>\n<li><p><code>Xcode</code>正确创建<code>pch</code>文件</p>\n</li>\n<li><p>选择<code>target</code> &gt; <code>BuildSettings</code> &gt; <code>Apple LLVM 8.0 -Language</code>下的<code>Prefix Header</code>(或者搜索<code>Prefix Header</code>)</p>\n</li>\n<li><p>双击后面的空白区域</p>\n</li>\n<li><p>点击”+”号添加一项:并且输入:<code>$(SRCROOT)/项目中创建.pch</code>,选择:<code>recursive</code>(会在相应的目录递归搜索文件)</p>\n</li>\n<li><p><code>Precompile Prefix Header</code>为<code>YES</code>,预编译后的pch文件缓存起来</p>\n</li>\n</ol>\n<h2 id=\"扩展随机颜色\"><a href=\"#扩展随机颜色\" class=\"headerlink\" title=\"扩展随机颜色\"></a>扩展随机颜色</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[UIColor colorWithRed:arc4random_uniform(255) / 255.0 green:arc4random_uniform(255) / 255.0 blue:arc4random_uniform(255) / 255.0 alpha:1];</span><br></pre></td></tr></table></figure>\n<h2 id=\"UIView常用setNeedsDisplay和setNeedsLayout\"><a href=\"#UIView常用setNeedsDisplay和setNeedsLayout\" class=\"headerlink\" title=\"UIView常用setNeedsDisplay和setNeedsLayout\"></a>UIView常用setNeedsDisplay和setNeedsLayout</h2><p><strong>UIView的setNeedsDisplay和setNeedsLayout方法</strong></p>\n<blockquote>\n<p>首先两个方法都是异步执行的。而<code>setNeedsDisplay</code>会调用自动调用<code>drawRect</code>方法，这样可以拿到<code>UIGraphicsGetCurrentContext</code>，就可以画画了。而<code>setNeedsLayout</code>会默认调用<code>layoutSubViews</code>，就可以处理子视图中的一些数据。</p>\n</blockquote>\n<blockquote>\n<p>综上所诉，<code>setNeedsDisplay</code>方便绘图，而<code>layoutSubViews</code>方便出来数据。</p>\n</blockquote>\n<p><code>layoutSubviews</code>在以下情况下会被调用：</p>\n<ul>\n<li><code>init</code>初始化不会触发<code>layoutSubviews</code>。</li>\n<li><code>addSubview</code>会触发<code>layoutSubviews</code>。</li>\n<li>设置<code>view</code>的<code>Frame</code>会触发<code>layoutSubviews</code>，当然前提是<code>frame</code>的值设置前后发生了变化。</li>\n<li>滚动一个<code>UIScrollView</code>会触发<code>layoutSubviews</code>。</li>\n<li>旋转<code>Screen</code>会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件。</li>\n<li>改变一个<code>UIView</code>大小的时候也会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件。</li>\n<li>直接调用<code>setLayoutSubviews</code>。</li>\n</ul>\n<p><code>drawRect</code>在以下情况下会被调用：</p>\n<ul>\n<li>如果在<code>UIView</code>初始化时没有设置<code>rect</code>大小，将直接导致<code>drawRect</code>不被自动调用。<code>drawRect</code>调用是在<code>Controller-&gt;loadView, Controller-&gt;viewDidLoad</code>两方法之后掉用的.所以不用担心在控制器中,这些<code>View</code>的<code>drawRect</code>就开始画了.这样可以在控制器中设置一些值给<code>View</code>(如果这些<code>View draw</code>的时候需要用到某些变量值).</li>\n<li>该方法在调用<code>sizeToFit</code>后被调用，所以可以先调用<code>sizeToFit</code>计算出<code>size</code>。然后系统自动调用<code>drawRect:</code>方法。</li>\n<li>通过设置<code>contentMode</code>属性值为<code>UIViewContentModeRedraw</code>。那么将在每次设置或更改<code>frame</code>的时候自动调用<code>drawRect:</code>。</li>\n<li>直接调用<code>setNeedsDisplay</code>，或者<code>setNeedsDisplayInRect:</code>触发<code>drawRect:</code>，但是有个前提条件是<code>rect</code>不能为0。</li>\n<li>以上1,2推荐；而3,4不提倡</li>\n</ul>\n<p><code>drawRect</code>方法使用注意点：</p>\n<ul>\n<li>若使用<code>UIView</code>绘图，只能在<code>drawRect：</code>方法中获取相应的<code>contextRef</code>并绘图。如果在其他方法中获取将获取到一个<code>invalidate</code>的<code>ref</code>并且不能用于画图。<code>drawRect：</code>方法不能手动显示调用，必须通过调用<code>setNeedsDisplay</code> 或者 <code>setNeedsDisplayInRect</code>，让系统自动调该方法。</li>\n<li>若使用<code>calayer</code>绘图，只能在<code>drawInContext:</code>中（类似于<code>drawRect</code>）绘制，或者在<code>delegate</code>中的相应方法绘制。同样也是调用<code>setNeedDisplay</code>等间接调用以上方法</li>\n<li>若要实时画图，不能使用<code>gestureRecognizer</code>，只能使用<code>touchbegan</code>等方法来掉用<code>setNeedsDisplay</code>实时刷新屏幕</li>\n</ul>\n<h2 id=\"UIView调用\"><a href=\"#UIView调用\" class=\"headerlink\" title=\"UIView调用\"></a>UIView调用</h2><blockquote>\n<p><code>-(void)layoutSubviews</code></p>\n</blockquote>\n<blockquote>\n<p><code>-(void)layoutIfNeeded</code></p>\n</blockquote>\n<blockquote>\n<p><code>-(void)setNeedsLayout</code></p>\n</blockquote>\n<blockquote>\n<p><code>-(CGSize)sizeThatFits:(CGSize)size</code></p>\n</blockquote>\n<blockquote>\n<p><code>-(void)sizeToFit</code></p>\n</blockquote>\n<blockquote>\n<p><code>-(void)setNeedsDisplay</code></p>\n</blockquote>\n<blockquote>\n<p><code>-(void)drawRect</code></p>\n</blockquote>\n<h3 id=\"layoutSubviews在以下情况下会被调用-被触发？？\"><a href=\"#layoutSubviews在以下情况下会被调用-被触发？？\" class=\"headerlink\" title=\"layoutSubviews在以下情况下会被调用/被触发？？\"></a><code>layoutSubviews</code>在以下情况下会被调用/被触发？？</h3><ol>\n<li><p><code>init</code>初始化不会触发<code>layoutSubviews</code>，但是是用<code>initWithFrame</code>进行初始化时，当<code>rect</code>的值 非<code>CGRectZero</code>时,也会触发。</p>\n</li>\n<li><p><code>addSubview</code>会触发<code>layoutSubviews</code></p>\n</li>\n<li><p>设置<code>view</code>的<code>Frame</code>会触发<code>layoutSubviews</code>，当然前提是<code>frame</code>的值设置前后发生了变化</p>\n</li>\n<li><p>滚动一个<code>UIScrollView</code>会触发<code>layoutSubviews</code></p>\n</li>\n<li><p>旋转<code>Screen</code>会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件</p>\n</li>\n<li><p>改变一个<code>UIView</code>大小的时候也会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件</p>\n</li>\n</ol>\n<p><strong>(在苹果的官方文档中强调)</strong></p>\n<p><code>You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.layoutSubviews</code>,(当我们在某个类的内部调整子视图位置时，需要调用。反过来的意思就是说：如果你想要在外部设置<code>subviews</code>的位置，就不要重写。)</p>\n<h2 id=\"刷新子对象布局\"><a href=\"#刷新子对象布局\" class=\"headerlink\" title=\"刷新子对象布局??\"></a>刷新子对象布局??</h2><h3 id=\"什么时候，需要重写？\"><a href=\"#什么时候，需要重写？\" class=\"headerlink\" title=\"什么时候，需要重写？\"></a>什么时候，需要重写？</h3><blockquote>\n<p>view是系统的，不需要重写 <code>- (void)layoutSubviews</code></p>\n</blockquote>\n<blockquote>\n<p>view是自定义的，需要重写  <code>- (void)layoutSubviews</code></p>\n</blockquote>\n<blockquote>\n<p><code>-layoutSubviews</code>方法：这个方法，默认没有做任何事情，需要子类进行重写，自定义<code>view</code>时，手动重写，这里面只能写<code>subview</code>的<code>frame</code>限制。</p>\n</blockquote>\n<h3 id=\"手动调用这个方法，系统默认-我们不能手动直接调用这个方法，这能通过下列两种方式，调用-触发-void-layoutSubviews方法\"><a href=\"#手动调用这个方法，系统默认-我们不能手动直接调用这个方法，这能通过下列两种方式，调用-触发-void-layoutSubviews方法\" class=\"headerlink\" title=\"手动调用这个方法，系统默认 我们不能手动直接调用这个方法，这能通过下列两种方式，调用/触发 - (void)layoutSubviews方法\"></a>手动调用这个方法，系统默认 我们不能手动直接调用这个方法，这能通过下列两种方式，调用/触发 <code>- (void)layoutSubviews</code>方法</h3><blockquote>\n<p><code>-setNeedsLayout</code>方法： 标记为需要重新布局，告诉系统未来某个时间点异步调用。不立即刷新，但<code>layoutSubviews</code>一定会被调用。</p>\n</blockquote>\n<blockquote>\n<p><code>-layoutIfNeeded</code>方法：如果，有需要刷新的标记，立即调用<code>layoutSubviews</code>进行布局（如果没有标记，不会调用<code>layoutSubviews</code>）</p>\n</blockquote>\n<blockquote>\n<p>若需要立即刷新<code>view</code>的<code>frame</code>更改：（同时调用，注意先后顺序）</p>\n</blockquote>\n<blockquote>\n<p>先调用<code>[view setNeedsLayout]</code>，把标记设为需要布局</p>\n</blockquote>\n<blockquote>\n<p>然后马上调用<code>[view layoutIfNeeded]</code>，实现布局</p>\n</blockquote>\n<blockquote>\n<p>在初始化方法<code>init</code>..。、或者view第一次显示之前，标记总是“需要刷新”的，可以直接调用<code>[view layoutIfNeeded]</code></p>\n</blockquote>\n<h3 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h3><blockquote>\n<p><code>-drawRect:(CGRect)rect</code>方法：重写此方法，执行重绘任务</p>\n</blockquote>\n<blockquote>\n<p><code>-setNeedsDisplay</code>方法：标记为需要重绘，异步调用<code>drawRect</code></p>\n</blockquote>\n<blockquote>\n<p><code>-setNeedsDisplayInRect:(CGRect)invalidRect</code>方法：标记为需要局部重绘</p>\n</blockquote>\n<ul>\n<li><strong>（注意：<code>sizeToFit</code>会 自动调用<code>sizeThatFits</code>方法；</strong></li>\n</ul>\n<p><code>sizeToFit</code>不应该在子类中被重写，应该重写<code>sizeThatFits</code>）</p>\n<blockquote>\n<p><code>sizeThatFits</code>传入的参数是<code>receiver</code>当前的<code>size</code>，返回一个适合的<code>size</code></p>\n</blockquote>\n<blockquote>\n<p><code>sizeToFit</code>可以被手动直接调用,注意(系统默认的一些控件可以通过调用<code>sizeToFit</code>方法使其有尺寸,<code>egUIBarButtonItem,UITableView</code>的组头,组尾,表头,表尾,,,……)</p>\n</blockquote>\n<blockquote>\n<p><code>sizeToFit</code>和<code>sizeThatFits</code>方法都没有递归，对<code>subviews</code>也不负责，只负责自己</p>\n</blockquote>\n<blockquote>\n<p><code>layoutSubviews</code>对<code>subviews</code>重新布局</p>\n</blockquote>\n<blockquote>\n<p><code>layoutSubviews</code>方法调用先于<code>drawRect</code></p>\n</blockquote>\n<blockquote>\n<p><code>setNeedsLayout</code>在<code>receiver</code>标上一个需要被重新布局的标记，在系统<code>runloop</code>的下一个周期自动调用<code>layoutSubviews</code></p>\n</blockquote>\n<blockquote>\n<p><code>layoutIfNeeded</code>方法如其名，<code>UIKit</code>会判断该<code>receiver</code>是否需要<code>layout</code>.根据Apple官方文档,<code>layoutIfNeeded</code>方法应该是这样的</p>\n</blockquote>\n<blockquote>\n<p><code>layoutIfNeeded</code>遍历的不是<code>superview</code>链，应该是<code>subviews</code>链</p>\n</blockquote>\n<blockquote>\n<p><code>drawRect</code>是对<code>receiver</code>的重绘，能获得<code>context</code></p>\n</blockquote>\n<blockquote>\n<p><code>setNeedDisplay</code>在<code>receiver</code>标上一个需要被重新绘图的标记，在下一个<code>draw</code>周期自动重绘，<code>iphone device的刷新频率是60hz</code>，也就是<code>1/60</code>秒后重绘</p>\n</blockquote>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"http://blog.sina.com.cn/s/blog_a573f7990101cdpe.html\" target=\"_blank\" rel=\"noopener\">UIView常用的一些方法小记之setNeedsDisplay和setNeedsLayout</a></p>"},{"title":"iOS开发之UITableView滚动方向","date":"2018-05-29T08:45:41.000Z","_content":"\n>iOS开发之`UITableView`, `UICollectionView`, `UIScrollview`,根据代理判断页面滚动方向\n\n```\n- (void)scrollViewDidScroll:(UIScrollView *)scrollView {  \n   CGPoint point =  [scrollView.panGestureRecognizer translationInView:self.view];  \n    if (point.y > 0 ) {  \n        NSLog(@\"------往上滚动\");  \n    }else{  \n        NSLog(@\"------往下滚动\");  \n  \n    }  \n} \n```\n\n<!--more-->","source":"_posts/iOS开发之UITableView滚动方向.md","raw":"---\ntitle: iOS开发之UITableView滚动方向\ndate: 2018-05-29 16:45:41\ntags: \"iOS\"\ncategories: \"iOS效率\"\n---\n\n>iOS开发之`UITableView`, `UICollectionView`, `UIScrollview`,根据代理判断页面滚动方向\n\n```\n- (void)scrollViewDidScroll:(UIScrollView *)scrollView {  \n   CGPoint point =  [scrollView.panGestureRecognizer translationInView:self.view];  \n    if (point.y > 0 ) {  \n        NSLog(@\"------往上滚动\");  \n    }else{  \n        NSLog(@\"------往下滚动\");  \n  \n    }  \n} \n```\n\n<!--more-->","slug":"iOS开发之UITableView滚动方向","published":1,"updated":"2018-08-06T05:46:08.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkhy6quk000dduu9onstz4fe","content":"<blockquote>\n<p>iOS开发之<code>UITableView</code>, <code>UICollectionView</code>, <code>UIScrollview</code>,根据代理判断页面滚动方向</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;  </span><br><span class=\"line\">   CGPoint point =  [scrollView.panGestureRecognizer translationInView:self.view];  </span><br><span class=\"line\">    if (point.y &gt; 0 ) &#123;  </span><br><span class=\"line\">        NSLog(@&quot;------往上滚动&quot;);  </span><br><span class=\"line\">    &#125;else&#123;  </span><br><span class=\"line\">        NSLog(@&quot;------往下滚动&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>","site":{"data":{}},"excerpt":"<blockquote>\n<p>iOS开发之<code>UITableView</code>, <code>UICollectionView</code>, <code>UIScrollview</code>,根据代理判断页面滚动方向</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;  </span><br><span class=\"line\">   CGPoint point =  [scrollView.panGestureRecognizer translationInView:self.view];  </span><br><span class=\"line\">    if (point.y &gt; 0 ) &#123;  </span><br><span class=\"line\">        NSLog(@&quot;------往上滚动&quot;);  </span><br><span class=\"line\">    &#125;else&#123;  </span><br><span class=\"line\">        NSLog(@&quot;------往下滚动&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":""},{"title":"iOS仿淘宝详情页导航栏","date":"2018-06-02T08:41:58.000Z","_content":"\n## 前提\n>当看到好的App应用,都想好好的了解下他们的实现\n\n## 分析\n>正常的App应用是不能分析App的结构的,所以我们只能借助越狱的手机,对App进行分析,如果没有越狱手机我们一样的可以分析App的结构\n\n1. `Mac`下载`PP助手`程序,再越狱应用中搜索`参考的App`\n\n2. 下载`参考的App`,对`App`进行解压,获取应用安装包\n\n3. 安装工具,具体的工具自行搜索百度(`逆向分析工具`)\n\n4. 安装好工具,把应用安装包放入工具中,运行安装等等(更多的逆向自行搜索)\n\n<!--more-->\n\n5. 通过Xcode工具UI界面分析工具查看淘宝详情页的页面\n\n> 了解,UI界面分析完成之后,大概知道了他的实现View,查看UI界面分析得到的淘宝详情页导航栏实现的View\n\n## 实现\n\n>开始我们的实现,如上的的分析,我们得到了淘宝详情页的大致结构,跳转页面隐藏系统导航栏,添加导航栏View\n\n**看代码**\n\n### 隐藏导航栏(第一步)\n>`UINavigationControllerDelegate`实现代理,侧滑的同时也不会隐藏导航栏的正确显示和隐藏\n\n```\n- (void)viewWillAppear:(BOOL)animated {\n    [super viewWillAppear:animated];\n    self.navigationController.delegate = self;\n}\n\n- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated {\n    // 判断要显示的控制器是否是自己\n    BOOL isShowHomePage = [viewController isKindOfClass:[self class]];\n    [self.navigationController setNavigationBarHidden:isShowHomePage animated:YES];\n}\n```\n\n### 创建导航栏View(第二步)\n\n>创建导航栏View,里面放置详情页面需要的按钮信息和跳转逻辑,`Controller`添加完`UITableView`,只会添加导航栏View,他们都同样的添加的`Controller`的View上\n```\n  // tableView\n  [self.view addSubview:self.tableView];\n\n  self.tableView.tableHeaderView = self.tableHeadLabel;\n  // 导航栏View\n  [self.view addSubview:self.floatView];\n\n- (void)viewWillLayoutSubviews {\n    [super viewWillLayoutSubviews];\n    // 让导航栏View显示最上层,backgroundView设置成透明\n    [self.view bringSubviewToFront:self.floatView];\n}\n\n```\n\n>完成上面的操作,是不能滑动tableView的\n\n### 解决\n**分析iOS**我们通过响应链知识,导航栏View重写`- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event`方法,具体看代码\n```\n- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n//    UIView *tmpView = [super hitTest:point withEvent:event];\n//    if (tmpView.superview == self) {\n//        return nil;\n//    }\n//    return tmpView;\n    \n//    处理的关键点在于判断条件\n//\n//    tmpView.superview == self!\n//\n//    如果需要穿透UIView，则变更为tmpView == self\n    \n    UIView *tmpView = [super hitTest:point withEvent:event];\n    if (tmpView == self) {\n        return nil;\n    }\n    return tmpView;\n}\n\n```\n\n## 完成\n完成上面的操作,这个手势滑动导航栏View,就能响应`tableView`的手势了\n\n>上面的逻辑大致可以实现大部分功能了,所以多查查资料可以更好的提升自己的能力\n\n\n\n\n\n\n","source":"_posts/iOS仿淘宝详情页导航栏.md","raw":"---\ntitle: iOS仿淘宝详情页导航栏\ndate: 2018-06-02 16:41:58\ntags: \"iOS\"\ncategories: \"iOS开发\"\n---\n\n## 前提\n>当看到好的App应用,都想好好的了解下他们的实现\n\n## 分析\n>正常的App应用是不能分析App的结构的,所以我们只能借助越狱的手机,对App进行分析,如果没有越狱手机我们一样的可以分析App的结构\n\n1. `Mac`下载`PP助手`程序,再越狱应用中搜索`参考的App`\n\n2. 下载`参考的App`,对`App`进行解压,获取应用安装包\n\n3. 安装工具,具体的工具自行搜索百度(`逆向分析工具`)\n\n4. 安装好工具,把应用安装包放入工具中,运行安装等等(更多的逆向自行搜索)\n\n<!--more-->\n\n5. 通过Xcode工具UI界面分析工具查看淘宝详情页的页面\n\n> 了解,UI界面分析完成之后,大概知道了他的实现View,查看UI界面分析得到的淘宝详情页导航栏实现的View\n\n## 实现\n\n>开始我们的实现,如上的的分析,我们得到了淘宝详情页的大致结构,跳转页面隐藏系统导航栏,添加导航栏View\n\n**看代码**\n\n### 隐藏导航栏(第一步)\n>`UINavigationControllerDelegate`实现代理,侧滑的同时也不会隐藏导航栏的正确显示和隐藏\n\n```\n- (void)viewWillAppear:(BOOL)animated {\n    [super viewWillAppear:animated];\n    self.navigationController.delegate = self;\n}\n\n- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated {\n    // 判断要显示的控制器是否是自己\n    BOOL isShowHomePage = [viewController isKindOfClass:[self class]];\n    [self.navigationController setNavigationBarHidden:isShowHomePage animated:YES];\n}\n```\n\n### 创建导航栏View(第二步)\n\n>创建导航栏View,里面放置详情页面需要的按钮信息和跳转逻辑,`Controller`添加完`UITableView`,只会添加导航栏View,他们都同样的添加的`Controller`的View上\n```\n  // tableView\n  [self.view addSubview:self.tableView];\n\n  self.tableView.tableHeaderView = self.tableHeadLabel;\n  // 导航栏View\n  [self.view addSubview:self.floatView];\n\n- (void)viewWillLayoutSubviews {\n    [super viewWillLayoutSubviews];\n    // 让导航栏View显示最上层,backgroundView设置成透明\n    [self.view bringSubviewToFront:self.floatView];\n}\n\n```\n\n>完成上面的操作,是不能滑动tableView的\n\n### 解决\n**分析iOS**我们通过响应链知识,导航栏View重写`- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event`方法,具体看代码\n```\n- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n//    UIView *tmpView = [super hitTest:point withEvent:event];\n//    if (tmpView.superview == self) {\n//        return nil;\n//    }\n//    return tmpView;\n    \n//    处理的关键点在于判断条件\n//\n//    tmpView.superview == self!\n//\n//    如果需要穿透UIView，则变更为tmpView == self\n    \n    UIView *tmpView = [super hitTest:point withEvent:event];\n    if (tmpView == self) {\n        return nil;\n    }\n    return tmpView;\n}\n\n```\n\n## 完成\n完成上面的操作,这个手势滑动导航栏View,就能响应`tableView`的手势了\n\n>上面的逻辑大致可以实现大部分功能了,所以多查查资料可以更好的提升自己的能力\n\n\n\n\n\n\n","slug":"iOS仿淘宝详情页导航栏","published":1,"updated":"2018-08-06T05:46:08.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkhy6qum000iduu91obqimil","content":"<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><blockquote>\n<p>当看到好的App应用,都想好好的了解下他们的实现</p>\n</blockquote>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><blockquote>\n<p>正常的App应用是不能分析App的结构的,所以我们只能借助越狱的手机,对App进行分析,如果没有越狱手机我们一样的可以分析App的结构</p>\n</blockquote>\n<ol>\n<li><p><code>Mac</code>下载<code>PP助手</code>程序,再越狱应用中搜索<code>参考的App</code></p>\n</li>\n<li><p>下载<code>参考的App</code>,对<code>App</code>进行解压,获取应用安装包</p>\n</li>\n<li><p>安装工具,具体的工具自行搜索百度(<code>逆向分析工具</code>)</p>\n</li>\n<li><p>安装好工具,把应用安装包放入工具中,运行安装等等(更多的逆向自行搜索)</p>\n</li>\n</ol>\n<a id=\"more\"></a>\n<ol start=\"5\">\n<li>通过Xcode工具UI界面分析工具查看淘宝详情页的页面</li>\n</ol>\n<blockquote>\n<p>了解,UI界面分析完成之后,大概知道了他的实现View,查看UI界面分析得到的淘宝详情页导航栏实现的View</p>\n</blockquote>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><blockquote>\n<p>开始我们的实现,如上的的分析,我们得到了淘宝详情页的大致结构,跳转页面隐藏系统导航栏,添加导航栏View</p>\n</blockquote>\n<p><strong>看代码</strong></p>\n<h3 id=\"隐藏导航栏-第一步\"><a href=\"#隐藏导航栏-第一步\" class=\"headerlink\" title=\"隐藏导航栏(第一步)\"></a>隐藏导航栏(第一步)</h3><blockquote>\n<p><code>UINavigationControllerDelegate</code>实现代理,侧滑的同时也不会隐藏导航栏的正确显示和隐藏</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class=\"line\">    [super viewWillAppear:animated];</span><br><span class=\"line\">    self.navigationController.delegate = self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated &#123;</span><br><span class=\"line\">    // 判断要显示的控制器是否是自己</span><br><span class=\"line\">    BOOL isShowHomePage = [viewController isKindOfClass:[self class]];</span><br><span class=\"line\">    [self.navigationController setNavigationBarHidden:isShowHomePage animated:YES];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建导航栏View-第二步\"><a href=\"#创建导航栏View-第二步\" class=\"headerlink\" title=\"创建导航栏View(第二步)\"></a>创建导航栏View(第二步)</h3><blockquote>\n<p>创建导航栏View,里面放置详情页面需要的按钮信息和跳转逻辑,<code>Controller</code>添加完<code>UITableView</code>,只会添加导航栏View,他们都同样的添加的<code>Controller</code>的View上<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  // tableView</span><br><span class=\"line\">  [self.view addSubview:self.tableView];</span><br><span class=\"line\"></span><br><span class=\"line\">  self.tableView.tableHeaderView = self.tableHeadLabel;</span><br><span class=\"line\">  // 导航栏View</span><br><span class=\"line\">  [self.view addSubview:self.floatView];</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewWillLayoutSubviews &#123;</span><br><span class=\"line\">    [super viewWillLayoutSubviews];</span><br><span class=\"line\">    // 让导航栏View显示最上层,backgroundView设置成透明</span><br><span class=\"line\">    [self.view bringSubviewToFront:self.floatView];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>完成上面的操作,是不能滑动tableView的</p>\n</blockquote>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p><strong>分析iOS</strong>我们通过响应链知识,导航栏View重写<code>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</code>方法,具体看代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class=\"line\">//    UIView *tmpView = [super hitTest:point withEvent:event];</span><br><span class=\"line\">//    if (tmpView.superview == self) &#123;</span><br><span class=\"line\">//        return nil;</span><br><span class=\"line\">//    &#125;</span><br><span class=\"line\">//    return tmpView;</span><br><span class=\"line\">    </span><br><span class=\"line\">//    处理的关键点在于判断条件</span><br><span class=\"line\">//</span><br><span class=\"line\">//    tmpView.superview == self!</span><br><span class=\"line\">//</span><br><span class=\"line\">//    如果需要穿透UIView，则变更为tmpView == self</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIView *tmpView = [super hitTest:point withEvent:event];</span><br><span class=\"line\">    if (tmpView == self) &#123;</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return tmpView;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"完成\"><a href=\"#完成\" class=\"headerlink\" title=\"完成\"></a>完成</h2><p>完成上面的操作,这个手势滑动导航栏View,就能响应<code>tableView</code>的手势了</p>\n<blockquote>\n<p>上面的逻辑大致可以实现大部分功能了,所以多查查资料可以更好的提升自己的能力</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><blockquote>\n<p>当看到好的App应用,都想好好的了解下他们的实现</p>\n</blockquote>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><blockquote>\n<p>正常的App应用是不能分析App的结构的,所以我们只能借助越狱的手机,对App进行分析,如果没有越狱手机我们一样的可以分析App的结构</p>\n</blockquote>\n<ol>\n<li><p><code>Mac</code>下载<code>PP助手</code>程序,再越狱应用中搜索<code>参考的App</code></p>\n</li>\n<li><p>下载<code>参考的App</code>,对<code>App</code>进行解压,获取应用安装包</p>\n</li>\n<li><p>安装工具,具体的工具自行搜索百度(<code>逆向分析工具</code>)</p>\n</li>\n<li><p>安装好工具,把应用安装包放入工具中,运行安装等等(更多的逆向自行搜索)</p>\n</li>\n</ol>","more":"<ol start=\"5\">\n<li>通过Xcode工具UI界面分析工具查看淘宝详情页的页面</li>\n</ol>\n<blockquote>\n<p>了解,UI界面分析完成之后,大概知道了他的实现View,查看UI界面分析得到的淘宝详情页导航栏实现的View</p>\n</blockquote>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><blockquote>\n<p>开始我们的实现,如上的的分析,我们得到了淘宝详情页的大致结构,跳转页面隐藏系统导航栏,添加导航栏View</p>\n</blockquote>\n<p><strong>看代码</strong></p>\n<h3 id=\"隐藏导航栏-第一步\"><a href=\"#隐藏导航栏-第一步\" class=\"headerlink\" title=\"隐藏导航栏(第一步)\"></a>隐藏导航栏(第一步)</h3><blockquote>\n<p><code>UINavigationControllerDelegate</code>实现代理,侧滑的同时也不会隐藏导航栏的正确显示和隐藏</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class=\"line\">    [super viewWillAppear:animated];</span><br><span class=\"line\">    self.navigationController.delegate = self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated &#123;</span><br><span class=\"line\">    // 判断要显示的控制器是否是自己</span><br><span class=\"line\">    BOOL isShowHomePage = [viewController isKindOfClass:[self class]];</span><br><span class=\"line\">    [self.navigationController setNavigationBarHidden:isShowHomePage animated:YES];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建导航栏View-第二步\"><a href=\"#创建导航栏View-第二步\" class=\"headerlink\" title=\"创建导航栏View(第二步)\"></a>创建导航栏View(第二步)</h3><blockquote>\n<p>创建导航栏View,里面放置详情页面需要的按钮信息和跳转逻辑,<code>Controller</code>添加完<code>UITableView</code>,只会添加导航栏View,他们都同样的添加的<code>Controller</code>的View上<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  // tableView</span><br><span class=\"line\">  [self.view addSubview:self.tableView];</span><br><span class=\"line\"></span><br><span class=\"line\">  self.tableView.tableHeaderView = self.tableHeadLabel;</span><br><span class=\"line\">  // 导航栏View</span><br><span class=\"line\">  [self.view addSubview:self.floatView];</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewWillLayoutSubviews &#123;</span><br><span class=\"line\">    [super viewWillLayoutSubviews];</span><br><span class=\"line\">    // 让导航栏View显示最上层,backgroundView设置成透明</span><br><span class=\"line\">    [self.view bringSubviewToFront:self.floatView];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>完成上面的操作,是不能滑动tableView的</p>\n</blockquote>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p><strong>分析iOS</strong>我们通过响应链知识,导航栏View重写<code>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</code>方法,具体看代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class=\"line\">//    UIView *tmpView = [super hitTest:point withEvent:event];</span><br><span class=\"line\">//    if (tmpView.superview == self) &#123;</span><br><span class=\"line\">//        return nil;</span><br><span class=\"line\">//    &#125;</span><br><span class=\"line\">//    return tmpView;</span><br><span class=\"line\">    </span><br><span class=\"line\">//    处理的关键点在于判断条件</span><br><span class=\"line\">//</span><br><span class=\"line\">//    tmpView.superview == self!</span><br><span class=\"line\">//</span><br><span class=\"line\">//    如果需要穿透UIView，则变更为tmpView == self</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIView *tmpView = [super hitTest:point withEvent:event];</span><br><span class=\"line\">    if (tmpView == self) &#123;</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return tmpView;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"完成\"><a href=\"#完成\" class=\"headerlink\" title=\"完成\"></a>完成</h2><p>完成上面的操作,这个手势滑动导航栏View,就能响应<code>tableView</code>的手势了</p>\n<blockquote>\n<p>上面的逻辑大致可以实现大部分功能了,所以多查查资料可以更好的提升自己的能力</p>\n</blockquote>"},{"title":"iOS模型嵌套模型","date":"2018-06-23T01:57:14.000Z","_content":"\n## 问题\n\n> 网络请求到服务器数据,根据服务器的数据结构,我们正确使用数据模型`model`接收,但会出现这样的情况,数组嵌套数组获取嵌套字典等,所以我们就有了模型切图模型的解决方案\n\n## 代码`STCountryModel`h文件\n\n> `STCountryModel`接收类\n\n```\n#import \"STBaseModel.h\"\n\n@class STCountryListModel;\n\n@interface STCountryModel : STBaseModel\n\n@property (nonatomic, copy) NSString *initial;\n// 使用强引用在接收是必须使用copy方法,防止出现问题\n@property (nonatomic, strong) NSArray <STCountryListModel *>*list;\n\n@end\n```\n\n<!--more-->\n\n## 代码`STCountryModel`m文件\n\n```\n#import \"STCountryModel.h\"\n#import \"STCountryListModel.h\"\n\n@implementation STCountryModel\n\n// 重新父类模型嵌套\n- (instancetype)initWithSTDataModelDict:(NSDictionary *)dict {\n    if (self = [super init]) {\n        [self setValuesForKeysWithDictionary:dict];\n        // 性能提升\n        NSMutableArray *dataSource = [NSMutableArray arrayWithCapacity:self.list.count];\n        for (NSDictionary *brandDict in self.list) {\n            STCountryListModel *model = [[STCountryListModel alloc] initWithSTDataModelDict:brandDict];\n            [dataSource addObject:model];\n        }\n        self.list = [dataSource copy];\n    }\n    return self;\n}\n\n@end\n```\n\n## 代码`STCountryListModel`h文件\n\n> `STCountryListModel`接收类\n\n```\n#import \"STBaseModel.h\"\n\n@interface STCountryListModel : STBaseModel\n\n@property (nonatomic, copy) NSString *initial;\n\n@property (nonatomic, copy) NSString *country;\n\n@property (nonatomic, copy) NSString *file_fid;\n\n@property (nonatomic, copy) NSString *ID;\n\n@property (nonatomic, copy) NSString *country_code;\n\n@property (nonatomic, copy) NSString *short_name;\n\n@property (nonatomic, copy) NSString *file_pic;\n\n@property (nonatomic, copy) NSString *name;\n\n@property (nonatomic, copy) NSString *city_code;\n\n@end\n```\n\n## 代码`STCountryListModel`m文件\n\n```\n#import \"STCountryListModel.h\"\n\n@implementation STCountryListModel\n\n// 关键字冲突\n- (void)setValue:(id)value forUndefinedKey:(NSString *)key {\n    if([key isEqualToString:@\"id\"]) {\n    \t// [self.ID setValue:value forKey:key];\n        self.ID = value;\n        return ;\n    }\n}\n\n@end\n```","source":"_posts/iOS模型嵌套模型.md","raw":"---\ntitle: iOS模型嵌套模型\ndate: 2018-06-23 09:57:14\ntags: \"iOS\"\ncategories: \"iOS开发\"\n---\n\n## 问题\n\n> 网络请求到服务器数据,根据服务器的数据结构,我们正确使用数据模型`model`接收,但会出现这样的情况,数组嵌套数组获取嵌套字典等,所以我们就有了模型切图模型的解决方案\n\n## 代码`STCountryModel`h文件\n\n> `STCountryModel`接收类\n\n```\n#import \"STBaseModel.h\"\n\n@class STCountryListModel;\n\n@interface STCountryModel : STBaseModel\n\n@property (nonatomic, copy) NSString *initial;\n// 使用强引用在接收是必须使用copy方法,防止出现问题\n@property (nonatomic, strong) NSArray <STCountryListModel *>*list;\n\n@end\n```\n\n<!--more-->\n\n## 代码`STCountryModel`m文件\n\n```\n#import \"STCountryModel.h\"\n#import \"STCountryListModel.h\"\n\n@implementation STCountryModel\n\n// 重新父类模型嵌套\n- (instancetype)initWithSTDataModelDict:(NSDictionary *)dict {\n    if (self = [super init]) {\n        [self setValuesForKeysWithDictionary:dict];\n        // 性能提升\n        NSMutableArray *dataSource = [NSMutableArray arrayWithCapacity:self.list.count];\n        for (NSDictionary *brandDict in self.list) {\n            STCountryListModel *model = [[STCountryListModel alloc] initWithSTDataModelDict:brandDict];\n            [dataSource addObject:model];\n        }\n        self.list = [dataSource copy];\n    }\n    return self;\n}\n\n@end\n```\n\n## 代码`STCountryListModel`h文件\n\n> `STCountryListModel`接收类\n\n```\n#import \"STBaseModel.h\"\n\n@interface STCountryListModel : STBaseModel\n\n@property (nonatomic, copy) NSString *initial;\n\n@property (nonatomic, copy) NSString *country;\n\n@property (nonatomic, copy) NSString *file_fid;\n\n@property (nonatomic, copy) NSString *ID;\n\n@property (nonatomic, copy) NSString *country_code;\n\n@property (nonatomic, copy) NSString *short_name;\n\n@property (nonatomic, copy) NSString *file_pic;\n\n@property (nonatomic, copy) NSString *name;\n\n@property (nonatomic, copy) NSString *city_code;\n\n@end\n```\n\n## 代码`STCountryListModel`m文件\n\n```\n#import \"STCountryListModel.h\"\n\n@implementation STCountryListModel\n\n// 关键字冲突\n- (void)setValue:(id)value forUndefinedKey:(NSString *)key {\n    if([key isEqualToString:@\"id\"]) {\n    \t// [self.ID setValue:value forKey:key];\n        self.ID = value;\n        return ;\n    }\n}\n\n@end\n```","slug":"iOS模型嵌套模型","published":1,"updated":"2018-08-06T05:46:08.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkhy6qun000jduu9pgnkkdgf","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>网络请求到服务器数据,根据服务器的数据结构,我们正确使用数据模型<code>model</code>接收,但会出现这样的情况,数组嵌套数组获取嵌套字典等,所以我们就有了模型切图模型的解决方案</p>\n</blockquote>\n<h2 id=\"代码STCountryModelh文件\"><a href=\"#代码STCountryModelh文件\" class=\"headerlink\" title=\"代码STCountryModelh文件\"></a>代码<code>STCountryModel</code>h文件</h2><blockquote>\n<p><code>STCountryModel</code>接收类</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;STBaseModel.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@class STCountryListModel;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface STCountryModel : STBaseModel</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *initial;</span><br><span class=\"line\">// 使用强引用在接收是必须使用copy方法,防止出现问题</span><br><span class=\"line\">@property (nonatomic, strong) NSArray &lt;STCountryListModel *&gt;*list;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"代码STCountryModelm文件\"><a href=\"#代码STCountryModelm文件\" class=\"headerlink\" title=\"代码STCountryModelm文件\"></a>代码<code>STCountryModel</code>m文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;STCountryModel.h&quot;</span><br><span class=\"line\">#import &quot;STCountryListModel.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation STCountryModel</span><br><span class=\"line\"></span><br><span class=\"line\">// 重新父类模型嵌套</span><br><span class=\"line\">- (instancetype)initWithSTDataModelDict:(NSDictionary *)dict &#123;</span><br><span class=\"line\">    if (self = [super init]) &#123;</span><br><span class=\"line\">        [self setValuesForKeysWithDictionary:dict];</span><br><span class=\"line\">        // 性能提升</span><br><span class=\"line\">        NSMutableArray *dataSource = [NSMutableArray arrayWithCapacity:self.list.count];</span><br><span class=\"line\">        for (NSDictionary *brandDict in self.list) &#123;</span><br><span class=\"line\">            STCountryListModel *model = [[STCountryListModel alloc] initWithSTDataModelDict:brandDict];</span><br><span class=\"line\">            [dataSource addObject:model];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        self.list = [dataSource copy];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码STCountryListModelh文件\"><a href=\"#代码STCountryListModelh文件\" class=\"headerlink\" title=\"代码STCountryListModelh文件\"></a>代码<code>STCountryListModel</code>h文件</h2><blockquote>\n<p><code>STCountryListModel</code>接收类</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;STBaseModel.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface STCountryListModel : STBaseModel</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *initial;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *country;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *file_fid;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *ID;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *country_code;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *short_name;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *file_pic;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *name;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *city_code;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码STCountryListModelm文件\"><a href=\"#代码STCountryListModelm文件\" class=\"headerlink\" title=\"代码STCountryListModelm文件\"></a>代码<code>STCountryListModel</code>m文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;STCountryListModel.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation STCountryListModel</span><br><span class=\"line\"></span><br><span class=\"line\">// 关键字冲突</span><br><span class=\"line\">- (void)setValue:(id)value forUndefinedKey:(NSString *)key &#123;</span><br><span class=\"line\">    if([key isEqualToString:@&quot;id&quot;]) &#123;</span><br><span class=\"line\">    \t// [self.ID setValue:value forKey:key];</span><br><span class=\"line\">        self.ID = value;</span><br><span class=\"line\">        return ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>网络请求到服务器数据,根据服务器的数据结构,我们正确使用数据模型<code>model</code>接收,但会出现这样的情况,数组嵌套数组获取嵌套字典等,所以我们就有了模型切图模型的解决方案</p>\n</blockquote>\n<h2 id=\"代码STCountryModelh文件\"><a href=\"#代码STCountryModelh文件\" class=\"headerlink\" title=\"代码STCountryModelh文件\"></a>代码<code>STCountryModel</code>h文件</h2><blockquote>\n<p><code>STCountryModel</code>接收类</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;STBaseModel.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@class STCountryListModel;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface STCountryModel : STBaseModel</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *initial;</span><br><span class=\"line\">// 使用强引用在接收是必须使用copy方法,防止出现问题</span><br><span class=\"line\">@property (nonatomic, strong) NSArray &lt;STCountryListModel *&gt;*list;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"代码STCountryModelm文件\"><a href=\"#代码STCountryModelm文件\" class=\"headerlink\" title=\"代码STCountryModelm文件\"></a>代码<code>STCountryModel</code>m文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;STCountryModel.h&quot;</span><br><span class=\"line\">#import &quot;STCountryListModel.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation STCountryModel</span><br><span class=\"line\"></span><br><span class=\"line\">// 重新父类模型嵌套</span><br><span class=\"line\">- (instancetype)initWithSTDataModelDict:(NSDictionary *)dict &#123;</span><br><span class=\"line\">    if (self = [super init]) &#123;</span><br><span class=\"line\">        [self setValuesForKeysWithDictionary:dict];</span><br><span class=\"line\">        // 性能提升</span><br><span class=\"line\">        NSMutableArray *dataSource = [NSMutableArray arrayWithCapacity:self.list.count];</span><br><span class=\"line\">        for (NSDictionary *brandDict in self.list) &#123;</span><br><span class=\"line\">            STCountryListModel *model = [[STCountryListModel alloc] initWithSTDataModelDict:brandDict];</span><br><span class=\"line\">            [dataSource addObject:model];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        self.list = [dataSource copy];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码STCountryListModelh文件\"><a href=\"#代码STCountryListModelh文件\" class=\"headerlink\" title=\"代码STCountryListModelh文件\"></a>代码<code>STCountryListModel</code>h文件</h2><blockquote>\n<p><code>STCountryListModel</code>接收类</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;STBaseModel.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface STCountryListModel : STBaseModel</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *initial;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *country;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *file_fid;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *ID;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *country_code;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *short_name;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *file_pic;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *name;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *city_code;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码STCountryListModelm文件\"><a href=\"#代码STCountryListModelm文件\" class=\"headerlink\" title=\"代码STCountryListModelm文件\"></a>代码<code>STCountryListModel</code>m文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;STCountryListModel.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation STCountryListModel</span><br><span class=\"line\"></span><br><span class=\"line\">// 关键字冲突</span><br><span class=\"line\">- (void)setValue:(id)value forUndefinedKey:(NSString *)key &#123;</span><br><span class=\"line\">    if([key isEqualToString:@&quot;id&quot;]) &#123;</span><br><span class=\"line\">    \t// [self.ID setValue:value forKey:key];</span><br><span class=\"line\">        self.ID = value;</span><br><span class=\"line\">        return ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>"},{"title":"iOS强制横屏实践","date":"2018-06-04T03:05:58.000Z","_content":"\n## 问题\n>在开发视频播放器的时候,需要视频全屏播放同时还能响应手机旋转\n\n## 所以\n>通过资料查找,分为几种方案\n\n**方案一**\n>`View`旋转\n\n**方案二**\n>转场动画\n\n**方案三**\n>强制横竖屏\n\n<!--more-->\n\n## 实践\n>今天就考虑直接使用**强制横竖屏**来完成播放器的全屏播放\n\n- General配置\n![General配置](iOS强制横屏实践/横竖屏1.png)\n\n- info.plist配置\n![info.plist配置](iOS强制横屏实践/横竖屏2.png)\n\n>横竖屏跳转的`Controller`\n\n```\n- (void)interfaceOrientation:(UIInterfaceOrientation)orientation {\n    if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) {\n        SEL selector             = NSSelectorFromString(@\"setOrientation:\");\n        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];\n        [invocation setSelector:selector];\n        [invocation setTarget:[UIDevice currentDevice]];\n        int val                  = orientation;\n        // 从2开始是因为0 1 两个参数已经被selector和target占用\n        [invocation setArgument:&val atIndex:2];\n        [invocation invoke];\n    }\n}\n```\n\n> 重点,必须配置状态栏才能正确的跳转\n\n```\n// 跳转的Controller设置\n- (BOOL)shouldAutorotate {\n    return NO;\n}\n```\n\n> 响应事件调用\n\n```\n[self interfaceOrientation:UIInterfaceOrientationPortrait];\n```\n\n- 一般我们都是`UITabBarController`和`UINavigationController`的结构来完成`App`的框架搭建\n\n> 配置`UITabBarController`\n\n```\n- (BOOL)shouldAutorotate{\n    return [self.selectedViewController shouldAutorotate];\n}\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations{\n    return [self.selectedViewController supportedInterfaceOrientations];\n}\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation{\n    return [self.selectedViewController preferredInterfaceOrientationForPresentation];\n}\n```\n\n> 配置`UINavigationController`\n\n```\n// viewDidLoad调用\n[[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications];\n    \n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(deviceOrientationDidChange) name:UIDeviceOrientationDidChangeNotification object:nil];\n\n// 方法一获取\n- (BOOL)shouldAutorotate{\n    return [[self.viewControllers lastObject]shouldAutorotate];\n}\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations{\n    return [[self.viewControllers lastObject]supportedInterfaceOrientations];\n}\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation{\n    return [[self.viewControllers lastObject] preferredInterfaceOrientationForPresentation];\n}\n\n// 方法二获取\n- (BOOL)shouldAutorotate {\n    return [self.topViewController shouldAutorotate];\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return [self.topViewController supportedInterfaceOrientations];\n}\n\n- (void)deviceOrientationDidChange {\n    NSLog(@\"NAV deviceOrientationDidChange:%ld\",(long)[UIDevice currentDevice].orientation);\n    if([UIDevice currentDevice].orientation == UIDeviceOrientationPortrait) {\n        [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationPortrait];\n        [self orientationChange:NO];\n        //注意： UIDeviceOrientationLandscapeLeft 与 UIInterfaceOrientationLandscapeRight\n    } else if ([UIDevice currentDevice].orientation == UIDeviceOrientationLandscapeLeft) {\n        [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationLandscapeRight];\n        [self orientationChange:YES];\n    }\n}\n\n- (void)orientationChange:(BOOL)landscapeRight {\n    CGFloat width = [UIScreen mainScreen].bounds.size.width;\n    CGFloat height = [UIScreen mainScreen].bounds.size.height;\n\n    if (landscapeRight) {\n        [UIView animateWithDuration:0.2f animations:^{\n            self.view.transform = CGAffineTransformMakeRotation(M_PI_2);\n            self.view.bounds = CGRectMake(0, 0, width, height);\n        }];\n    } else {\n        [UIView animateWithDuration:0.2f animations:^{\n            self.view.transform = CGAffineTransformMakeRotation(0);\n            self.view.bounds = CGRectMake(0, 0, width, height);\n        }];\n    }\n}\n```\n\n## 最后\n>上面全部的代码配置好,iOS强制横屏就已经完成了,大伙自己实践一下!!!\n","source":"_posts/iOS强制横屏实践.md","raw":"---\ntitle: iOS强制横屏实践\ndate: 2018-06-04 11:05:58\ntags: \"iOS\"\ncategories: \"iOS开发\"\n---\n\n## 问题\n>在开发视频播放器的时候,需要视频全屏播放同时还能响应手机旋转\n\n## 所以\n>通过资料查找,分为几种方案\n\n**方案一**\n>`View`旋转\n\n**方案二**\n>转场动画\n\n**方案三**\n>强制横竖屏\n\n<!--more-->\n\n## 实践\n>今天就考虑直接使用**强制横竖屏**来完成播放器的全屏播放\n\n- General配置\n![General配置](iOS强制横屏实践/横竖屏1.png)\n\n- info.plist配置\n![info.plist配置](iOS强制横屏实践/横竖屏2.png)\n\n>横竖屏跳转的`Controller`\n\n```\n- (void)interfaceOrientation:(UIInterfaceOrientation)orientation {\n    if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) {\n        SEL selector             = NSSelectorFromString(@\"setOrientation:\");\n        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];\n        [invocation setSelector:selector];\n        [invocation setTarget:[UIDevice currentDevice]];\n        int val                  = orientation;\n        // 从2开始是因为0 1 两个参数已经被selector和target占用\n        [invocation setArgument:&val atIndex:2];\n        [invocation invoke];\n    }\n}\n```\n\n> 重点,必须配置状态栏才能正确的跳转\n\n```\n// 跳转的Controller设置\n- (BOOL)shouldAutorotate {\n    return NO;\n}\n```\n\n> 响应事件调用\n\n```\n[self interfaceOrientation:UIInterfaceOrientationPortrait];\n```\n\n- 一般我们都是`UITabBarController`和`UINavigationController`的结构来完成`App`的框架搭建\n\n> 配置`UITabBarController`\n\n```\n- (BOOL)shouldAutorotate{\n    return [self.selectedViewController shouldAutorotate];\n}\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations{\n    return [self.selectedViewController supportedInterfaceOrientations];\n}\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation{\n    return [self.selectedViewController preferredInterfaceOrientationForPresentation];\n}\n```\n\n> 配置`UINavigationController`\n\n```\n// viewDidLoad调用\n[[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications];\n    \n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(deviceOrientationDidChange) name:UIDeviceOrientationDidChangeNotification object:nil];\n\n// 方法一获取\n- (BOOL)shouldAutorotate{\n    return [[self.viewControllers lastObject]shouldAutorotate];\n}\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations{\n    return [[self.viewControllers lastObject]supportedInterfaceOrientations];\n}\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation{\n    return [[self.viewControllers lastObject] preferredInterfaceOrientationForPresentation];\n}\n\n// 方法二获取\n- (BOOL)shouldAutorotate {\n    return [self.topViewController shouldAutorotate];\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return [self.topViewController supportedInterfaceOrientations];\n}\n\n- (void)deviceOrientationDidChange {\n    NSLog(@\"NAV deviceOrientationDidChange:%ld\",(long)[UIDevice currentDevice].orientation);\n    if([UIDevice currentDevice].orientation == UIDeviceOrientationPortrait) {\n        [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationPortrait];\n        [self orientationChange:NO];\n        //注意： UIDeviceOrientationLandscapeLeft 与 UIInterfaceOrientationLandscapeRight\n    } else if ([UIDevice currentDevice].orientation == UIDeviceOrientationLandscapeLeft) {\n        [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationLandscapeRight];\n        [self orientationChange:YES];\n    }\n}\n\n- (void)orientationChange:(BOOL)landscapeRight {\n    CGFloat width = [UIScreen mainScreen].bounds.size.width;\n    CGFloat height = [UIScreen mainScreen].bounds.size.height;\n\n    if (landscapeRight) {\n        [UIView animateWithDuration:0.2f animations:^{\n            self.view.transform = CGAffineTransformMakeRotation(M_PI_2);\n            self.view.bounds = CGRectMake(0, 0, width, height);\n        }];\n    } else {\n        [UIView animateWithDuration:0.2f animations:^{\n            self.view.transform = CGAffineTransformMakeRotation(0);\n            self.view.bounds = CGRectMake(0, 0, width, height);\n        }];\n    }\n}\n```\n\n## 最后\n>上面全部的代码配置好,iOS强制横屏就已经完成了,大伙自己实践一下!!!\n","slug":"iOS强制横屏实践","published":1,"updated":"2018-08-06T05:46:08.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkhy6qup000oduu9lgru4pbc","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>在开发视频播放器的时候,需要视频全屏播放同时还能响应手机旋转</p>\n</blockquote>\n<h2 id=\"所以\"><a href=\"#所以\" class=\"headerlink\" title=\"所以\"></a>所以</h2><blockquote>\n<p>通过资料查找,分为几种方案</p>\n</blockquote>\n<p><strong>方案一</strong></p>\n<blockquote>\n<p><code>View</code>旋转</p>\n</blockquote>\n<p><strong>方案二</strong></p>\n<blockquote>\n<p>转场动画</p>\n</blockquote>\n<p><strong>方案三</strong></p>\n<blockquote>\n<p>强制横竖屏</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><blockquote>\n<p>今天就考虑直接使用<strong>强制横竖屏</strong>来完成播放器的全屏播放</p>\n</blockquote>\n<ul>\n<li><p>General配置<br><img src=\"/2018/06/04/iOS强制横屏实践/横竖屏1.png\" alt=\"General配置\"></p>\n</li>\n<li><p>info.plist配置<br><img src=\"/2018/06/04/iOS强制横屏实践/横竖屏2.png\" alt=\"info.plist配置\"></p>\n</li>\n</ul>\n<blockquote>\n<p>横竖屏跳转的<code>Controller</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)interfaceOrientation:(UIInterfaceOrientation)orientation &#123;</span><br><span class=\"line\">    if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123;</span><br><span class=\"line\">        SEL selector             = NSSelectorFromString(@&quot;setOrientation:&quot;);</span><br><span class=\"line\">        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];</span><br><span class=\"line\">        [invocation setSelector:selector];</span><br><span class=\"line\">        [invocation setTarget:[UIDevice currentDevice]];</span><br><span class=\"line\">        int val                  = orientation;</span><br><span class=\"line\">        // 从2开始是因为0 1 两个参数已经被selector和target占用</span><br><span class=\"line\">        [invocation setArgument:&amp;val atIndex:2];</span><br><span class=\"line\">        [invocation invoke];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>重点,必须配置状态栏才能正确的跳转</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 跳转的Controller设置</span><br><span class=\"line\">- (BOOL)shouldAutorotate &#123;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>响应事件调用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self interfaceOrientation:UIInterfaceOrientationPortrait];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>一般我们都是<code>UITabBarController</code>和<code>UINavigationController</code>的结构来完成<code>App</code>的框架搭建</li>\n</ul>\n<blockquote>\n<p>配置<code>UITabBarController</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)shouldAutorotate&#123;</span><br><span class=\"line\">    return [self.selectedViewController shouldAutorotate];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123;</span><br><span class=\"line\">    return [self.selectedViewController supportedInterfaceOrientations];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123;</span><br><span class=\"line\">    return [self.selectedViewController preferredInterfaceOrientationForPresentation];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>配置<code>UINavigationController</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// viewDidLoad调用</span><br><span class=\"line\">[[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications];</span><br><span class=\"line\">    </span><br><span class=\"line\">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(deviceOrientationDidChange) name:UIDeviceOrientationDidChangeNotification object:nil];</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法一获取</span><br><span class=\"line\">- (BOOL)shouldAutorotate&#123;</span><br><span class=\"line\">    return [[self.viewControllers lastObject]shouldAutorotate];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123;</span><br><span class=\"line\">    return [[self.viewControllers lastObject]supportedInterfaceOrientations];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123;</span><br><span class=\"line\">    return [[self.viewControllers lastObject] preferredInterfaceOrientationForPresentation];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法二获取</span><br><span class=\"line\">- (BOOL)shouldAutorotate &#123;</span><br><span class=\"line\">    return [self.topViewController shouldAutorotate];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</span><br><span class=\"line\">    return [self.topViewController supportedInterfaceOrientations];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)deviceOrientationDidChange &#123;</span><br><span class=\"line\">    NSLog(@&quot;NAV deviceOrientationDidChange:%ld&quot;,(long)[UIDevice currentDevice].orientation);</span><br><span class=\"line\">    if([UIDevice currentDevice].orientation == UIDeviceOrientationPortrait) &#123;</span><br><span class=\"line\">        [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationPortrait];</span><br><span class=\"line\">        [self orientationChange:NO];</span><br><span class=\"line\">        //注意： UIDeviceOrientationLandscapeLeft 与 UIInterfaceOrientationLandscapeRight</span><br><span class=\"line\">    &#125; else if ([UIDevice currentDevice].orientation == UIDeviceOrientationLandscapeLeft) &#123;</span><br><span class=\"line\">        [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationLandscapeRight];</span><br><span class=\"line\">        [self orientationChange:YES];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)orientationChange:(BOOL)landscapeRight &#123;</span><br><span class=\"line\">    CGFloat width = [UIScreen mainScreen].bounds.size.width;</span><br><span class=\"line\">    CGFloat height = [UIScreen mainScreen].bounds.size.height;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (landscapeRight) &#123;</span><br><span class=\"line\">        [UIView animateWithDuration:0.2f animations:^&#123;</span><br><span class=\"line\">            self.view.transform = CGAffineTransformMakeRotation(M_PI_2);</span><br><span class=\"line\">            self.view.bounds = CGRectMake(0, 0, width, height);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        [UIView animateWithDuration:0.2f animations:^&#123;</span><br><span class=\"line\">            self.view.transform = CGAffineTransformMakeRotation(0);</span><br><span class=\"line\">            self.view.bounds = CGRectMake(0, 0, width, height);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><blockquote>\n<p>上面全部的代码配置好,iOS强制横屏就已经完成了,大伙自己实践一下!!!</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>在开发视频播放器的时候,需要视频全屏播放同时还能响应手机旋转</p>\n</blockquote>\n<h2 id=\"所以\"><a href=\"#所以\" class=\"headerlink\" title=\"所以\"></a>所以</h2><blockquote>\n<p>通过资料查找,分为几种方案</p>\n</blockquote>\n<p><strong>方案一</strong></p>\n<blockquote>\n<p><code>View</code>旋转</p>\n</blockquote>\n<p><strong>方案二</strong></p>\n<blockquote>\n<p>转场动画</p>\n</blockquote>\n<p><strong>方案三</strong></p>\n<blockquote>\n<p>强制横竖屏</p>\n</blockquote>","more":"<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><blockquote>\n<p>今天就考虑直接使用<strong>强制横竖屏</strong>来完成播放器的全屏播放</p>\n</blockquote>\n<ul>\n<li><p>General配置<br><img src=\"/2018/06/04/iOS强制横屏实践/横竖屏1.png\" alt=\"General配置\"></p>\n</li>\n<li><p>info.plist配置<br><img src=\"/2018/06/04/iOS强制横屏实践/横竖屏2.png\" alt=\"info.plist配置\"></p>\n</li>\n</ul>\n<blockquote>\n<p>横竖屏跳转的<code>Controller</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)interfaceOrientation:(UIInterfaceOrientation)orientation &#123;</span><br><span class=\"line\">    if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123;</span><br><span class=\"line\">        SEL selector             = NSSelectorFromString(@&quot;setOrientation:&quot;);</span><br><span class=\"line\">        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];</span><br><span class=\"line\">        [invocation setSelector:selector];</span><br><span class=\"line\">        [invocation setTarget:[UIDevice currentDevice]];</span><br><span class=\"line\">        int val                  = orientation;</span><br><span class=\"line\">        // 从2开始是因为0 1 两个参数已经被selector和target占用</span><br><span class=\"line\">        [invocation setArgument:&amp;val atIndex:2];</span><br><span class=\"line\">        [invocation invoke];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>重点,必须配置状态栏才能正确的跳转</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 跳转的Controller设置</span><br><span class=\"line\">- (BOOL)shouldAutorotate &#123;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>响应事件调用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self interfaceOrientation:UIInterfaceOrientationPortrait];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>一般我们都是<code>UITabBarController</code>和<code>UINavigationController</code>的结构来完成<code>App</code>的框架搭建</li>\n</ul>\n<blockquote>\n<p>配置<code>UITabBarController</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)shouldAutorotate&#123;</span><br><span class=\"line\">    return [self.selectedViewController shouldAutorotate];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123;</span><br><span class=\"line\">    return [self.selectedViewController supportedInterfaceOrientations];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123;</span><br><span class=\"line\">    return [self.selectedViewController preferredInterfaceOrientationForPresentation];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>配置<code>UINavigationController</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// viewDidLoad调用</span><br><span class=\"line\">[[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications];</span><br><span class=\"line\">    </span><br><span class=\"line\">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(deviceOrientationDidChange) name:UIDeviceOrientationDidChangeNotification object:nil];</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法一获取</span><br><span class=\"line\">- (BOOL)shouldAutorotate&#123;</span><br><span class=\"line\">    return [[self.viewControllers lastObject]shouldAutorotate];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123;</span><br><span class=\"line\">    return [[self.viewControllers lastObject]supportedInterfaceOrientations];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123;</span><br><span class=\"line\">    return [[self.viewControllers lastObject] preferredInterfaceOrientationForPresentation];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法二获取</span><br><span class=\"line\">- (BOOL)shouldAutorotate &#123;</span><br><span class=\"line\">    return [self.topViewController shouldAutorotate];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</span><br><span class=\"line\">    return [self.topViewController supportedInterfaceOrientations];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)deviceOrientationDidChange &#123;</span><br><span class=\"line\">    NSLog(@&quot;NAV deviceOrientationDidChange:%ld&quot;,(long)[UIDevice currentDevice].orientation);</span><br><span class=\"line\">    if([UIDevice currentDevice].orientation == UIDeviceOrientationPortrait) &#123;</span><br><span class=\"line\">        [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationPortrait];</span><br><span class=\"line\">        [self orientationChange:NO];</span><br><span class=\"line\">        //注意： UIDeviceOrientationLandscapeLeft 与 UIInterfaceOrientationLandscapeRight</span><br><span class=\"line\">    &#125; else if ([UIDevice currentDevice].orientation == UIDeviceOrientationLandscapeLeft) &#123;</span><br><span class=\"line\">        [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationLandscapeRight];</span><br><span class=\"line\">        [self orientationChange:YES];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)orientationChange:(BOOL)landscapeRight &#123;</span><br><span class=\"line\">    CGFloat width = [UIScreen mainScreen].bounds.size.width;</span><br><span class=\"line\">    CGFloat height = [UIScreen mainScreen].bounds.size.height;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (landscapeRight) &#123;</span><br><span class=\"line\">        [UIView animateWithDuration:0.2f animations:^&#123;</span><br><span class=\"line\">            self.view.transform = CGAffineTransformMakeRotation(M_PI_2);</span><br><span class=\"line\">            self.view.bounds = CGRectMake(0, 0, width, height);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        [UIView animateWithDuration:0.2f animations:^&#123;</span><br><span class=\"line\">            self.view.transform = CGAffineTransformMakeRotation(0);</span><br><span class=\"line\">            self.view.bounds = CGRectMake(0, 0, width, height);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><blockquote>\n<p>上面全部的代码配置好,iOS强制横屏就已经完成了,大伙自己实践一下!!!</p>\n</blockquote>"},{"title":"iOS横竖屏","date":"2018-08-06T07:13:34.000Z","_content":"\n### 前言\n\n>熟悉`iOS`框架结构,一般都是`UITabBarController`结合`UINavigationController`,所有需要配置信息\n\n- `UITabBarController`配置\n```\n- (BOOL)shouldAutorotate{\n    return [self.selectedViewController shouldAutorotate];\n}\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations{\n    return [self.selectedViewController supportedInterfaceOrientations];\n}\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation{\n    return [self.selectedViewController preferredInterfaceOrientationForPresentation];\n}\n```\n\n<!--more-->\n\n- `UINavigationController`配置\n```\n- (BOOL)shouldAutorotate {\n    return [[self.viewControllers lastObject] shouldAutorotate];\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return [[self.viewControllers lastObject] supportedInterfaceOrientations];\n}\n\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation{\n    return [[self.viewControllers lastObject] preferredInterfaceOrientationForPresentation];\n}\n```\n> 一般应用app开发都是个别页面需要设置好横屏设置,所有在基类里面设置所有的类不能横屏\n```\n-(UIInterfaceOrientationMask)supportedInterfaceOrientations\n{\n    return UIInterfaceOrientationMaskPortrait ;\n}\n- (BOOL)shouldAutorotate\n{\n    return NO;\n}\n-(UIInterfaceOrientation)preferredInterfaceOrientationForPresentation\n{\n    return UIInterfaceOrientationPortrait;\n}\n- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation{\n    return NO;\n}\n```\n\n- 旋转`ViewController`\n\n```\n// 允许屏幕旋转设置\n- (BOOL)shouldAutorotate {\n    return YES;\n}\n-(UIInterfaceOrientationMask)supportedInterfaceOrientations\n{\n    return UIInterfaceOrientationMaskAll;\n}\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation\n{\n    return UIInterfaceOrientationPortrait;\n}\n- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation\n{\n    return YES;\n}\n\n// 设置状态栏信息\n//设置样式\n- (UIStatusBarStyle)preferredStatusBarStyle {\n    return UIStatusBarStyleDefault;\n}\n\n//设置是否隐藏\n- (BOOL)prefersStatusBarHidden {\n    return NO;\n}\n\n//设置隐藏动画\n- (UIStatusBarAnimation)preferredStatusBarUpdateAnimation {\n    return UIStatusBarAnimationFade;\n}\n```\n\n> 页面设置跳转的逻辑\n\n```\n//iOS8旋转动作的具体执行\n- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id<UIViewControllerTransitionCoordinator>)coordinator {\n    [super viewWillTransitionToSize:size withTransitionCoordinator: coordinator];\n    // 监察者将执行： 1.旋转前的动作  2.旋转后的动作（completion）\n    [coordinator animateAlongsideTransition: ^(id<UIViewControllerTransitionCoordinatorContext> context) {\n        if ([XMRotatoUtil isOrientationLandscape]) {\n            self->_lastOrientation = [UIApplication sharedApplication].statusBarOrientation;\n            [self prepareFullScreen];\n        } else {\n            [self prepareSmallScreen];\n        }\n    } completion: ^(id<UIViewControllerTransitionCoordinatorContext> context) {\n        \n    }];\n}\n\n//iOS7旋转动作的具体执行\n- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration {\n    [super willRotateToInterfaceOrientation:toInterfaceOrientation duration:duration];\n    if (toInterfaceOrientation == UIDeviceOrientationLandscapeRight) {\n        _lastOrientation = [UIApplication sharedApplication].statusBarOrientation;\n        [self prepareFullScreen];\n    } else {\n        [self prepareSmallScreen];\n    }\n}\n```\n> 考虑到横屏,默认状态栏会隐藏,需要在`info.plist`文件中`View controller-based status bar appearance`为YES\n\n### 最后\n\n> 在横屏页面所有的都采用自动布局来达到对于的效果\n\n\n```\n// 屏幕方法调用\n+ (void)forceOrientation: (UIInterfaceOrientation)orientation {\n    if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) {\n        SEL selector = NSSelectorFromString(@\"setOrientation:\");\n        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];\n        [invocation setSelector:selector];\n        [invocation setTarget: [UIDevice currentDevice]];\n        int val = orientation;\n        [invocation setArgument:&val atIndex:2];\n        [invocation invoke];\n    }\n}\n\n+ (BOOL)isOrientationLandscape {\n    if (UIInterfaceOrientationIsLandscape([UIApplication sharedApplication].statusBarOrientation)) {\n        return YES;\n    } else {\n        return NO;\n    }\n}\n```\n\n> 需要配置Deplymengt info勾选竖屏和向右横屏,以解决横屏问题\n","source":"_posts/iOS横竖屏.md","raw":"---\ntitle: iOS横竖屏\ndate: 2018-08-06 15:13:34\ntags: \"iOS\"\ncategories: \"iOS开发\"\n---\n\n### 前言\n\n>熟悉`iOS`框架结构,一般都是`UITabBarController`结合`UINavigationController`,所有需要配置信息\n\n- `UITabBarController`配置\n```\n- (BOOL)shouldAutorotate{\n    return [self.selectedViewController shouldAutorotate];\n}\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations{\n    return [self.selectedViewController supportedInterfaceOrientations];\n}\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation{\n    return [self.selectedViewController preferredInterfaceOrientationForPresentation];\n}\n```\n\n<!--more-->\n\n- `UINavigationController`配置\n```\n- (BOOL)shouldAutorotate {\n    return [[self.viewControllers lastObject] shouldAutorotate];\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return [[self.viewControllers lastObject] supportedInterfaceOrientations];\n}\n\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation{\n    return [[self.viewControllers lastObject] preferredInterfaceOrientationForPresentation];\n}\n```\n> 一般应用app开发都是个别页面需要设置好横屏设置,所有在基类里面设置所有的类不能横屏\n```\n-(UIInterfaceOrientationMask)supportedInterfaceOrientations\n{\n    return UIInterfaceOrientationMaskPortrait ;\n}\n- (BOOL)shouldAutorotate\n{\n    return NO;\n}\n-(UIInterfaceOrientation)preferredInterfaceOrientationForPresentation\n{\n    return UIInterfaceOrientationPortrait;\n}\n- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation{\n    return NO;\n}\n```\n\n- 旋转`ViewController`\n\n```\n// 允许屏幕旋转设置\n- (BOOL)shouldAutorotate {\n    return YES;\n}\n-(UIInterfaceOrientationMask)supportedInterfaceOrientations\n{\n    return UIInterfaceOrientationMaskAll;\n}\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation\n{\n    return UIInterfaceOrientationPortrait;\n}\n- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation\n{\n    return YES;\n}\n\n// 设置状态栏信息\n//设置样式\n- (UIStatusBarStyle)preferredStatusBarStyle {\n    return UIStatusBarStyleDefault;\n}\n\n//设置是否隐藏\n- (BOOL)prefersStatusBarHidden {\n    return NO;\n}\n\n//设置隐藏动画\n- (UIStatusBarAnimation)preferredStatusBarUpdateAnimation {\n    return UIStatusBarAnimationFade;\n}\n```\n\n> 页面设置跳转的逻辑\n\n```\n//iOS8旋转动作的具体执行\n- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id<UIViewControllerTransitionCoordinator>)coordinator {\n    [super viewWillTransitionToSize:size withTransitionCoordinator: coordinator];\n    // 监察者将执行： 1.旋转前的动作  2.旋转后的动作（completion）\n    [coordinator animateAlongsideTransition: ^(id<UIViewControllerTransitionCoordinatorContext> context) {\n        if ([XMRotatoUtil isOrientationLandscape]) {\n            self->_lastOrientation = [UIApplication sharedApplication].statusBarOrientation;\n            [self prepareFullScreen];\n        } else {\n            [self prepareSmallScreen];\n        }\n    } completion: ^(id<UIViewControllerTransitionCoordinatorContext> context) {\n        \n    }];\n}\n\n//iOS7旋转动作的具体执行\n- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration {\n    [super willRotateToInterfaceOrientation:toInterfaceOrientation duration:duration];\n    if (toInterfaceOrientation == UIDeviceOrientationLandscapeRight) {\n        _lastOrientation = [UIApplication sharedApplication].statusBarOrientation;\n        [self prepareFullScreen];\n    } else {\n        [self prepareSmallScreen];\n    }\n}\n```\n> 考虑到横屏,默认状态栏会隐藏,需要在`info.plist`文件中`View controller-based status bar appearance`为YES\n\n### 最后\n\n> 在横屏页面所有的都采用自动布局来达到对于的效果\n\n\n```\n// 屏幕方法调用\n+ (void)forceOrientation: (UIInterfaceOrientation)orientation {\n    if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) {\n        SEL selector = NSSelectorFromString(@\"setOrientation:\");\n        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];\n        [invocation setSelector:selector];\n        [invocation setTarget: [UIDevice currentDevice]];\n        int val = orientation;\n        [invocation setArgument:&val atIndex:2];\n        [invocation invoke];\n    }\n}\n\n+ (BOOL)isOrientationLandscape {\n    if (UIInterfaceOrientationIsLandscape([UIApplication sharedApplication].statusBarOrientation)) {\n        return YES;\n    } else {\n        return NO;\n    }\n}\n```\n\n> 需要配置Deplymengt info勾选竖屏和向右横屏,以解决横屏问题\n","slug":"iOS横竖屏","published":1,"updated":"2018-08-06T07:18:19.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkhy6quq000qduu9m924hm63","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>熟悉<code>iOS</code>框架结构,一般都是<code>UITabBarController</code>结合<code>UINavigationController</code>,所有需要配置信息</p>\n</blockquote>\n<ul>\n<li><code>UITabBarController</code>配置<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)shouldAutorotate&#123;</span><br><span class=\"line\">    return [self.selectedViewController shouldAutorotate];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123;</span><br><span class=\"line\">    return [self.selectedViewController supportedInterfaceOrientations];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123;</span><br><span class=\"line\">    return [self.selectedViewController preferredInterfaceOrientationForPresentation];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><code>UINavigationController</code>配置<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)shouldAutorotate &#123;</span><br><span class=\"line\">    return [[self.viewControllers lastObject] shouldAutorotate];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</span><br><span class=\"line\">    return [[self.viewControllers lastObject] supportedInterfaceOrientations];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123;</span><br><span class=\"line\">    return [[self.viewControllers lastObject] preferredInterfaceOrientationForPresentation];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>一般应用app开发都是个别页面需要设置好横屏设置,所有在基类里面设置所有的类不能横屏<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(UIInterfaceOrientationMask)supportedInterfaceOrientations</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return UIInterfaceOrientationMaskPortrait ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (BOOL)shouldAutorotate</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">-(UIInterfaceOrientation)preferredInterfaceOrientationForPresentation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return UIInterfaceOrientationPortrait;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation&#123;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<ul>\n<li>旋转<code>ViewController</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 允许屏幕旋转设置</span><br><span class=\"line\">- (BOOL)shouldAutorotate &#123;</span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">-(UIInterfaceOrientationMask)supportedInterfaceOrientations</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return UIInterfaceOrientationMaskAll;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return UIInterfaceOrientationPortrait;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 设置状态栏信息</span><br><span class=\"line\">//设置样式</span><br><span class=\"line\">- (UIStatusBarStyle)preferredStatusBarStyle &#123;</span><br><span class=\"line\">    return UIStatusBarStyleDefault;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//设置是否隐藏</span><br><span class=\"line\">- (BOOL)prefersStatusBarHidden &#123;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//设置隐藏动画</span><br><span class=\"line\">- (UIStatusBarAnimation)preferredStatusBarUpdateAnimation &#123;</span><br><span class=\"line\">    return UIStatusBarAnimationFade;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>页面设置跳转的逻辑</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//iOS8旋转动作的具体执行</span><br><span class=\"line\">- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id&lt;UIViewControllerTransitionCoordinator&gt;)coordinator &#123;</span><br><span class=\"line\">    [super viewWillTransitionToSize:size withTransitionCoordinator: coordinator];</span><br><span class=\"line\">    // 监察者将执行： 1.旋转前的动作  2.旋转后的动作（completion）</span><br><span class=\"line\">    [coordinator animateAlongsideTransition: ^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context) &#123;</span><br><span class=\"line\">        if ([XMRotatoUtil isOrientationLandscape]) &#123;</span><br><span class=\"line\">            self-&gt;_lastOrientation = [UIApplication sharedApplication].statusBarOrientation;</span><br><span class=\"line\">            [self prepareFullScreen];</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            [self prepareSmallScreen];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; completion: ^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//iOS7旋转动作的具体执行</span><br><span class=\"line\">- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration &#123;</span><br><span class=\"line\">    [super willRotateToInterfaceOrientation:toInterfaceOrientation duration:duration];</span><br><span class=\"line\">    if (toInterfaceOrientation == UIDeviceOrientationLandscapeRight) &#123;</span><br><span class=\"line\">        _lastOrientation = [UIApplication sharedApplication].statusBarOrientation;</span><br><span class=\"line\">        [self prepareFullScreen];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        [self prepareSmallScreen];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>考虑到横屏,默认状态栏会隐藏,需要在<code>info.plist</code>文件中<code>View controller-based status bar appearance</code>为YES</p>\n</blockquote>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><blockquote>\n<p>在横屏页面所有的都采用自动布局来达到对于的效果</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 屏幕方法调用</span><br><span class=\"line\">+ (void)forceOrientation: (UIInterfaceOrientation)orientation &#123;</span><br><span class=\"line\">    if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123;</span><br><span class=\"line\">        SEL selector = NSSelectorFromString(@&quot;setOrientation:&quot;);</span><br><span class=\"line\">        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];</span><br><span class=\"line\">        [invocation setSelector:selector];</span><br><span class=\"line\">        [invocation setTarget: [UIDevice currentDevice]];</span><br><span class=\"line\">        int val = orientation;</span><br><span class=\"line\">        [invocation setArgument:&amp;val atIndex:2];</span><br><span class=\"line\">        [invocation invoke];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)isOrientationLandscape &#123;</span><br><span class=\"line\">    if (UIInterfaceOrientationIsLandscape([UIApplication sharedApplication].statusBarOrientation)) &#123;</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>需要配置Deplymengt info勾选竖屏和向右横屏,以解决横屏问题</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>熟悉<code>iOS</code>框架结构,一般都是<code>UITabBarController</code>结合<code>UINavigationController</code>,所有需要配置信息</p>\n</blockquote>\n<ul>\n<li><code>UITabBarController</code>配置<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)shouldAutorotate&#123;</span><br><span class=\"line\">    return [self.selectedViewController shouldAutorotate];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123;</span><br><span class=\"line\">    return [self.selectedViewController supportedInterfaceOrientations];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123;</span><br><span class=\"line\">    return [self.selectedViewController preferredInterfaceOrientationForPresentation];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>","more":"<ul>\n<li><code>UINavigationController</code>配置<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)shouldAutorotate &#123;</span><br><span class=\"line\">    return [[self.viewControllers lastObject] shouldAutorotate];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</span><br><span class=\"line\">    return [[self.viewControllers lastObject] supportedInterfaceOrientations];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123;</span><br><span class=\"line\">    return [[self.viewControllers lastObject] preferredInterfaceOrientationForPresentation];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>一般应用app开发都是个别页面需要设置好横屏设置,所有在基类里面设置所有的类不能横屏<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(UIInterfaceOrientationMask)supportedInterfaceOrientations</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return UIInterfaceOrientationMaskPortrait ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (BOOL)shouldAutorotate</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">-(UIInterfaceOrientation)preferredInterfaceOrientationForPresentation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return UIInterfaceOrientationPortrait;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation&#123;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<ul>\n<li>旋转<code>ViewController</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 允许屏幕旋转设置</span><br><span class=\"line\">- (BOOL)shouldAutorotate &#123;</span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">-(UIInterfaceOrientationMask)supportedInterfaceOrientations</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return UIInterfaceOrientationMaskAll;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return UIInterfaceOrientationPortrait;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 设置状态栏信息</span><br><span class=\"line\">//设置样式</span><br><span class=\"line\">- (UIStatusBarStyle)preferredStatusBarStyle &#123;</span><br><span class=\"line\">    return UIStatusBarStyleDefault;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//设置是否隐藏</span><br><span class=\"line\">- (BOOL)prefersStatusBarHidden &#123;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//设置隐藏动画</span><br><span class=\"line\">- (UIStatusBarAnimation)preferredStatusBarUpdateAnimation &#123;</span><br><span class=\"line\">    return UIStatusBarAnimationFade;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>页面设置跳转的逻辑</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//iOS8旋转动作的具体执行</span><br><span class=\"line\">- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id&lt;UIViewControllerTransitionCoordinator&gt;)coordinator &#123;</span><br><span class=\"line\">    [super viewWillTransitionToSize:size withTransitionCoordinator: coordinator];</span><br><span class=\"line\">    // 监察者将执行： 1.旋转前的动作  2.旋转后的动作（completion）</span><br><span class=\"line\">    [coordinator animateAlongsideTransition: ^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context) &#123;</span><br><span class=\"line\">        if ([XMRotatoUtil isOrientationLandscape]) &#123;</span><br><span class=\"line\">            self-&gt;_lastOrientation = [UIApplication sharedApplication].statusBarOrientation;</span><br><span class=\"line\">            [self prepareFullScreen];</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            [self prepareSmallScreen];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; completion: ^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//iOS7旋转动作的具体执行</span><br><span class=\"line\">- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration &#123;</span><br><span class=\"line\">    [super willRotateToInterfaceOrientation:toInterfaceOrientation duration:duration];</span><br><span class=\"line\">    if (toInterfaceOrientation == UIDeviceOrientationLandscapeRight) &#123;</span><br><span class=\"line\">        _lastOrientation = [UIApplication sharedApplication].statusBarOrientation;</span><br><span class=\"line\">        [self prepareFullScreen];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        [self prepareSmallScreen];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>考虑到横屏,默认状态栏会隐藏,需要在<code>info.plist</code>文件中<code>View controller-based status bar appearance</code>为YES</p>\n</blockquote>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><blockquote>\n<p>在横屏页面所有的都采用自动布局来达到对于的效果</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 屏幕方法调用</span><br><span class=\"line\">+ (void)forceOrientation: (UIInterfaceOrientation)orientation &#123;</span><br><span class=\"line\">    if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123;</span><br><span class=\"line\">        SEL selector = NSSelectorFromString(@&quot;setOrientation:&quot;);</span><br><span class=\"line\">        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];</span><br><span class=\"line\">        [invocation setSelector:selector];</span><br><span class=\"line\">        [invocation setTarget: [UIDevice currentDevice]];</span><br><span class=\"line\">        int val = orientation;</span><br><span class=\"line\">        [invocation setArgument:&amp;val atIndex:2];</span><br><span class=\"line\">        [invocation invoke];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)isOrientationLandscape &#123;</span><br><span class=\"line\">    if (UIInterfaceOrientationIsLandscape([UIApplication sharedApplication].statusBarOrientation)) &#123;</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>需要配置Deplymengt info勾选竖屏和向右横屏,以解决横屏问题</p>\n</blockquote>"},{"title":"iOS熟悉@property和set方法和get方法","date":"2018-06-05T07:37:20.000Z","_content":"\n## 前言\n\n`@property (nonatomic, assign) CGFloat height;`\n\n>`@property`声明了成员变量，没有自己去写它的**`set`**方法和**`get`**方法,`Xcode`系统会自动生成**`set`**和**`get`**方法。同时生成一个下划线成员变量\n\n\n- 你调用的时候，赋值的值是多少就是多少\n\n```\nPerson *p = [[Person alloc] init];\np.height = 170.0;\nNSLog(@\"%f\",p.height); //打印得170.0\n```\n\n- 如果你自己写了**`set`**方法，却没有在里面做任何操作，会默认调用**`_height`**。所有的成员变量初始值都是0.所以即便你在调用**`set`**方法的时候赋值，打印出来也是0\n\n<!--more-->\n\n**Set方法**\n\n```\n- (void)setHeight:(CGFloat)height {\n\n}\n```\n\n```\nPerson *p = [[Person alloc] init];\np.height = 170.0;\nNSLog(@\"%f\",p.height); //打印得0.0\n```\n\n- 如果你自己写了**`get`**方法，在里面return 180.0。你在调用**`get`**方法的时候赋值，打印出来也是就是你**`get`**方法里面返回的值180.0\n\n**Get方法**\n\n```\n- (CGFloat)height {\n\treturn 180.0;\n}\n```\n\n```\nPerson *p = [[Person alloc] init];\np.height = 170.0;\nNSLog(@\"%f\",p.height); //打印得180.0\n```\n\n>`=`左边**`height`**是调用**`set`**方法\n\n>`=`右边**`height`**是调用**`get`**方法\n\n> 如果你自己同时生成了**`set`**和**`get`**方法，那系统就不会生成`下划线成员变量`\n\n- 手动实现**`set`**方法和**`get`**方法\n```\n@synthesize height = _height;\n\n- (void)setHeight:(CGFloat)height {\n    _height = height;\n}\n\n- (CGFloat)height {\n    return _height;\n}\n```\n\n## Runtime\n\n`Runtime`key值使用C语言字符串\n\n`static char imageURLKey` = `&imageURLKey`\n\n`static char imageURLKey = \"imageURLKey\"`","source":"_posts/iOS熟悉-property和set方法和get方法.md","raw":"---\ntitle: iOS熟悉@property和set方法和get方法\ndate: 2018-06-05 15:37:20\ntags: \"iOS\"\ncategories: \"iOS基础\"\n---\n\n## 前言\n\n`@property (nonatomic, assign) CGFloat height;`\n\n>`@property`声明了成员变量，没有自己去写它的**`set`**方法和**`get`**方法,`Xcode`系统会自动生成**`set`**和**`get`**方法。同时生成一个下划线成员变量\n\n\n- 你调用的时候，赋值的值是多少就是多少\n\n```\nPerson *p = [[Person alloc] init];\np.height = 170.0;\nNSLog(@\"%f\",p.height); //打印得170.0\n```\n\n- 如果你自己写了**`set`**方法，却没有在里面做任何操作，会默认调用**`_height`**。所有的成员变量初始值都是0.所以即便你在调用**`set`**方法的时候赋值，打印出来也是0\n\n<!--more-->\n\n**Set方法**\n\n```\n- (void)setHeight:(CGFloat)height {\n\n}\n```\n\n```\nPerson *p = [[Person alloc] init];\np.height = 170.0;\nNSLog(@\"%f\",p.height); //打印得0.0\n```\n\n- 如果你自己写了**`get`**方法，在里面return 180.0。你在调用**`get`**方法的时候赋值，打印出来也是就是你**`get`**方法里面返回的值180.0\n\n**Get方法**\n\n```\n- (CGFloat)height {\n\treturn 180.0;\n}\n```\n\n```\nPerson *p = [[Person alloc] init];\np.height = 170.0;\nNSLog(@\"%f\",p.height); //打印得180.0\n```\n\n>`=`左边**`height`**是调用**`set`**方法\n\n>`=`右边**`height`**是调用**`get`**方法\n\n> 如果你自己同时生成了**`set`**和**`get`**方法，那系统就不会生成`下划线成员变量`\n\n- 手动实现**`set`**方法和**`get`**方法\n```\n@synthesize height = _height;\n\n- (void)setHeight:(CGFloat)height {\n    _height = height;\n}\n\n- (CGFloat)height {\n    return _height;\n}\n```\n\n## Runtime\n\n`Runtime`key值使用C语言字符串\n\n`static char imageURLKey` = `&imageURLKey`\n\n`static char imageURLKey = \"imageURLKey\"`","slug":"iOS熟悉-property和set方法和get方法","published":1,"updated":"2018-08-06T05:46:08.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkhy6qus000vduu9sct0eeoj","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>@property (nonatomic, assign) CGFloat height;</code></p>\n<blockquote>\n<p><code>@property</code>声明了成员变量，没有自己去写它的<strong><code>set</code></strong>方法和<strong><code>get</code></strong>方法,<code>Xcode</code>系统会自动生成<strong><code>set</code></strong>和<strong><code>get</code></strong>方法。同时生成一个下划线成员变量</p>\n</blockquote>\n<ul>\n<li>你调用的时候，赋值的值是多少就是多少</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person *p = [[Person alloc] init];</span><br><span class=\"line\">p.height = 170.0;</span><br><span class=\"line\">NSLog(@&quot;%f&quot;,p.height); //打印得170.0</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果你自己写了<strong><code>set</code></strong>方法，却没有在里面做任何操作，会默认调用<strong><code>_height</code></strong>。所有的成员变量初始值都是0.所以即便你在调用<strong><code>set</code></strong>方法的时候赋值，打印出来也是0</li>\n</ul>\n<a id=\"more\"></a>\n<p><strong>Set方法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setHeight:(CGFloat)height &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person *p = [[Person alloc] init];</span><br><span class=\"line\">p.height = 170.0;</span><br><span class=\"line\">NSLog(@&quot;%f&quot;,p.height); //打印得0.0</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果你自己写了<strong><code>get</code></strong>方法，在里面return 180.0。你在调用<strong><code>get</code></strong>方法的时候赋值，打印出来也是就是你<strong><code>get</code></strong>方法里面返回的值180.0</li>\n</ul>\n<p><strong>Get方法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (CGFloat)height &#123;</span><br><span class=\"line\">\treturn 180.0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person *p = [[Person alloc] init];</span><br><span class=\"line\">p.height = 170.0;</span><br><span class=\"line\">NSLog(@&quot;%f&quot;,p.height); //打印得180.0</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>=</code>左边<strong><code>height</code></strong>是调用<strong><code>set</code></strong>方法</p>\n</blockquote>\n<blockquote>\n<p><code>=</code>右边<strong><code>height</code></strong>是调用<strong><code>get</code></strong>方法</p>\n</blockquote>\n<blockquote>\n<p>如果你自己同时生成了<strong><code>set</code></strong>和<strong><code>get</code></strong>方法，那系统就不会生成<code>下划线成员变量</code></p>\n</blockquote>\n<ul>\n<li>手动实现<strong><code>set</code></strong>方法和<strong><code>get</code></strong>方法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@synthesize height = _height;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setHeight:(CGFloat)height &#123;</span><br><span class=\"line\">    _height = height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (CGFloat)height &#123;</span><br><span class=\"line\">    return _height;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Runtime\"><a href=\"#Runtime\" class=\"headerlink\" title=\"Runtime\"></a>Runtime</h2><p><code>Runtime</code>key值使用C语言字符串</p>\n<p><code>static char imageURLKey</code> = <code>&amp;imageURLKey</code></p>\n<p><code>static char imageURLKey = &quot;imageURLKey&quot;</code></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>@property (nonatomic, assign) CGFloat height;</code></p>\n<blockquote>\n<p><code>@property</code>声明了成员变量，没有自己去写它的<strong><code>set</code></strong>方法和<strong><code>get</code></strong>方法,<code>Xcode</code>系统会自动生成<strong><code>set</code></strong>和<strong><code>get</code></strong>方法。同时生成一个下划线成员变量</p>\n</blockquote>\n<ul>\n<li>你调用的时候，赋值的值是多少就是多少</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person *p = [[Person alloc] init];</span><br><span class=\"line\">p.height = 170.0;</span><br><span class=\"line\">NSLog(@&quot;%f&quot;,p.height); //打印得170.0</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果你自己写了<strong><code>set</code></strong>方法，却没有在里面做任何操作，会默认调用<strong><code>_height</code></strong>。所有的成员变量初始值都是0.所以即便你在调用<strong><code>set</code></strong>方法的时候赋值，打印出来也是0</li>\n</ul>","more":"<p><strong>Set方法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setHeight:(CGFloat)height &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person *p = [[Person alloc] init];</span><br><span class=\"line\">p.height = 170.0;</span><br><span class=\"line\">NSLog(@&quot;%f&quot;,p.height); //打印得0.0</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果你自己写了<strong><code>get</code></strong>方法，在里面return 180.0。你在调用<strong><code>get</code></strong>方法的时候赋值，打印出来也是就是你<strong><code>get</code></strong>方法里面返回的值180.0</li>\n</ul>\n<p><strong>Get方法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (CGFloat)height &#123;</span><br><span class=\"line\">\treturn 180.0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person *p = [[Person alloc] init];</span><br><span class=\"line\">p.height = 170.0;</span><br><span class=\"line\">NSLog(@&quot;%f&quot;,p.height); //打印得180.0</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>=</code>左边<strong><code>height</code></strong>是调用<strong><code>set</code></strong>方法</p>\n</blockquote>\n<blockquote>\n<p><code>=</code>右边<strong><code>height</code></strong>是调用<strong><code>get</code></strong>方法</p>\n</blockquote>\n<blockquote>\n<p>如果你自己同时生成了<strong><code>set</code></strong>和<strong><code>get</code></strong>方法，那系统就不会生成<code>下划线成员变量</code></p>\n</blockquote>\n<ul>\n<li>手动实现<strong><code>set</code></strong>方法和<strong><code>get</code></strong>方法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@synthesize height = _height;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setHeight:(CGFloat)height &#123;</span><br><span class=\"line\">    _height = height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (CGFloat)height &#123;</span><br><span class=\"line\">    return _height;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Runtime\"><a href=\"#Runtime\" class=\"headerlink\" title=\"Runtime\"></a>Runtime</h2><p><code>Runtime</code>key值使用C语言字符串</p>\n<p><code>static char imageURLKey</code> = <code>&amp;imageURLKey</code></p>\n<p><code>static char imageURLKey = &quot;imageURLKey&quot;</code></p>"},{"title":"iOS熟悉UIEdgeInsetsMake使用","date":"2018-05-13T07:28:14.000Z","_content":"\n## 理解UIEdgeInsetsMake\n\n>`Creates an edge inset for a button or view.`开发文档中显示\n\n>定义调用方法`UIEdgeInsets UIEdgeInsetsMake(CGFloat top, CGFloat left, CGFloat bottom, CGFloat right)`\n\n```\ntypedef struct UIEdgeInsets {\n    CGFloat top, left, bottom, right;  // specify amount to inset (positive) for each of the edges. values can be negative to 'outset'\n} UIEdgeInsets;\n```\n\n**简单点说就是对视图的偏移**\n\n## 看黑板,使用说明\n\n1. 定义一个`UIButton`,对它的子视图对它进行布局\n\n2. 按钮`titleLabel`的`titleEdgeInsets`\n\n3. 按钮`imageView`的`imageEdgeInsets`\n\n<!--more-->\n\n```\n[btn setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn.imageView.frame.size.width, 0, 0)];\n[btn setImageEdgeInsets:UIEdgeInsetsMake(0, 0, 0, -btn.titleLabel.intrinsicContentSize.width)];\n```\n\n>**按钮图片文字居中**\n![按钮图片文字居中](iOS熟悉UIEdgeInsetsMake使用/按钮图片文字居中.png)\n\n### `imageView`在左，`titleLabel`在右 `UIButton`系统默认\n\n\n### `imageView`在上，`titleLabel`在下 \n\n```\n[btn setTitleEdgeInsets:UIEdgeInsetsMake(btn.titleLabel.intrinsicContentSize.height + 10, -btn.imageView.frame.size.width, 0, 0)];\n[btn setImageEdgeInsets:UIEdgeInsetsMake(0, 0, btn.imageView.frame.size.height + 10, -btn.titleLabel.intrinsicContentSize.width)];\n考虑间隙对图片和文字加了10的偏移量\n\n```\n>**按钮图片在上文字在下**\n![按钮图片在上文字在下](iOS熟悉UIEdgeInsetsMake使用/按钮图片在上文字在下.png)\n\n### `imageView`在下，`titleLabel`在上\n\n```\n[btn setTitleEdgeInsets:UIEdgeInsetsMake(-btn.titleLabel.intrinsicContentSize.height - 10, -btn.imageView.frame.size.width, 0, 0)];\n[btn setImageEdgeInsets:UIEdgeInsetsMake(0, 0, -btn.imageView.frame.size.height - 10, -btn.titleLabel.intrinsicContentSize.width)];\n\n```\n>**按钮图片在下文字在上**\n![按钮图片在下文字在上](iOS熟悉UIEdgeInsetsMake使用/按钮图片在下文字在上.png)\n\n### `imageView`在右，`titleLabel`在左\n\n```\n[btn setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn.imageView.frame.size.width, 0, btn.imageView.frame.size.width)];\n[btn setImageEdgeInsets:UIEdgeInsetsMake(0, btn.titleLabel.intrinsicContentSize.width, 0, -btn.titleLabel.intrinsicContentSize.width)];\n```\n\n>**按钮图片在右文字在左**\n![按钮图片在右文字在左](iOS熟悉UIEdgeInsetsMake使用/按钮图片在右文字在左.png)\n\n\n### `imageView`靠右，`titleLabel`靠左\n```\n[btn setImageEdgeInsets:UIEdgeInsetsMake(0, btn.frame.size.width - btn.imageView.frame.size.width, 0, -btn.titleLabel.intrinsicContentSize.width)];\n[btn setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn.imageView.frame.size.width, 0, btn.frame.size.width - btn.titleLabel.intrinsicContentSize.width)];\n```\n\n\n**`intrinsicContentSize`是iOS 8时候获取的属性**\n","source":"_posts/iOS熟悉UIEdgeInsetsMake使用.md","raw":"---\ntitle: iOS熟悉UIEdgeInsetsMake使用\ndate: 2018-05-13 15:28:14\ntags: \"iOS\"\ncategories: \"iOS开发\"\n---\n\n## 理解UIEdgeInsetsMake\n\n>`Creates an edge inset for a button or view.`开发文档中显示\n\n>定义调用方法`UIEdgeInsets UIEdgeInsetsMake(CGFloat top, CGFloat left, CGFloat bottom, CGFloat right)`\n\n```\ntypedef struct UIEdgeInsets {\n    CGFloat top, left, bottom, right;  // specify amount to inset (positive) for each of the edges. values can be negative to 'outset'\n} UIEdgeInsets;\n```\n\n**简单点说就是对视图的偏移**\n\n## 看黑板,使用说明\n\n1. 定义一个`UIButton`,对它的子视图对它进行布局\n\n2. 按钮`titleLabel`的`titleEdgeInsets`\n\n3. 按钮`imageView`的`imageEdgeInsets`\n\n<!--more-->\n\n```\n[btn setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn.imageView.frame.size.width, 0, 0)];\n[btn setImageEdgeInsets:UIEdgeInsetsMake(0, 0, 0, -btn.titleLabel.intrinsicContentSize.width)];\n```\n\n>**按钮图片文字居中**\n![按钮图片文字居中](iOS熟悉UIEdgeInsetsMake使用/按钮图片文字居中.png)\n\n### `imageView`在左，`titleLabel`在右 `UIButton`系统默认\n\n\n### `imageView`在上，`titleLabel`在下 \n\n```\n[btn setTitleEdgeInsets:UIEdgeInsetsMake(btn.titleLabel.intrinsicContentSize.height + 10, -btn.imageView.frame.size.width, 0, 0)];\n[btn setImageEdgeInsets:UIEdgeInsetsMake(0, 0, btn.imageView.frame.size.height + 10, -btn.titleLabel.intrinsicContentSize.width)];\n考虑间隙对图片和文字加了10的偏移量\n\n```\n>**按钮图片在上文字在下**\n![按钮图片在上文字在下](iOS熟悉UIEdgeInsetsMake使用/按钮图片在上文字在下.png)\n\n### `imageView`在下，`titleLabel`在上\n\n```\n[btn setTitleEdgeInsets:UIEdgeInsetsMake(-btn.titleLabel.intrinsicContentSize.height - 10, -btn.imageView.frame.size.width, 0, 0)];\n[btn setImageEdgeInsets:UIEdgeInsetsMake(0, 0, -btn.imageView.frame.size.height - 10, -btn.titleLabel.intrinsicContentSize.width)];\n\n```\n>**按钮图片在下文字在上**\n![按钮图片在下文字在上](iOS熟悉UIEdgeInsetsMake使用/按钮图片在下文字在上.png)\n\n### `imageView`在右，`titleLabel`在左\n\n```\n[btn setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn.imageView.frame.size.width, 0, btn.imageView.frame.size.width)];\n[btn setImageEdgeInsets:UIEdgeInsetsMake(0, btn.titleLabel.intrinsicContentSize.width, 0, -btn.titleLabel.intrinsicContentSize.width)];\n```\n\n>**按钮图片在右文字在左**\n![按钮图片在右文字在左](iOS熟悉UIEdgeInsetsMake使用/按钮图片在右文字在左.png)\n\n\n### `imageView`靠右，`titleLabel`靠左\n```\n[btn setImageEdgeInsets:UIEdgeInsetsMake(0, btn.frame.size.width - btn.imageView.frame.size.width, 0, -btn.titleLabel.intrinsicContentSize.width)];\n[btn setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn.imageView.frame.size.width, 0, btn.frame.size.width - btn.titleLabel.intrinsicContentSize.width)];\n```\n\n\n**`intrinsicContentSize`是iOS 8时候获取的属性**\n","slug":"iOS熟悉UIEdgeInsetsMake使用","published":1,"updated":"2018-08-06T05:46:08.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkhy6qut000yduu9tthp7p3y","content":"<h2 id=\"理解UIEdgeInsetsMake\"><a href=\"#理解UIEdgeInsetsMake\" class=\"headerlink\" title=\"理解UIEdgeInsetsMake\"></a>理解UIEdgeInsetsMake</h2><blockquote>\n<p><code>Creates an edge inset for a button or view.</code>开发文档中显示</p>\n</blockquote>\n<blockquote>\n<p>定义调用方法<code>UIEdgeInsets UIEdgeInsetsMake(CGFloat top, CGFloat left, CGFloat bottom, CGFloat right)</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct UIEdgeInsets &#123;</span><br><span class=\"line\">    CGFloat top, left, bottom, right;  // specify amount to inset (positive) for each of the edges. values can be negative to &apos;outset&apos;</span><br><span class=\"line\">&#125; UIEdgeInsets;</span><br></pre></td></tr></table></figure>\n<p><strong>简单点说就是对视图的偏移</strong></p>\n<h2 id=\"看黑板-使用说明\"><a href=\"#看黑板-使用说明\" class=\"headerlink\" title=\"看黑板,使用说明\"></a>看黑板,使用说明</h2><ol>\n<li><p>定义一个<code>UIButton</code>,对它的子视图对它进行布局</p>\n</li>\n<li><p>按钮<code>titleLabel</code>的<code>titleEdgeInsets</code></p>\n</li>\n<li><p>按钮<code>imageView</code>的<code>imageEdgeInsets</code></p>\n</li>\n</ol>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[btn setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn.imageView.frame.size.width, 0, 0)];</span><br><span class=\"line\">[btn setImageEdgeInsets:UIEdgeInsetsMake(0, 0, 0, -btn.titleLabel.intrinsicContentSize.width)];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>按钮图片文字居中</strong><br><img src=\"/2018/05/13/iOS熟悉UIEdgeInsetsMake使用/按钮图片文字居中.png\" alt=\"按钮图片文字居中\"></p>\n</blockquote>\n<h3 id=\"imageView在左，titleLabel在右-UIButton系统默认\"><a href=\"#imageView在左，titleLabel在右-UIButton系统默认\" class=\"headerlink\" title=\"imageView在左，titleLabel在右 UIButton系统默认\"></a><code>imageView</code>在左，<code>titleLabel</code>在右 <code>UIButton</code>系统默认</h3><h3 id=\"imageView在上，titleLabel在下\"><a href=\"#imageView在上，titleLabel在下\" class=\"headerlink\" title=\"imageView在上，titleLabel在下\"></a><code>imageView</code>在上，<code>titleLabel</code>在下</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[btn setTitleEdgeInsets:UIEdgeInsetsMake(btn.titleLabel.intrinsicContentSize.height + 10, -btn.imageView.frame.size.width, 0, 0)];</span><br><span class=\"line\">[btn setImageEdgeInsets:UIEdgeInsetsMake(0, 0, btn.imageView.frame.size.height + 10, -btn.titleLabel.intrinsicContentSize.width)];</span><br><span class=\"line\">考虑间隙对图片和文字加了10的偏移量</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>按钮图片在上文字在下</strong><br><img src=\"/2018/05/13/iOS熟悉UIEdgeInsetsMake使用/按钮图片在上文字在下.png\" alt=\"按钮图片在上文字在下\"></p>\n</blockquote>\n<h3 id=\"imageView在下，titleLabel在上\"><a href=\"#imageView在下，titleLabel在上\" class=\"headerlink\" title=\"imageView在下，titleLabel在上\"></a><code>imageView</code>在下，<code>titleLabel</code>在上</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[btn setTitleEdgeInsets:UIEdgeInsetsMake(-btn.titleLabel.intrinsicContentSize.height - 10, -btn.imageView.frame.size.width, 0, 0)];</span><br><span class=\"line\">[btn setImageEdgeInsets:UIEdgeInsetsMake(0, 0, -btn.imageView.frame.size.height - 10, -btn.titleLabel.intrinsicContentSize.width)];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>按钮图片在下文字在上</strong><br><img src=\"/2018/05/13/iOS熟悉UIEdgeInsetsMake使用/按钮图片在下文字在上.png\" alt=\"按钮图片在下文字在上\"></p>\n</blockquote>\n<h3 id=\"imageView在右，titleLabel在左\"><a href=\"#imageView在右，titleLabel在左\" class=\"headerlink\" title=\"imageView在右，titleLabel在左\"></a><code>imageView</code>在右，<code>titleLabel</code>在左</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[btn setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn.imageView.frame.size.width, 0, btn.imageView.frame.size.width)];</span><br><span class=\"line\">[btn setImageEdgeInsets:UIEdgeInsetsMake(0, btn.titleLabel.intrinsicContentSize.width, 0, -btn.titleLabel.intrinsicContentSize.width)];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>按钮图片在右文字在左</strong><br><img src=\"/2018/05/13/iOS熟悉UIEdgeInsetsMake使用/按钮图片在右文字在左.png\" alt=\"按钮图片在右文字在左\"></p>\n</blockquote>\n<h3 id=\"imageView靠右，titleLabel靠左\"><a href=\"#imageView靠右，titleLabel靠左\" class=\"headerlink\" title=\"imageView靠右，titleLabel靠左\"></a><code>imageView</code>靠右，<code>titleLabel</code>靠左</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[btn setImageEdgeInsets:UIEdgeInsetsMake(0, btn.frame.size.width - btn.imageView.frame.size.width, 0, -btn.titleLabel.intrinsicContentSize.width)];</span><br><span class=\"line\">[btn setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn.imageView.frame.size.width, 0, btn.frame.size.width - btn.titleLabel.intrinsicContentSize.width)];</span><br></pre></td></tr></table></figure>\n<p><strong><code>intrinsicContentSize</code>是iOS 8时候获取的属性</strong></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"理解UIEdgeInsetsMake\"><a href=\"#理解UIEdgeInsetsMake\" class=\"headerlink\" title=\"理解UIEdgeInsetsMake\"></a>理解UIEdgeInsetsMake</h2><blockquote>\n<p><code>Creates an edge inset for a button or view.</code>开发文档中显示</p>\n</blockquote>\n<blockquote>\n<p>定义调用方法<code>UIEdgeInsets UIEdgeInsetsMake(CGFloat top, CGFloat left, CGFloat bottom, CGFloat right)</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct UIEdgeInsets &#123;</span><br><span class=\"line\">    CGFloat top, left, bottom, right;  // specify amount to inset (positive) for each of the edges. values can be negative to &apos;outset&apos;</span><br><span class=\"line\">&#125; UIEdgeInsets;</span><br></pre></td></tr></table></figure>\n<p><strong>简单点说就是对视图的偏移</strong></p>\n<h2 id=\"看黑板-使用说明\"><a href=\"#看黑板-使用说明\" class=\"headerlink\" title=\"看黑板,使用说明\"></a>看黑板,使用说明</h2><ol>\n<li><p>定义一个<code>UIButton</code>,对它的子视图对它进行布局</p>\n</li>\n<li><p>按钮<code>titleLabel</code>的<code>titleEdgeInsets</code></p>\n</li>\n<li><p>按钮<code>imageView</code>的<code>imageEdgeInsets</code></p>\n</li>\n</ol>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[btn setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn.imageView.frame.size.width, 0, 0)];</span><br><span class=\"line\">[btn setImageEdgeInsets:UIEdgeInsetsMake(0, 0, 0, -btn.titleLabel.intrinsicContentSize.width)];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>按钮图片文字居中</strong><br><img src=\"/2018/05/13/iOS熟悉UIEdgeInsetsMake使用/按钮图片文字居中.png\" alt=\"按钮图片文字居中\"></p>\n</blockquote>\n<h3 id=\"imageView在左，titleLabel在右-UIButton系统默认\"><a href=\"#imageView在左，titleLabel在右-UIButton系统默认\" class=\"headerlink\" title=\"imageView在左，titleLabel在右 UIButton系统默认\"></a><code>imageView</code>在左，<code>titleLabel</code>在右 <code>UIButton</code>系统默认</h3><h3 id=\"imageView在上，titleLabel在下\"><a href=\"#imageView在上，titleLabel在下\" class=\"headerlink\" title=\"imageView在上，titleLabel在下\"></a><code>imageView</code>在上，<code>titleLabel</code>在下</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[btn setTitleEdgeInsets:UIEdgeInsetsMake(btn.titleLabel.intrinsicContentSize.height + 10, -btn.imageView.frame.size.width, 0, 0)];</span><br><span class=\"line\">[btn setImageEdgeInsets:UIEdgeInsetsMake(0, 0, btn.imageView.frame.size.height + 10, -btn.titleLabel.intrinsicContentSize.width)];</span><br><span class=\"line\">考虑间隙对图片和文字加了10的偏移量</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>按钮图片在上文字在下</strong><br><img src=\"/2018/05/13/iOS熟悉UIEdgeInsetsMake使用/按钮图片在上文字在下.png\" alt=\"按钮图片在上文字在下\"></p>\n</blockquote>\n<h3 id=\"imageView在下，titleLabel在上\"><a href=\"#imageView在下，titleLabel在上\" class=\"headerlink\" title=\"imageView在下，titleLabel在上\"></a><code>imageView</code>在下，<code>titleLabel</code>在上</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[btn setTitleEdgeInsets:UIEdgeInsetsMake(-btn.titleLabel.intrinsicContentSize.height - 10, -btn.imageView.frame.size.width, 0, 0)];</span><br><span class=\"line\">[btn setImageEdgeInsets:UIEdgeInsetsMake(0, 0, -btn.imageView.frame.size.height - 10, -btn.titleLabel.intrinsicContentSize.width)];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>按钮图片在下文字在上</strong><br><img src=\"/2018/05/13/iOS熟悉UIEdgeInsetsMake使用/按钮图片在下文字在上.png\" alt=\"按钮图片在下文字在上\"></p>\n</blockquote>\n<h3 id=\"imageView在右，titleLabel在左\"><a href=\"#imageView在右，titleLabel在左\" class=\"headerlink\" title=\"imageView在右，titleLabel在左\"></a><code>imageView</code>在右，<code>titleLabel</code>在左</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[btn setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn.imageView.frame.size.width, 0, btn.imageView.frame.size.width)];</span><br><span class=\"line\">[btn setImageEdgeInsets:UIEdgeInsetsMake(0, btn.titleLabel.intrinsicContentSize.width, 0, -btn.titleLabel.intrinsicContentSize.width)];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>按钮图片在右文字在左</strong><br><img src=\"/2018/05/13/iOS熟悉UIEdgeInsetsMake使用/按钮图片在右文字在左.png\" alt=\"按钮图片在右文字在左\"></p>\n</blockquote>\n<h3 id=\"imageView靠右，titleLabel靠左\"><a href=\"#imageView靠右，titleLabel靠左\" class=\"headerlink\" title=\"imageView靠右，titleLabel靠左\"></a><code>imageView</code>靠右，<code>titleLabel</code>靠左</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[btn setImageEdgeInsets:UIEdgeInsetsMake(0, btn.frame.size.width - btn.imageView.frame.size.width, 0, -btn.titleLabel.intrinsicContentSize.width)];</span><br><span class=\"line\">[btn setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn.imageView.frame.size.width, 0, btn.frame.size.width - btn.titleLabel.intrinsicContentSize.width)];</span><br></pre></td></tr></table></figure>\n<p><strong><code>intrinsicContentSize</code>是iOS 8时候获取的属性</strong></p>"},{"title":"熟悉UIScrollView的contentSize,contentOffset,contentInset","date":"2018-05-17T09:39:45.000Z","_content":"\n## UIScrollView基础知识\n\n>`UIScrollView`中的`contentSize`,`contentOffset`,`contentInset`的知识点熟悉\n\n### contentSize\n\n>`contentSize`是`UIScrollView`和继承于`UIScrollView`的子控件的属性，`contentSize`是确定`UIScrollView`上`contentView`宽`（contentSize.width）`和高`（conteSize.height）`的属性。\n\n<!--more-->\n\n### contentOffset\n\n>`contentOffset`是`UIScrollView`和继承于`UIScrollView`的子控件的属性，`contentOffset`确定的是`UIScrollView`的顶点（左上角点）值相对于其父类视图的顶点值（即`frame.origin`）的距离\n\n### contentInset \n\n>`contentInset`是`UIScrollView`和继承于`UIScrollView`的子控件的属性，`contentInset`确定的是`contenView`上下左右相对于`UIScrollView`扩展出来的区域大小。`contentInset`是`UIEdgeInsets`类型的，默认值为`UIEdgeInsetsZero`。\n\n## 布局图\n\n![contentSize](熟悉UIScrollView的contentSize-contentOffset-contentInset/UIScrollView偏移图.png)\n\n## 理解\n>`scrollView.contentInset`默认情况下其初始值都为0；当设置了初始值时（不为零），它相当于给`scrollView`的范围进行了扩大，并加了一堵墙，如果把`scrollView`中的图片理解为一个背景，将`scrollView`理解为一个镜头，通过改变`scrollView.contentOffset`的值就可以改变镜头的初始化位置，但是当你设置了`scrollView.contentInset` 后如果其改变的位置超过了你加的范围它的镜头最多移到你加范围的最大位置\n\n## 参考文档\n[熟悉UIScrollView的contentSize,contentOffset,contentInset](https://www.cnblogs.com/Jenaral/p/5540422.html)","source":"_posts/熟悉UIScrollView的contentSize-contentOffset-contentInset.md","raw":"---\ntitle: '熟悉UIScrollView的contentSize,contentOffset,contentInset'\ndate: 2018-05-17 17:39:45\ntags: \"iOS\"\ncategories: \"iOS基础\"\n---\n\n## UIScrollView基础知识\n\n>`UIScrollView`中的`contentSize`,`contentOffset`,`contentInset`的知识点熟悉\n\n### contentSize\n\n>`contentSize`是`UIScrollView`和继承于`UIScrollView`的子控件的属性，`contentSize`是确定`UIScrollView`上`contentView`宽`（contentSize.width）`和高`（conteSize.height）`的属性。\n\n<!--more-->\n\n### contentOffset\n\n>`contentOffset`是`UIScrollView`和继承于`UIScrollView`的子控件的属性，`contentOffset`确定的是`UIScrollView`的顶点（左上角点）值相对于其父类视图的顶点值（即`frame.origin`）的距离\n\n### contentInset \n\n>`contentInset`是`UIScrollView`和继承于`UIScrollView`的子控件的属性，`contentInset`确定的是`contenView`上下左右相对于`UIScrollView`扩展出来的区域大小。`contentInset`是`UIEdgeInsets`类型的，默认值为`UIEdgeInsetsZero`。\n\n## 布局图\n\n![contentSize](熟悉UIScrollView的contentSize-contentOffset-contentInset/UIScrollView偏移图.png)\n\n## 理解\n>`scrollView.contentInset`默认情况下其初始值都为0；当设置了初始值时（不为零），它相当于给`scrollView`的范围进行了扩大，并加了一堵墙，如果把`scrollView`中的图片理解为一个背景，将`scrollView`理解为一个镜头，通过改变`scrollView.contentOffset`的值就可以改变镜头的初始化位置，但是当你设置了`scrollView.contentInset` 后如果其改变的位置超过了你加的范围它的镜头最多移到你加范围的最大位置\n\n## 参考文档\n[熟悉UIScrollView的contentSize,contentOffset,contentInset](https://www.cnblogs.com/Jenaral/p/5540422.html)","slug":"熟悉UIScrollView的contentSize-contentOffset-contentInset","published":1,"updated":"2018-08-06T05:46:08.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkhy6quv0013duu9skrkpb5p","content":"<h2 id=\"UIScrollView基础知识\"><a href=\"#UIScrollView基础知识\" class=\"headerlink\" title=\"UIScrollView基础知识\"></a>UIScrollView基础知识</h2><blockquote>\n<p><code>UIScrollView</code>中的<code>contentSize</code>,<code>contentOffset</code>,<code>contentInset</code>的知识点熟悉</p>\n</blockquote>\n<h3 id=\"contentSize\"><a href=\"#contentSize\" class=\"headerlink\" title=\"contentSize\"></a>contentSize</h3><blockquote>\n<p><code>contentSize</code>是<code>UIScrollView</code>和继承于<code>UIScrollView</code>的子控件的属性，<code>contentSize</code>是确定<code>UIScrollView</code>上<code>contentView</code>宽<code>（contentSize.width）</code>和高<code>（conteSize.height）</code>的属性。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"contentOffset\"><a href=\"#contentOffset\" class=\"headerlink\" title=\"contentOffset\"></a>contentOffset</h3><blockquote>\n<p><code>contentOffset</code>是<code>UIScrollView</code>和继承于<code>UIScrollView</code>的子控件的属性，<code>contentOffset</code>确定的是<code>UIScrollView</code>的顶点（左上角点）值相对于其父类视图的顶点值（即<code>frame.origin</code>）的距离</p>\n</blockquote>\n<h3 id=\"contentInset\"><a href=\"#contentInset\" class=\"headerlink\" title=\"contentInset\"></a>contentInset</h3><blockquote>\n<p><code>contentInset</code>是<code>UIScrollView</code>和继承于<code>UIScrollView</code>的子控件的属性，<code>contentInset</code>确定的是<code>contenView</code>上下左右相对于<code>UIScrollView</code>扩展出来的区域大小。<code>contentInset</code>是<code>UIEdgeInsets</code>类型的，默认值为<code>UIEdgeInsetsZero</code>。</p>\n</blockquote>\n<h2 id=\"布局图\"><a href=\"#布局图\" class=\"headerlink\" title=\"布局图\"></a>布局图</h2><p><img src=\"/2018/05/17/熟悉UIScrollView的contentSize-contentOffset-contentInset/UIScrollView偏移图.png\" alt=\"contentSize\"></p>\n<h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><blockquote>\n<p><code>scrollView.contentInset</code>默认情况下其初始值都为0；当设置了初始值时（不为零），它相当于给<code>scrollView</code>的范围进行了扩大，并加了一堵墙，如果把<code>scrollView</code>中的图片理解为一个背景，将<code>scrollView</code>理解为一个镜头，通过改变<code>scrollView.contentOffset</code>的值就可以改变镜头的初始化位置，但是当你设置了<code>scrollView.contentInset</code> 后如果其改变的位置超过了你加的范围它的镜头最多移到你加范围的最大位置</p>\n</blockquote>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://www.cnblogs.com/Jenaral/p/5540422.html\" target=\"_blank\" rel=\"noopener\">熟悉UIScrollView的contentSize,contentOffset,contentInset</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"UIScrollView基础知识\"><a href=\"#UIScrollView基础知识\" class=\"headerlink\" title=\"UIScrollView基础知识\"></a>UIScrollView基础知识</h2><blockquote>\n<p><code>UIScrollView</code>中的<code>contentSize</code>,<code>contentOffset</code>,<code>contentInset</code>的知识点熟悉</p>\n</blockquote>\n<h3 id=\"contentSize\"><a href=\"#contentSize\" class=\"headerlink\" title=\"contentSize\"></a>contentSize</h3><blockquote>\n<p><code>contentSize</code>是<code>UIScrollView</code>和继承于<code>UIScrollView</code>的子控件的属性，<code>contentSize</code>是确定<code>UIScrollView</code>上<code>contentView</code>宽<code>（contentSize.width）</code>和高<code>（conteSize.height）</code>的属性。</p>\n</blockquote>","more":"<h3 id=\"contentOffset\"><a href=\"#contentOffset\" class=\"headerlink\" title=\"contentOffset\"></a>contentOffset</h3><blockquote>\n<p><code>contentOffset</code>是<code>UIScrollView</code>和继承于<code>UIScrollView</code>的子控件的属性，<code>contentOffset</code>确定的是<code>UIScrollView</code>的顶点（左上角点）值相对于其父类视图的顶点值（即<code>frame.origin</code>）的距离</p>\n</blockquote>\n<h3 id=\"contentInset\"><a href=\"#contentInset\" class=\"headerlink\" title=\"contentInset\"></a>contentInset</h3><blockquote>\n<p><code>contentInset</code>是<code>UIScrollView</code>和继承于<code>UIScrollView</code>的子控件的属性，<code>contentInset</code>确定的是<code>contenView</code>上下左右相对于<code>UIScrollView</code>扩展出来的区域大小。<code>contentInset</code>是<code>UIEdgeInsets</code>类型的，默认值为<code>UIEdgeInsetsZero</code>。</p>\n</blockquote>\n<h2 id=\"布局图\"><a href=\"#布局图\" class=\"headerlink\" title=\"布局图\"></a>布局图</h2><p><img src=\"/2018/05/17/熟悉UIScrollView的contentSize-contentOffset-contentInset/UIScrollView偏移图.png\" alt=\"contentSize\"></p>\n<h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><blockquote>\n<p><code>scrollView.contentInset</code>默认情况下其初始值都为0；当设置了初始值时（不为零），它相当于给<code>scrollView</code>的范围进行了扩大，并加了一堵墙，如果把<code>scrollView</code>中的图片理解为一个背景，将<code>scrollView</code>理解为一个镜头，通过改变<code>scrollView.contentOffset</code>的值就可以改变镜头的初始化位置，但是当你设置了<code>scrollView.contentInset</code> 后如果其改变的位置超过了你加的范围它的镜头最多移到你加范围的最大位置</p>\n</blockquote>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://www.cnblogs.com/Jenaral/p/5540422.html\" target=\"_blank\" rel=\"noopener\">熟悉UIScrollView的contentSize,contentOffset,contentInset</a></p>"},{"title":"ios之界面之间的数据正逆向传递方法","date":"2018-06-08T09:02:22.000Z","_content":"\n## 1. 初始化传值\n\n> 自定义`View`初始化方法.h文件\n\n```\n#import <UIKit/UIKit.h>\n\n@interface XMContentView : UIView\n\n- (instancetype)initTitles:(NSArray <NSString *>*)titles;\n\n@end\n```\n\n> 自定义`View`初始化方法.m文件\n\n```\n#import \"XMContentView.h\"\n\n@interface XMContentView ()\n\n// 数据保存\n@property (nonatomic, strong) NSArray *titles;\n\n@end\n\n@implementation XMContentView\n\n- (instancetype)initTitles:(NSArray<NSString *> *)titles {\n    if (self = [super init]) {\n        // 进行页面数据传递\n    }\n    return self;\n}\n\n@end\n```\n\n<!--more-->\n\n> 初始化传值使用\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    _contentView = [[XMContentView alloc] initTitles:@[@\"初始化传值1\",@\"初始化传值2\"]];\n    [self.view addSubview:_contentView];\n\n}\n```\n\n## 2. 属性传值\n\n> 自定义`View`添加属性.h文件\n\n```\n#import <UIKit/UIKit.h>\n\n@interface XMContentView : UIView\n\n@property (nonatomic, copy) NSString *titles;\n\n@end\n```\n\n> 自定义`View`添加属性.m文件\n\n```\n#import \"XMContentView.h\"\n\n@interface XMContentView ()\n\n\n@end\n\n@implementation XMContentView\n\n- (void)setTitles:(NSString *)titles {\n    _titles = titles;\n    // 进行页面数据传递\n}\n\n@end\n```\n\n> 属性传值使用\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    _contentView = [[XMContentView alloc] initWithFrame:CGRectZero];\n    _contentView.titles = @\"属性传值\";\n    [self.view addSubview:_contentView];\n\n}\n```\n\n## 3. 方法传值\n\n> 自定义`View`添加方法.h文件\n\n```\n#import <UIKit/UIKit.h>\n\n@interface XMContentView : UIView\n\n- (void)reloadContentViewTitles:(NSArray <NSString *>*)titles;\n\n+ (void)reloadContentViewNames:(NSString *)names;\n\n@end\n```\n\n> 自定义`View`添加方法.m文件\n\n```\n\n#import \"XMContentView.h\"\n\n@interface XMContentView ()\n\n@end\n\n@implementation XMContentView\n\n- (void)reloadContentViewTitles:(NSArray<NSString *> *)titles {\n    // 进行页面传递数据配置\n}\n\n+ (void)reloadContentViewNames:(NSString *)names {\n    // 进行页面传递数据配置\n}\n\n@end\n```\n\n> 方法传值使用\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    _contentView = [[XMContentView alloc] initWithFrame:CGRectZero];\n    [_contentView reloadContentViewTitles:@[@\"方法传值1\",@\"方法传值2\"]];\n    [XMContentView reloadContentViewNames:@\"方法传值\"];\n    [self.view addSubview:_contentView];\n\n}\n```\n\n## 4. Delegate(协议)传值\n\n> 自定义`View`添加协议.h文件\n\n```\n#import <UIKit/UIKit.h>\n\n@protocol XMContentViewDelegate <NSObject>\n// delegate 必须实现的方法\n@required\n- (void)sendInformation:(NSInteger)tag;\n// delegate 选择实现的方法\n@optional\n\n@end\n\n@interface XMContentView : UIView\n\n@property (nonatomic, weak) id<XMContentViewDelegate> delegate;\n\n@end\n```\n\n> 自定义`View`添加协议.m文件\n\n```\n#import \"XMContentView.h\"\n\n@interface XMContentView ()\n\n@end\n\n@implementation XMContentView\n\n- (instancetype)initWithFrame:(CGRect)frame {\n    if (self = [super initWithFrame:frame]) {\n    \t// 一般用于反向传值,按钮或者手势处理\n        if (_delegate && [_delegate respondsToSelector:@selector(sendInformation:)]) {\n            [_delegate sendInformation:0];\n        }\n    }\n    return self;\n}\n\n@end\n```\n\n> 协议传值使用\n\n```\n// 引用协议\n@interface ViewController ()<XMContentViewDelegate>\n\n@end\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    _contentView = [[XMContentView alloc] initWithFrame:CGRectZero];\n    // 遵守协议\n    _contentView.delegate = self;\n    [self.view addSubview:_contentView];\n \n}\n\n// 实现协议传值\n- (void)sendInformation:(NSInteger)tag {\n    \n}\n\n```\n\n## 5. Block传值\n\n> 自定义`View`定义Block.h文件\n\n```\n#import <UIKit/UIKit.h>\n\ntypedef void(^contentBlock)(NSString *titles);\n\n@interface XMContentView : UIView\n\n@property (nonatomic, copy) contentBlock contentblk;\n\n@property (nonatomic, copy) dispatch_block_t contentdisblk;\n\n// block第一个参数为返回值,第二个参数为block名字,第三个参数为携带的参数\n@property (nonatomic, copy) void (^contentBlock)(void);\n\n- (void)reloadBlock:(void (^)(NSString *titles))animations;\n\n// 方法和属性设置block\n//  returnType(^name)(arguments);\n\n// - void)reloadBlock:(returnType(^name)(arguments))animations;\n\n\n@end\n```\n\n> 自定义`View`定义Block.m文件\n\n```\n#import \"XMContentView.h\"\n\n@interface XMContentView ()\n\n@end\n\n@implementation XMContentView\n\n- (instancetype)initWithFrame:(CGRect)frame {\n    if (self = [super initWithFrame:frame]) {\n      \n    }\n    return self;\n}\n\n- (void)reloadBlock:(void (^)(NSString *titles))animations {\n   // 进行页面传递数据配置\n}\n\n@end\n```\n\n> Block传值使用\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // block中处理weak属性,防止循环引用\n    __weak typeof(self) weakSelf = self;\n\n    _contentView = [[XMContentView alloc] initWithFrame:CGRectZero];\n    [_contentView reloadBlock:^(NSString *titles) {\n        \n    }];\n    _contentView.contentBlock = ^{\n        \n    };\n    [self.view addSubview:_contentView];\n\n}\n```\n\n## 6. 单例传值\n\n> 自定义单例.h文件\n\n```\n#import @interface nameObject : NSObject\n/**\n 单例类方法\n @return 返回一个共享对象\n */\n+ (instancetype)sharedInstance;\n\n// 姓名\n@property (nonatomic, copy) NSString* name;\n\n@end\n```\n\n> 自定义单例.m文件\n\n```\n#import \"nameObject.h\"\n\n@implementation nameObject\n\nstatic nameObject* kNameObject = nil;\n\n/** 单例类方法 */\n// GCD\n+ (instancetype)sharedInstance {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n    \t<!-- if (kNameObject == nil) { -->\n    \t    kNameObject = [[super allocWithZone:NULL] init];\n    \t<!-- } -->\n   });\n    return kNameObject;\n}\n\n\n// 同步锁\n/*\n+ (instancetype)sharedInstance {\n\tvolatile static LaunchIntroductionView *singleInstance = nil;\n\t    if (singleInstance == nil) {\n\t        @synchronized(self) {\n\t            if (singleInstance == nil) {\n\t                singleInstance = [[LaunchIntroductionView alloc] init];\n\t            }\n\t        }\n\t    }\n\t    return singleInstance;\n}\n*/\n\n+ (id)allocWithZone:(struct _NSZone *)zone {\n\tstatic dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        kNameObject = [super allocWithZone:zone];\n    });\n    return kNameObject;\n\t<!-- return [self sharedInstance]; -->\n}\n\n- (id)copy {\n\t<!-- return self; -->\n\treturn kNameObject;\n}\n\n- (id)muntableCope {\n\t<!-- return self; -->\n\treturn kNameObject;\n}\n\n@end\n\n```\n\n> 单例传值使用\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n\t// [nameObject sharedInstance].name    \n\n}\n```\n\n## 7. 通知传值\n\n**编写通知命名** \n```\nUIKIT_EXTERN NSNotificationName const ZOCFooDidBecomeBarNotification\nNSNotificationName const ZOCFooDidBecomeBarNotification = @\"ZOCFooDidBecomeBarNotification\";\n```\n\n> 通知.h文件,设置通知名字`extern NSString * const aNotification;`\n\n```\n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(requestName:) name:aNotification object:nil];\n```\n\n> 通知.m文件,设置通知名字`NSString * const aNotification = @\"aNotification\";`\n\n**实现`requestName`方法**\n\n`dealloc`移除通知\n\n\n## NSUserDefaults数据保存\n\n> 统一方法保存\n```\n+ (void)saveValueString:(NSString *)valueString withKey:(NSString *)keyString;\n\n+ (NSString *)getValueStringWithKey:(NSString *)keyString;\n\n+ (void)cleanValueStringWithKey:(NSString *)keyString;\n```\n\n> 统一方法实现\n\n```\n+ (void)saveValueString:(NSString *)valueString withKey:(NSString *)keyString {\n    NSUserDefaults *uidDefaults = [NSUserDefaults standardUserDefaults];\n    [uidDefaults setObject:valueString forKey:keyString];\n    [uidDefaults synchronize];\n}\n\n+ (NSString *)getValueStringWithKey:(NSString *)keyString {\n    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];\n    NSString *valueString = [userDefaults objectForKey:keyString];\n    return valueString;\n}\n\n+ (void)cleanValueStringWithKey:(NSString *)keyString {\n    NSUserDefaults *UserLoginState = [NSUserDefaults standardUserDefaults];\n    [UserLoginState removeObjectForKey:keyString];\n    [UserLoginState synchronize];\n}\n```\n\n\n\n","source":"_posts/ios之界面之间的数据正逆向传递方法.md","raw":"---\ntitle: ios之界面之间的数据正逆向传递方法\ndate: 2018-06-08 17:02:22\ntags: \"iOS\"\ncategories: \"iOS基础\"\n---\n\n## 1. 初始化传值\n\n> 自定义`View`初始化方法.h文件\n\n```\n#import <UIKit/UIKit.h>\n\n@interface XMContentView : UIView\n\n- (instancetype)initTitles:(NSArray <NSString *>*)titles;\n\n@end\n```\n\n> 自定义`View`初始化方法.m文件\n\n```\n#import \"XMContentView.h\"\n\n@interface XMContentView ()\n\n// 数据保存\n@property (nonatomic, strong) NSArray *titles;\n\n@end\n\n@implementation XMContentView\n\n- (instancetype)initTitles:(NSArray<NSString *> *)titles {\n    if (self = [super init]) {\n        // 进行页面数据传递\n    }\n    return self;\n}\n\n@end\n```\n\n<!--more-->\n\n> 初始化传值使用\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    _contentView = [[XMContentView alloc] initTitles:@[@\"初始化传值1\",@\"初始化传值2\"]];\n    [self.view addSubview:_contentView];\n\n}\n```\n\n## 2. 属性传值\n\n> 自定义`View`添加属性.h文件\n\n```\n#import <UIKit/UIKit.h>\n\n@interface XMContentView : UIView\n\n@property (nonatomic, copy) NSString *titles;\n\n@end\n```\n\n> 自定义`View`添加属性.m文件\n\n```\n#import \"XMContentView.h\"\n\n@interface XMContentView ()\n\n\n@end\n\n@implementation XMContentView\n\n- (void)setTitles:(NSString *)titles {\n    _titles = titles;\n    // 进行页面数据传递\n}\n\n@end\n```\n\n> 属性传值使用\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    _contentView = [[XMContentView alloc] initWithFrame:CGRectZero];\n    _contentView.titles = @\"属性传值\";\n    [self.view addSubview:_contentView];\n\n}\n```\n\n## 3. 方法传值\n\n> 自定义`View`添加方法.h文件\n\n```\n#import <UIKit/UIKit.h>\n\n@interface XMContentView : UIView\n\n- (void)reloadContentViewTitles:(NSArray <NSString *>*)titles;\n\n+ (void)reloadContentViewNames:(NSString *)names;\n\n@end\n```\n\n> 自定义`View`添加方法.m文件\n\n```\n\n#import \"XMContentView.h\"\n\n@interface XMContentView ()\n\n@end\n\n@implementation XMContentView\n\n- (void)reloadContentViewTitles:(NSArray<NSString *> *)titles {\n    // 进行页面传递数据配置\n}\n\n+ (void)reloadContentViewNames:(NSString *)names {\n    // 进行页面传递数据配置\n}\n\n@end\n```\n\n> 方法传值使用\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    _contentView = [[XMContentView alloc] initWithFrame:CGRectZero];\n    [_contentView reloadContentViewTitles:@[@\"方法传值1\",@\"方法传值2\"]];\n    [XMContentView reloadContentViewNames:@\"方法传值\"];\n    [self.view addSubview:_contentView];\n\n}\n```\n\n## 4. Delegate(协议)传值\n\n> 自定义`View`添加协议.h文件\n\n```\n#import <UIKit/UIKit.h>\n\n@protocol XMContentViewDelegate <NSObject>\n// delegate 必须实现的方法\n@required\n- (void)sendInformation:(NSInteger)tag;\n// delegate 选择实现的方法\n@optional\n\n@end\n\n@interface XMContentView : UIView\n\n@property (nonatomic, weak) id<XMContentViewDelegate> delegate;\n\n@end\n```\n\n> 自定义`View`添加协议.m文件\n\n```\n#import \"XMContentView.h\"\n\n@interface XMContentView ()\n\n@end\n\n@implementation XMContentView\n\n- (instancetype)initWithFrame:(CGRect)frame {\n    if (self = [super initWithFrame:frame]) {\n    \t// 一般用于反向传值,按钮或者手势处理\n        if (_delegate && [_delegate respondsToSelector:@selector(sendInformation:)]) {\n            [_delegate sendInformation:0];\n        }\n    }\n    return self;\n}\n\n@end\n```\n\n> 协议传值使用\n\n```\n// 引用协议\n@interface ViewController ()<XMContentViewDelegate>\n\n@end\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    _contentView = [[XMContentView alloc] initWithFrame:CGRectZero];\n    // 遵守协议\n    _contentView.delegate = self;\n    [self.view addSubview:_contentView];\n \n}\n\n// 实现协议传值\n- (void)sendInformation:(NSInteger)tag {\n    \n}\n\n```\n\n## 5. Block传值\n\n> 自定义`View`定义Block.h文件\n\n```\n#import <UIKit/UIKit.h>\n\ntypedef void(^contentBlock)(NSString *titles);\n\n@interface XMContentView : UIView\n\n@property (nonatomic, copy) contentBlock contentblk;\n\n@property (nonatomic, copy) dispatch_block_t contentdisblk;\n\n// block第一个参数为返回值,第二个参数为block名字,第三个参数为携带的参数\n@property (nonatomic, copy) void (^contentBlock)(void);\n\n- (void)reloadBlock:(void (^)(NSString *titles))animations;\n\n// 方法和属性设置block\n//  returnType(^name)(arguments);\n\n// - void)reloadBlock:(returnType(^name)(arguments))animations;\n\n\n@end\n```\n\n> 自定义`View`定义Block.m文件\n\n```\n#import \"XMContentView.h\"\n\n@interface XMContentView ()\n\n@end\n\n@implementation XMContentView\n\n- (instancetype)initWithFrame:(CGRect)frame {\n    if (self = [super initWithFrame:frame]) {\n      \n    }\n    return self;\n}\n\n- (void)reloadBlock:(void (^)(NSString *titles))animations {\n   // 进行页面传递数据配置\n}\n\n@end\n```\n\n> Block传值使用\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // block中处理weak属性,防止循环引用\n    __weak typeof(self) weakSelf = self;\n\n    _contentView = [[XMContentView alloc] initWithFrame:CGRectZero];\n    [_contentView reloadBlock:^(NSString *titles) {\n        \n    }];\n    _contentView.contentBlock = ^{\n        \n    };\n    [self.view addSubview:_contentView];\n\n}\n```\n\n## 6. 单例传值\n\n> 自定义单例.h文件\n\n```\n#import @interface nameObject : NSObject\n/**\n 单例类方法\n @return 返回一个共享对象\n */\n+ (instancetype)sharedInstance;\n\n// 姓名\n@property (nonatomic, copy) NSString* name;\n\n@end\n```\n\n> 自定义单例.m文件\n\n```\n#import \"nameObject.h\"\n\n@implementation nameObject\n\nstatic nameObject* kNameObject = nil;\n\n/** 单例类方法 */\n// GCD\n+ (instancetype)sharedInstance {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n    \t<!-- if (kNameObject == nil) { -->\n    \t    kNameObject = [[super allocWithZone:NULL] init];\n    \t<!-- } -->\n   });\n    return kNameObject;\n}\n\n\n// 同步锁\n/*\n+ (instancetype)sharedInstance {\n\tvolatile static LaunchIntroductionView *singleInstance = nil;\n\t    if (singleInstance == nil) {\n\t        @synchronized(self) {\n\t            if (singleInstance == nil) {\n\t                singleInstance = [[LaunchIntroductionView alloc] init];\n\t            }\n\t        }\n\t    }\n\t    return singleInstance;\n}\n*/\n\n+ (id)allocWithZone:(struct _NSZone *)zone {\n\tstatic dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        kNameObject = [super allocWithZone:zone];\n    });\n    return kNameObject;\n\t<!-- return [self sharedInstance]; -->\n}\n\n- (id)copy {\n\t<!-- return self; -->\n\treturn kNameObject;\n}\n\n- (id)muntableCope {\n\t<!-- return self; -->\n\treturn kNameObject;\n}\n\n@end\n\n```\n\n> 单例传值使用\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n\t// [nameObject sharedInstance].name    \n\n}\n```\n\n## 7. 通知传值\n\n**编写通知命名** \n```\nUIKIT_EXTERN NSNotificationName const ZOCFooDidBecomeBarNotification\nNSNotificationName const ZOCFooDidBecomeBarNotification = @\"ZOCFooDidBecomeBarNotification\";\n```\n\n> 通知.h文件,设置通知名字`extern NSString * const aNotification;`\n\n```\n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(requestName:) name:aNotification object:nil];\n```\n\n> 通知.m文件,设置通知名字`NSString * const aNotification = @\"aNotification\";`\n\n**实现`requestName`方法**\n\n`dealloc`移除通知\n\n\n## NSUserDefaults数据保存\n\n> 统一方法保存\n```\n+ (void)saveValueString:(NSString *)valueString withKey:(NSString *)keyString;\n\n+ (NSString *)getValueStringWithKey:(NSString *)keyString;\n\n+ (void)cleanValueStringWithKey:(NSString *)keyString;\n```\n\n> 统一方法实现\n\n```\n+ (void)saveValueString:(NSString *)valueString withKey:(NSString *)keyString {\n    NSUserDefaults *uidDefaults = [NSUserDefaults standardUserDefaults];\n    [uidDefaults setObject:valueString forKey:keyString];\n    [uidDefaults synchronize];\n}\n\n+ (NSString *)getValueStringWithKey:(NSString *)keyString {\n    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];\n    NSString *valueString = [userDefaults objectForKey:keyString];\n    return valueString;\n}\n\n+ (void)cleanValueStringWithKey:(NSString *)keyString {\n    NSUserDefaults *UserLoginState = [NSUserDefaults standardUserDefaults];\n    [UserLoginState removeObjectForKey:keyString];\n    [UserLoginState synchronize];\n}\n```\n\n\n\n","slug":"ios之界面之间的数据正逆向传递方法","published":1,"updated":"2018-08-06T05:46:08.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkhy6qv1001oduu9qiykumgg","content":"<h2 id=\"1-初始化传值\"><a href=\"#1-初始化传值\" class=\"headerlink\" title=\"1. 初始化传值\"></a>1. 初始化传值</h2><blockquote>\n<p>自定义<code>View</code>初始化方法.h文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView : UIView</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initTitles:(NSArray &lt;NSString *&gt;*)titles;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>自定义<code>View</code>初始化方法.m文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;XMContentView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView ()</span><br><span class=\"line\"></span><br><span class=\"line\">// 数据保存</span><br><span class=\"line\">@property (nonatomic, strong) NSArray *titles;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation XMContentView</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initTitles:(NSArray&lt;NSString *&gt; *)titles &#123;</span><br><span class=\"line\">    if (self = [super init]) &#123;</span><br><span class=\"line\">        // 进行页面数据传递</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<blockquote>\n<p>初始化传值使用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    _contentView = [[XMContentView alloc] initTitles:@[@&quot;初始化传值1&quot;,@&quot;初始化传值2&quot;]];</span><br><span class=\"line\">    [self.view addSubview:_contentView];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-属性传值\"><a href=\"#2-属性传值\" class=\"headerlink\" title=\"2. 属性传值\"></a>2. 属性传值</h2><blockquote>\n<p>自定义<code>View</code>添加属性.h文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView : UIView</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *titles;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>自定义<code>View</code>添加属性.m文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;XMContentView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView ()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation XMContentView</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setTitles:(NSString *)titles &#123;</span><br><span class=\"line\">    _titles = titles;</span><br><span class=\"line\">    // 进行页面数据传递</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>属性传值使用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    _contentView = [[XMContentView alloc] initWithFrame:CGRectZero];</span><br><span class=\"line\">    _contentView.titles = @&quot;属性传值&quot;;</span><br><span class=\"line\">    [self.view addSubview:_contentView];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-方法传值\"><a href=\"#3-方法传值\" class=\"headerlink\" title=\"3. 方法传值\"></a>3. 方法传值</h2><blockquote>\n<p>自定义<code>View</code>添加方法.h文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView : UIView</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)reloadContentViewTitles:(NSArray &lt;NSString *&gt;*)titles;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)reloadContentViewNames:(NSString *)names;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>自定义<code>View</code>添加方法.m文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#import &quot;XMContentView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView ()</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation XMContentView</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)reloadContentViewTitles:(NSArray&lt;NSString *&gt; *)titles &#123;</span><br><span class=\"line\">    // 进行页面传递数据配置</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)reloadContentViewNames:(NSString *)names &#123;</span><br><span class=\"line\">    // 进行页面传递数据配置</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>方法传值使用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    _contentView = [[XMContentView alloc] initWithFrame:CGRectZero];</span><br><span class=\"line\">    [_contentView reloadContentViewTitles:@[@&quot;方法传值1&quot;,@&quot;方法传值2&quot;]];</span><br><span class=\"line\">    [XMContentView reloadContentViewNames:@&quot;方法传值&quot;];</span><br><span class=\"line\">    [self.view addSubview:_contentView];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-Delegate-协议-传值\"><a href=\"#4-Delegate-协议-传值\" class=\"headerlink\" title=\"4. Delegate(协议)传值\"></a>4. Delegate(协议)传值</h2><blockquote>\n<p>自定义<code>View</code>添加协议.h文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@protocol XMContentViewDelegate &lt;NSObject&gt;</span><br><span class=\"line\">// delegate 必须实现的方法</span><br><span class=\"line\">@required</span><br><span class=\"line\">- (void)sendInformation:(NSInteger)tag;</span><br><span class=\"line\">// delegate 选择实现的方法</span><br><span class=\"line\">@optional</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView : UIView</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, weak) id&lt;XMContentViewDelegate&gt; delegate;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>自定义<code>View</code>添加协议.m文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;XMContentView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView ()</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation XMContentView</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithFrame:(CGRect)frame &#123;</span><br><span class=\"line\">    if (self = [super initWithFrame:frame]) &#123;</span><br><span class=\"line\">    \t// 一般用于反向传值,按钮或者手势处理</span><br><span class=\"line\">        if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(sendInformation:)]) &#123;</span><br><span class=\"line\">            [_delegate sendInformation:0];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>协议传值使用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 引用协议</span><br><span class=\"line\">@interface ViewController ()&lt;XMContentViewDelegate&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    _contentView = [[XMContentView alloc] initWithFrame:CGRectZero];</span><br><span class=\"line\">    // 遵守协议</span><br><span class=\"line\">    _contentView.delegate = self;</span><br><span class=\"line\">    [self.view addSubview:_contentView];</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 实现协议传值</span><br><span class=\"line\">- (void)sendInformation:(NSInteger)tag &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-Block传值\"><a href=\"#5-Block传值\" class=\"headerlink\" title=\"5. Block传值\"></a>5. Block传值</h2><blockquote>\n<p>自定义<code>View</code>定义Block.h文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef void(^contentBlock)(NSString *titles);</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView : UIView</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) contentBlock contentblk;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) dispatch_block_t contentdisblk;</span><br><span class=\"line\"></span><br><span class=\"line\">// block第一个参数为返回值,第二个参数为block名字,第三个参数为携带的参数</span><br><span class=\"line\">@property (nonatomic, copy) void (^contentBlock)(void);</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)reloadBlock:(void (^)(NSString *titles))animations;</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法和属性设置block</span><br><span class=\"line\">//  returnType(^name)(arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">// - void)reloadBlock:(returnType(^name)(arguments))animations;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>自定义<code>View</code>定义Block.m文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;XMContentView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView ()</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation XMContentView</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithFrame:(CGRect)frame &#123;</span><br><span class=\"line\">    if (self = [super initWithFrame:frame]) &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)reloadBlock:(void (^)(NSString *titles))animations &#123;</span><br><span class=\"line\">   // 进行页面传递数据配置</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Block传值使用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    // block中处理weak属性,防止循环引用</span><br><span class=\"line\">    __weak typeof(self) weakSelf = self;</span><br><span class=\"line\"></span><br><span class=\"line\">    _contentView = [[XMContentView alloc] initWithFrame:CGRectZero];</span><br><span class=\"line\">    [_contentView reloadBlock:^(NSString *titles) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    _contentView.contentBlock = ^&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    [self.view addSubview:_contentView];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-单例传值\"><a href=\"#6-单例传值\" class=\"headerlink\" title=\"6. 单例传值\"></a>6. 单例传值</h2><blockquote>\n<p>自定义单例.h文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import @interface nameObject : NSObject</span><br><span class=\"line\">/**</span><br><span class=\"line\"> 单例类方法</span><br><span class=\"line\"> @return 返回一个共享对象</span><br><span class=\"line\"> */</span><br><span class=\"line\">+ (instancetype)sharedInstance;</span><br><span class=\"line\"></span><br><span class=\"line\">// 姓名</span><br><span class=\"line\">@property (nonatomic, copy) NSString* name;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>自定义单例.m文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;nameObject.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation nameObject</span><br><span class=\"line\"></span><br><span class=\"line\">static nameObject* kNameObject = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">/** 单例类方法 */</span><br><span class=\"line\">// GCD</span><br><span class=\"line\">+ (instancetype)sharedInstance &#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">    \t&lt;!-- if (kNameObject == nil) &#123; --&gt;</span><br><span class=\"line\">    \t    kNameObject = [[super allocWithZone:NULL] init];</span><br><span class=\"line\">    \t&lt;!-- &#125; --&gt;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">    return kNameObject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 同步锁</span><br><span class=\"line\">/*</span><br><span class=\"line\">+ (instancetype)sharedInstance &#123;</span><br><span class=\"line\">\tvolatile static LaunchIntroductionView *singleInstance = nil;</span><br><span class=\"line\">\t    if (singleInstance == nil) &#123;</span><br><span class=\"line\">\t        @synchronized(self) &#123;</span><br><span class=\"line\">\t            if (singleInstance == nil) &#123;</span><br><span class=\"line\">\t                singleInstance = [[LaunchIntroductionView alloc] init];</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    return singleInstance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">+ (id)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class=\"line\">\tstatic dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        kNameObject = [super allocWithZone:zone];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return kNameObject;</span><br><span class=\"line\">\t&lt;!-- return [self sharedInstance]; --&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (id)copy &#123;</span><br><span class=\"line\">\t&lt;!-- return self; --&gt;</span><br><span class=\"line\">\treturn kNameObject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (id)muntableCope &#123;</span><br><span class=\"line\">\t&lt;!-- return self; --&gt;</span><br><span class=\"line\">\treturn kNameObject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>单例传值使用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">\t// [nameObject sharedInstance].name    </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-通知传值\"><a href=\"#7-通知传值\" class=\"headerlink\" title=\"7. 通知传值\"></a>7. 通知传值</h2><p><strong>编写通知命名</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIKIT_EXTERN NSNotificationName const ZOCFooDidBecomeBarNotification</span><br><span class=\"line\">NSNotificationName const ZOCFooDidBecomeBarNotification = @&quot;ZOCFooDidBecomeBarNotification&quot;;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>通知.h文件,设置通知名字<code>extern NSString * const aNotification;</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(requestName:) name:aNotification object:nil];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>通知.m文件,设置通知名字<code>NSString * const aNotification = @&quot;aNotification&quot;;</code></p>\n</blockquote>\n<p><strong>实现<code>requestName</code>方法</strong></p>\n<p><code>dealloc</code>移除通知</p>\n<h2 id=\"NSUserDefaults数据保存\"><a href=\"#NSUserDefaults数据保存\" class=\"headerlink\" title=\"NSUserDefaults数据保存\"></a>NSUserDefaults数据保存</h2><blockquote>\n<p>统一方法保存<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)saveValueString:(NSString *)valueString withKey:(NSString *)keyString;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getValueStringWithKey:(NSString *)keyString;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)cleanValueStringWithKey:(NSString *)keyString;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>统一方法实现</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)saveValueString:(NSString *)valueString withKey:(NSString *)keyString &#123;</span><br><span class=\"line\">    NSUserDefaults *uidDefaults = [NSUserDefaults standardUserDefaults];</span><br><span class=\"line\">    [uidDefaults setObject:valueString forKey:keyString];</span><br><span class=\"line\">    [uidDefaults synchronize];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getValueStringWithKey:(NSString *)keyString &#123;</span><br><span class=\"line\">    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];</span><br><span class=\"line\">    NSString *valueString = [userDefaults objectForKey:keyString];</span><br><span class=\"line\">    return valueString;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)cleanValueStringWithKey:(NSString *)keyString &#123;</span><br><span class=\"line\">    NSUserDefaults *UserLoginState = [NSUserDefaults standardUserDefaults];</span><br><span class=\"line\">    [UserLoginState removeObjectForKey:keyString];</span><br><span class=\"line\">    [UserLoginState synchronize];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-初始化传值\"><a href=\"#1-初始化传值\" class=\"headerlink\" title=\"1. 初始化传值\"></a>1. 初始化传值</h2><blockquote>\n<p>自定义<code>View</code>初始化方法.h文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView : UIView</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initTitles:(NSArray &lt;NSString *&gt;*)titles;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>自定义<code>View</code>初始化方法.m文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;XMContentView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView ()</span><br><span class=\"line\"></span><br><span class=\"line\">// 数据保存</span><br><span class=\"line\">@property (nonatomic, strong) NSArray *titles;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation XMContentView</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initTitles:(NSArray&lt;NSString *&gt; *)titles &#123;</span><br><span class=\"line\">    if (self = [super init]) &#123;</span><br><span class=\"line\">        // 进行页面数据传递</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>","more":"<blockquote>\n<p>初始化传值使用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    _contentView = [[XMContentView alloc] initTitles:@[@&quot;初始化传值1&quot;,@&quot;初始化传值2&quot;]];</span><br><span class=\"line\">    [self.view addSubview:_contentView];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-属性传值\"><a href=\"#2-属性传值\" class=\"headerlink\" title=\"2. 属性传值\"></a>2. 属性传值</h2><blockquote>\n<p>自定义<code>View</code>添加属性.h文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView : UIView</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *titles;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>自定义<code>View</code>添加属性.m文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;XMContentView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView ()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation XMContentView</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setTitles:(NSString *)titles &#123;</span><br><span class=\"line\">    _titles = titles;</span><br><span class=\"line\">    // 进行页面数据传递</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>属性传值使用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    _contentView = [[XMContentView alloc] initWithFrame:CGRectZero];</span><br><span class=\"line\">    _contentView.titles = @&quot;属性传值&quot;;</span><br><span class=\"line\">    [self.view addSubview:_contentView];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-方法传值\"><a href=\"#3-方法传值\" class=\"headerlink\" title=\"3. 方法传值\"></a>3. 方法传值</h2><blockquote>\n<p>自定义<code>View</code>添加方法.h文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView : UIView</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)reloadContentViewTitles:(NSArray &lt;NSString *&gt;*)titles;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)reloadContentViewNames:(NSString *)names;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>自定义<code>View</code>添加方法.m文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#import &quot;XMContentView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView ()</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation XMContentView</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)reloadContentViewTitles:(NSArray&lt;NSString *&gt; *)titles &#123;</span><br><span class=\"line\">    // 进行页面传递数据配置</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)reloadContentViewNames:(NSString *)names &#123;</span><br><span class=\"line\">    // 进行页面传递数据配置</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>方法传值使用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    _contentView = [[XMContentView alloc] initWithFrame:CGRectZero];</span><br><span class=\"line\">    [_contentView reloadContentViewTitles:@[@&quot;方法传值1&quot;,@&quot;方法传值2&quot;]];</span><br><span class=\"line\">    [XMContentView reloadContentViewNames:@&quot;方法传值&quot;];</span><br><span class=\"line\">    [self.view addSubview:_contentView];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-Delegate-协议-传值\"><a href=\"#4-Delegate-协议-传值\" class=\"headerlink\" title=\"4. Delegate(协议)传值\"></a>4. Delegate(协议)传值</h2><blockquote>\n<p>自定义<code>View</code>添加协议.h文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@protocol XMContentViewDelegate &lt;NSObject&gt;</span><br><span class=\"line\">// delegate 必须实现的方法</span><br><span class=\"line\">@required</span><br><span class=\"line\">- (void)sendInformation:(NSInteger)tag;</span><br><span class=\"line\">// delegate 选择实现的方法</span><br><span class=\"line\">@optional</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView : UIView</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, weak) id&lt;XMContentViewDelegate&gt; delegate;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>自定义<code>View</code>添加协议.m文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;XMContentView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView ()</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation XMContentView</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithFrame:(CGRect)frame &#123;</span><br><span class=\"line\">    if (self = [super initWithFrame:frame]) &#123;</span><br><span class=\"line\">    \t// 一般用于反向传值,按钮或者手势处理</span><br><span class=\"line\">        if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(sendInformation:)]) &#123;</span><br><span class=\"line\">            [_delegate sendInformation:0];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>协议传值使用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 引用协议</span><br><span class=\"line\">@interface ViewController ()&lt;XMContentViewDelegate&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    _contentView = [[XMContentView alloc] initWithFrame:CGRectZero];</span><br><span class=\"line\">    // 遵守协议</span><br><span class=\"line\">    _contentView.delegate = self;</span><br><span class=\"line\">    [self.view addSubview:_contentView];</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 实现协议传值</span><br><span class=\"line\">- (void)sendInformation:(NSInteger)tag &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-Block传值\"><a href=\"#5-Block传值\" class=\"headerlink\" title=\"5. Block传值\"></a>5. Block传值</h2><blockquote>\n<p>自定义<code>View</code>定义Block.h文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef void(^contentBlock)(NSString *titles);</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView : UIView</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) contentBlock contentblk;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) dispatch_block_t contentdisblk;</span><br><span class=\"line\"></span><br><span class=\"line\">// block第一个参数为返回值,第二个参数为block名字,第三个参数为携带的参数</span><br><span class=\"line\">@property (nonatomic, copy) void (^contentBlock)(void);</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)reloadBlock:(void (^)(NSString *titles))animations;</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法和属性设置block</span><br><span class=\"line\">//  returnType(^name)(arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">// - void)reloadBlock:(returnType(^name)(arguments))animations;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>自定义<code>View</code>定义Block.m文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;XMContentView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XMContentView ()</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation XMContentView</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithFrame:(CGRect)frame &#123;</span><br><span class=\"line\">    if (self = [super initWithFrame:frame]) &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)reloadBlock:(void (^)(NSString *titles))animations &#123;</span><br><span class=\"line\">   // 进行页面传递数据配置</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Block传值使用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    // block中处理weak属性,防止循环引用</span><br><span class=\"line\">    __weak typeof(self) weakSelf = self;</span><br><span class=\"line\"></span><br><span class=\"line\">    _contentView = [[XMContentView alloc] initWithFrame:CGRectZero];</span><br><span class=\"line\">    [_contentView reloadBlock:^(NSString *titles) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    _contentView.contentBlock = ^&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    [self.view addSubview:_contentView];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-单例传值\"><a href=\"#6-单例传值\" class=\"headerlink\" title=\"6. 单例传值\"></a>6. 单例传值</h2><blockquote>\n<p>自定义单例.h文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import @interface nameObject : NSObject</span><br><span class=\"line\">/**</span><br><span class=\"line\"> 单例类方法</span><br><span class=\"line\"> @return 返回一个共享对象</span><br><span class=\"line\"> */</span><br><span class=\"line\">+ (instancetype)sharedInstance;</span><br><span class=\"line\"></span><br><span class=\"line\">// 姓名</span><br><span class=\"line\">@property (nonatomic, copy) NSString* name;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>自定义单例.m文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;nameObject.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation nameObject</span><br><span class=\"line\"></span><br><span class=\"line\">static nameObject* kNameObject = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">/** 单例类方法 */</span><br><span class=\"line\">// GCD</span><br><span class=\"line\">+ (instancetype)sharedInstance &#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">    \t&lt;!-- if (kNameObject == nil) &#123; --&gt;</span><br><span class=\"line\">    \t    kNameObject = [[super allocWithZone:NULL] init];</span><br><span class=\"line\">    \t&lt;!-- &#125; --&gt;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">    return kNameObject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 同步锁</span><br><span class=\"line\">/*</span><br><span class=\"line\">+ (instancetype)sharedInstance &#123;</span><br><span class=\"line\">\tvolatile static LaunchIntroductionView *singleInstance = nil;</span><br><span class=\"line\">\t    if (singleInstance == nil) &#123;</span><br><span class=\"line\">\t        @synchronized(self) &#123;</span><br><span class=\"line\">\t            if (singleInstance == nil) &#123;</span><br><span class=\"line\">\t                singleInstance = [[LaunchIntroductionView alloc] init];</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    return singleInstance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">+ (id)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class=\"line\">\tstatic dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        kNameObject = [super allocWithZone:zone];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return kNameObject;</span><br><span class=\"line\">\t&lt;!-- return [self sharedInstance]; --&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (id)copy &#123;</span><br><span class=\"line\">\t&lt;!-- return self; --&gt;</span><br><span class=\"line\">\treturn kNameObject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (id)muntableCope &#123;</span><br><span class=\"line\">\t&lt;!-- return self; --&gt;</span><br><span class=\"line\">\treturn kNameObject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>单例传值使用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">\t// [nameObject sharedInstance].name    </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-通知传值\"><a href=\"#7-通知传值\" class=\"headerlink\" title=\"7. 通知传值\"></a>7. 通知传值</h2><p><strong>编写通知命名</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIKIT_EXTERN NSNotificationName const ZOCFooDidBecomeBarNotification</span><br><span class=\"line\">NSNotificationName const ZOCFooDidBecomeBarNotification = @&quot;ZOCFooDidBecomeBarNotification&quot;;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>通知.h文件,设置通知名字<code>extern NSString * const aNotification;</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(requestName:) name:aNotification object:nil];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>通知.m文件,设置通知名字<code>NSString * const aNotification = @&quot;aNotification&quot;;</code></p>\n</blockquote>\n<p><strong>实现<code>requestName</code>方法</strong></p>\n<p><code>dealloc</code>移除通知</p>\n<h2 id=\"NSUserDefaults数据保存\"><a href=\"#NSUserDefaults数据保存\" class=\"headerlink\" title=\"NSUserDefaults数据保存\"></a>NSUserDefaults数据保存</h2><blockquote>\n<p>统一方法保存<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)saveValueString:(NSString *)valueString withKey:(NSString *)keyString;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getValueStringWithKey:(NSString *)keyString;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)cleanValueStringWithKey:(NSString *)keyString;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>统一方法实现</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)saveValueString:(NSString *)valueString withKey:(NSString *)keyString &#123;</span><br><span class=\"line\">    NSUserDefaults *uidDefaults = [NSUserDefaults standardUserDefaults];</span><br><span class=\"line\">    [uidDefaults setObject:valueString forKey:keyString];</span><br><span class=\"line\">    [uidDefaults synchronize];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getValueStringWithKey:(NSString *)keyString &#123;</span><br><span class=\"line\">    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];</span><br><span class=\"line\">    NSString *valueString = [userDefaults objectForKey:keyString];</span><br><span class=\"line\">    return valueString;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)cleanValueStringWithKey:(NSString *)keyString &#123;</span><br><span class=\"line\">    NSUserDefaults *UserLoginState = [NSUserDefaults standardUserDefaults];</span><br><span class=\"line\">    [UserLoginState removeObjectForKey:keyString];</span><br><span class=\"line\">    [UserLoginState synchronize];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[{"_id":"source/_posts/Hexo插入图片/phone.jpg","post":"cjkhy6qu00000duu9imooznf3","slug":"phone.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Masonry自适应tableHeaderView/tableHeaderView.gif","slug":"tableHeaderView.gif","post":"cjkhy6qua0006duu9d3kmheaf","modified":1,"renderable":0},{"_id":"source/_posts/Masonry设置UIScrollView的contentSize/复杂UIScrollView.gif","slug":"复杂UIScrollView.gif","post":"cjkhy6que0008duu9p2lxey2v","modified":1,"renderable":0},{"_id":"source/_posts/熟悉UIScrollView的contentSize-contentOffset-contentInset/UIScrollView偏移图.png","post":"cjkhy6quv0013duu9skrkpb5p","slug":"UIScrollView偏移图.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS强制横屏实践/横竖屏1.png","post":"cjkhy6qup000oduu9lgru4pbc","slug":"横竖屏1.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS强制横屏实践/横竖屏2.png","post":"cjkhy6qup000oduu9lgru4pbc","slug":"横竖屏2.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS熟悉UIEdgeInsetsMake使用/按钮图片在上文字在下.png","post":"cjkhy6qut000yduu9tthp7p3y","slug":"按钮图片在上文字在下.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS熟悉UIEdgeInsetsMake使用/按钮图片在下文字在上.png","post":"cjkhy6qut000yduu9tthp7p3y","slug":"按钮图片在下文字在上.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS熟悉UIEdgeInsetsMake使用/按钮图片在右文字在左.png","post":"cjkhy6qut000yduu9tthp7p3y","slug":"按钮图片在右文字在左.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS熟悉UIEdgeInsetsMake使用/按钮图片文字居中.png","post":"cjkhy6qut000yduu9tthp7p3y","slug":"按钮图片文字居中.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjkhy6qu00000duu9imooznf3","category_id":"cjkhy6qu80004duu9f3raeozw","_id":"cjkhy6qul000fduu9qcoa79ec"},{"post_id":"cjkhy6qu40002duu9idlmf0a1","category_id":"cjkhy6qu80004duu9f3raeozw","_id":"cjkhy6quo000kduu9a03tqppn"},{"post_id":"cjkhy6qum000iduu91obqimil","category_id":"cjkhy6qul000eduu9g9bi12wp","_id":"cjkhy6qur000rduu9rxlhmkd1"},{"post_id":"cjkhy6qua0006duu9d3kmheaf","category_id":"cjkhy6qul000eduu9g9bi12wp","_id":"cjkhy6qut000wduu9olmsuhnr"},{"post_id":"cjkhy6qun000jduu9pgnkkdgf","category_id":"cjkhy6qul000eduu9g9bi12wp","_id":"cjkhy6quu000zduu9u4yguwgo"},{"post_id":"cjkhy6qup000oduu9lgru4pbc","category_id":"cjkhy6qul000eduu9g9bi12wp","_id":"cjkhy6quv0014duu9q4khoci0"},{"post_id":"cjkhy6qud0007duu9ag5p3i0i","category_id":"cjkhy6qul000eduu9g9bi12wp","_id":"cjkhy6quw0016duu99h55vm69"},{"post_id":"cjkhy6quq000qduu9m924hm63","category_id":"cjkhy6qul000eduu9g9bi12wp","_id":"cjkhy6qux001aduu95ae35mao"},{"post_id":"cjkhy6que0008duu9p2lxey2v","category_id":"cjkhy6qul000eduu9g9bi12wp","_id":"cjkhy6qux001cduu9lxe3ubw5"},{"post_id":"cjkhy6qut000yduu9tthp7p3y","category_id":"cjkhy6qul000eduu9g9bi12wp","_id":"cjkhy6qux001fduu9gsrx3pg5"},{"post_id":"cjkhy6quh000cduu96476hnpy","category_id":"cjkhy6quu0010duu95oqt88uq","_id":"cjkhy6quy001hduu9fc3mdb82"},{"post_id":"cjkhy6quk000dduu9onstz4fe","category_id":"cjkhy6quu0010duu95oqt88uq","_id":"cjkhy6quy001kduu96a3m09cj"},{"post_id":"cjkhy6qus000vduu9sct0eeoj","category_id":"cjkhy6qux001dduu9ltz3mv48","_id":"cjkhy6quy001mduu9pw8qugl8"},{"post_id":"cjkhy6quv0013duu9skrkpb5p","category_id":"cjkhy6qux001dduu9ltz3mv48","_id":"cjkhy6quz001nduu97dkkmmzf"},{"post_id":"cjkhy6qv1001oduu9qiykumgg","category_id":"cjkhy6qux001dduu9ltz3mv48","_id":"cjkhy6qv3001rduu97w8ly0s1"}],"PostTag":[{"post_id":"cjkhy6qu00000duu9imooznf3","tag_id":"cjkhy6qua0005duu9ebf21nf6","_id":"cjkhy6quh000bduu9mhh2njqh"},{"post_id":"cjkhy6qu40002duu9idlmf0a1","tag_id":"cjkhy6qua0005duu9ebf21nf6","_id":"cjkhy6qum000hduu9kf5u90wm"},{"post_id":"cjkhy6qum000iduu91obqimil","tag_id":"cjkhy6qum000gduu916jhaie4","_id":"cjkhy6qup000nduu9tb0mp9pm"},{"post_id":"cjkhy6qua0006duu9d3kmheaf","tag_id":"cjkhy6qum000gduu916jhaie4","_id":"cjkhy6quq000pduu9b0sd0af5"},{"post_id":"cjkhy6qun000jduu9pgnkkdgf","tag_id":"cjkhy6qum000gduu916jhaie4","_id":"cjkhy6qus000uduu9k7qidp1y"},{"post_id":"cjkhy6qup000oduu9lgru4pbc","tag_id":"cjkhy6qum000gduu916jhaie4","_id":"cjkhy6qut000xduu9x308pgrm"},{"post_id":"cjkhy6qud0007duu9ag5p3i0i","tag_id":"cjkhy6qum000gduu916jhaie4","_id":"cjkhy6quv0012duu9m2mczhck"},{"post_id":"cjkhy6quq000qduu9m924hm63","tag_id":"cjkhy6qum000gduu916jhaie4","_id":"cjkhy6quw0015duu94w89rq46"},{"post_id":"cjkhy6qus000vduu9sct0eeoj","tag_id":"cjkhy6qum000gduu916jhaie4","_id":"cjkhy6quw0019duu9lvtmhfiu"},{"post_id":"cjkhy6que0008duu9p2lxey2v","tag_id":"cjkhy6qum000gduu916jhaie4","_id":"cjkhy6qux001bduu9ceflj9nu"},{"post_id":"cjkhy6qut000yduu9tthp7p3y","tag_id":"cjkhy6qum000gduu916jhaie4","_id":"cjkhy6qux001eduu9gcbemqn7"},{"post_id":"cjkhy6quv0013duu9skrkpb5p","tag_id":"cjkhy6qum000gduu916jhaie4","_id":"cjkhy6quy001gduu9bkmfu7fj"},{"post_id":"cjkhy6quh000cduu96476hnpy","tag_id":"cjkhy6qum000gduu916jhaie4","_id":"cjkhy6quy001iduu9p9zyh1u2"},{"post_id":"cjkhy6quk000dduu9onstz4fe","tag_id":"cjkhy6qum000gduu916jhaie4","_id":"cjkhy6quy001lduu92ckahibm"},{"post_id":"cjkhy6qv1001oduu9qiykumgg","tag_id":"cjkhy6qum000gduu916jhaie4","_id":"cjkhy6qv3001qduu9w4o95w1d"}],"Tag":[{"name":"Hexo","_id":"cjkhy6qua0005duu9ebf21nf6"},{"name":"iOS","_id":"cjkhy6qum000gduu916jhaie4"}]}}