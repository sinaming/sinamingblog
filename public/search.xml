<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS横竖屏]]></title>
    <url>%2F2018%2F08%2F06%2FiOS%E6%A8%AA%E7%AB%96%E5%B1%8F%2F</url>
    <content type="text"><![CDATA[前言 熟悉iOS框架结构,一般都是UITabBarController结合UINavigationController,所有需要配置信息 UITabBarController配置123456789- (BOOL)shouldAutorotate&#123; return [self.selectedViewController shouldAutorotate];&#125;- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123; return [self.selectedViewController supportedInterfaceOrientations];&#125;- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123; return [self.selectedViewController preferredInterfaceOrientationForPresentation];&#125; UINavigationController配置1234567891011- (BOOL)shouldAutorotate &#123; return [[self.viewControllers lastObject] shouldAutorotate];&#125;- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123; return [[self.viewControllers lastObject] supportedInterfaceOrientations];&#125;- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123; return [[self.viewControllers lastObject] preferredInterfaceOrientationForPresentation];&#125; 一般应用app开发都是个别页面需要设置好横屏设置,所有在基类里面设置所有的类不能横屏123456789101112131415-(UIInterfaceOrientationMask)supportedInterfaceOrientations&#123; return UIInterfaceOrientationMaskPortrait ;&#125;- (BOOL)shouldAutorotate&#123; return NO;&#125;-(UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123; return UIInterfaceOrientationPortrait;&#125;- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation&#123; return NO;&#125; 旋转ViewController 1234567891011121314151617181920212223242526272829303132// 允许屏幕旋转设置- (BOOL)shouldAutorotate &#123; return YES;&#125;-(UIInterfaceOrientationMask)supportedInterfaceOrientations&#123; return UIInterfaceOrientationMaskAll;&#125;- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123; return UIInterfaceOrientationPortrait;&#125;- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation&#123; return YES;&#125;// 设置状态栏信息//设置样式- (UIStatusBarStyle)preferredStatusBarStyle &#123; return UIStatusBarStyleDefault;&#125;//设置是否隐藏- (BOOL)prefersStatusBarHidden &#123; return NO;&#125;//设置隐藏动画- (UIStatusBarAnimation)preferredStatusBarUpdateAnimation &#123; return UIStatusBarAnimationFade;&#125; 页面设置跳转的逻辑 1234567891011121314151617181920212223242526//iOS8旋转动作的具体执行- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id&lt;UIViewControllerTransitionCoordinator&gt;)coordinator &#123; [super viewWillTransitionToSize:size withTransitionCoordinator: coordinator]; // 监察者将执行： 1.旋转前的动作 2.旋转后的动作（completion） [coordinator animateAlongsideTransition: ^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context) &#123; if ([XMRotatoUtil isOrientationLandscape]) &#123; self-&gt;_lastOrientation = [UIApplication sharedApplication].statusBarOrientation; [self prepareFullScreen]; &#125; else &#123; [self prepareSmallScreen]; &#125; &#125; completion: ^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context) &#123; &#125;];&#125;//iOS7旋转动作的具体执行- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration &#123; [super willRotateToInterfaceOrientation:toInterfaceOrientation duration:duration]; if (toInterfaceOrientation == UIDeviceOrientationLandscapeRight) &#123; _lastOrientation = [UIApplication sharedApplication].statusBarOrientation; [self prepareFullScreen]; &#125; else &#123; [self prepareSmallScreen]; &#125;&#125; 考虑到横屏,默认状态栏会隐藏,需要在info.plist文件中View controller-based status bar appearance为YES 最后 在横屏页面所有的都采用自动布局来达到对于的效果 1234567891011121314151617181920// 屏幕方法调用+ (void)forceOrientation: (UIInterfaceOrientation)orientation &#123; if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123; SEL selector = NSSelectorFromString(@&quot;setOrientation:&quot;); NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]]; [invocation setSelector:selector]; [invocation setTarget: [UIDevice currentDevice]]; int val = orientation; [invocation setArgument:&amp;val atIndex:2]; [invocation invoke]; &#125;&#125;+ (BOOL)isOrientationLandscape &#123; if (UIInterfaceOrientationIsLandscape([UIApplication sharedApplication].statusBarOrientation)) &#123; return YES; &#125; else &#123; return NO; &#125;&#125; 需要配置Deplymengt info勾选竖屏和向右横屏,以解决横屏问题]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS模型嵌套模型]]></title>
    <url>%2F2018%2F06%2F23%2FiOS%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[问题 网络请求到服务器数据,根据服务器的数据结构,我们正确使用数据模型model接收,但会出现这样的情况,数组嵌套数组获取嵌套字典等,所以我们就有了模型切图模型的解决方案 代码STCountryModelh文件 STCountryModel接收类 1234567891011#import &quot;STBaseModel.h&quot;@class STCountryListModel;@interface STCountryModel : STBaseModel@property (nonatomic, copy) NSString *initial;// 使用强引用在接收是必须使用copy方法,防止出现问题@property (nonatomic, strong) NSArray &lt;STCountryListModel *&gt;*list;@end 代码STCountryModelm文件123456789101112131415161718192021#import &quot;STCountryModel.h&quot;#import &quot;STCountryListModel.h&quot;@implementation STCountryModel// 重新父类模型嵌套- (instancetype)initWithSTDataModelDict:(NSDictionary *)dict &#123; if (self = [super init]) &#123; [self setValuesForKeysWithDictionary:dict]; // 性能提升 NSMutableArray *dataSource = [NSMutableArray arrayWithCapacity:self.list.count]; for (NSDictionary *brandDict in self.list) &#123; STCountryListModel *model = [[STCountryListModel alloc] initWithSTDataModelDict:brandDict]; [dataSource addObject:model]; &#125; self.list = [dataSource copy]; &#125; return self;&#125;@end 代码STCountryListModelh文件 STCountryListModel接收类 1234567891011121314151617181920212223#import &quot;STBaseModel.h&quot;@interface STCountryListModel : STBaseModel@property (nonatomic, copy) NSString *initial;@property (nonatomic, copy) NSString *country;@property (nonatomic, copy) NSString *file_fid;@property (nonatomic, copy) NSString *ID;@property (nonatomic, copy) NSString *country_code;@property (nonatomic, copy) NSString *short_name;@property (nonatomic, copy) NSString *file_pic;@property (nonatomic, copy) NSString *name;@property (nonatomic, copy) NSString *city_code;@end 代码STCountryListModelm文件1234567891011121314#import &quot;STCountryListModel.h&quot;@implementation STCountryListModel// 关键字冲突- (void)setValue:(id)value forUndefinedKey:(NSString *)key &#123; if([key isEqualToString:@&quot;id&quot;]) &#123; // [self.ID setValue:value forKey:key]; self.ID = value; return ; &#125;&#125;@end]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios之界面之间的数据正逆向传递方法]]></title>
    <url>%2F2018%2F06%2F08%2Fios%E4%B9%8B%E7%95%8C%E9%9D%A2%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E6%AD%A3%E9%80%86%E5%90%91%E4%BC%A0%E9%80%92%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 初始化传值 自定义View初始化方法.h文件 1234567#import &lt;UIKit/UIKit.h&gt;@interface XMContentView : UIView- (instancetype)initTitles:(NSArray &lt;NSString *&gt;*)titles;@end 自定义View初始化方法.m文件 12345678910111213141516171819#import &quot;XMContentView.h&quot;@interface XMContentView ()// 数据保存@property (nonatomic, strong) NSArray *titles;@end@implementation XMContentView- (instancetype)initTitles:(NSArray&lt;NSString *&gt; *)titles &#123; if (self = [super init]) &#123; // 进行页面数据传递 &#125; return self;&#125;@end 初始化传值使用 1234567- (void)viewDidLoad &#123; [super viewDidLoad]; _contentView = [[XMContentView alloc] initTitles:@[@&quot;初始化传值1&quot;,@&quot;初始化传值2&quot;]]; [self.view addSubview:_contentView];&#125; 2. 属性传值 自定义View添加属性.h文件 1234567#import &lt;UIKit/UIKit.h&gt;@interface XMContentView : UIView@property (nonatomic, copy) NSString *titles;@end 自定义View添加属性.m文件 123456789101112131415#import &quot;XMContentView.h&quot;@interface XMContentView ()@end@implementation XMContentView- (void)setTitles:(NSString *)titles &#123; _titles = titles; // 进行页面数据传递&#125;@end 属性传值使用 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; _contentView = [[XMContentView alloc] initWithFrame:CGRectZero]; _contentView.titles = @&quot;属性传值&quot;; [self.view addSubview:_contentView];&#125; 3. 方法传值 自定义View添加方法.h文件 123456789#import &lt;UIKit/UIKit.h&gt;@interface XMContentView : UIView- (void)reloadContentViewTitles:(NSArray &lt;NSString *&gt;*)titles;+ (void)reloadContentViewNames:(NSString *)names;@end 自定义View添加方法.m文件 123456789101112131415161718#import &quot;XMContentView.h&quot;@interface XMContentView ()@end@implementation XMContentView- (void)reloadContentViewTitles:(NSArray&lt;NSString *&gt; *)titles &#123; // 进行页面传递数据配置&#125;+ (void)reloadContentViewNames:(NSString *)names &#123; // 进行页面传递数据配置&#125;@end 方法传值使用 123456789- (void)viewDidLoad &#123; [super viewDidLoad]; _contentView = [[XMContentView alloc] initWithFrame:CGRectZero]; [_contentView reloadContentViewTitles:@[@&quot;方法传值1&quot;,@&quot;方法传值2&quot;]]; [XMContentView reloadContentViewNames:@&quot;方法传值&quot;]; [self.view addSubview:_contentView];&#125; 4. Delegate(协议)传值 自定义View添加协议.h文件 12345678910111213141516#import &lt;UIKit/UIKit.h&gt;@protocol XMContentViewDelegate &lt;NSObject&gt;// delegate 必须实现的方法@required- (void)sendInformation:(NSInteger)tag;// delegate 选择实现的方法@optional@end@interface XMContentView : UIView@property (nonatomic, weak) id&lt;XMContentViewDelegate&gt; delegate;@end 自定义View添加协议.m文件 12345678910111213141516171819#import &quot;XMContentView.h&quot;@interface XMContentView ()@end@implementation XMContentView- (instancetype)initWithFrame:(CGRect)frame &#123; if (self = [super initWithFrame:frame]) &#123; // 一般用于反向传值,按钮或者手势处理 if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(sendInformation:)]) &#123; [_delegate sendInformation:0]; &#125; &#125; return self;&#125;@end 协议传值使用 12345678910111213141516171819// 引用协议@interface ViewController ()&lt;XMContentViewDelegate&gt;@end- (void)viewDidLoad &#123; [super viewDidLoad]; _contentView = [[XMContentView alloc] initWithFrame:CGRectZero]; // 遵守协议 _contentView.delegate = self; [self.view addSubview:_contentView]; &#125;// 实现协议传值- (void)sendInformation:(NSInteger)tag &#123; &#125; 5. Block传值 自定义View定义Block.h文件 12345678910111213141516171819202122#import &lt;UIKit/UIKit.h&gt;typedef void(^contentBlock)(NSString *titles);@interface XMContentView : UIView@property (nonatomic, copy) contentBlock contentblk;@property (nonatomic, copy) dispatch_block_t contentdisblk;// block第一个参数为返回值,第二个参数为block名字,第三个参数为携带的参数@property (nonatomic, copy) void (^contentBlock)(void);- (void)reloadBlock:(void (^)(NSString *titles))animations;// 方法和属性设置block// returnType(^name)(arguments);// - void)reloadBlock:(returnType(^name)(arguments))animations;@end 自定义View定义Block.m文件 1234567891011121314151617181920#import &quot;XMContentView.h&quot;@interface XMContentView ()@end@implementation XMContentView- (instancetype)initWithFrame:(CGRect)frame &#123; if (self = [super initWithFrame:frame]) &#123; &#125; return self;&#125;- (void)reloadBlock:(void (^)(NSString *titles))animations &#123; // 进行页面传递数据配置&#125;@end Block传值使用 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; // block中处理weak属性,防止循环引用 __weak typeof(self) weakSelf = self; _contentView = [[XMContentView alloc] initWithFrame:CGRectZero]; [_contentView reloadBlock:^(NSString *titles) &#123; &#125;]; _contentView.contentBlock = ^&#123; &#125;; [self.view addSubview:_contentView];&#125; 6. 单例传值 自定义单例.h文件 1234567891011#import @interface nameObject : NSObject/** 单例类方法 @return 返回一个共享对象 */+ (instancetype)sharedInstance;// 姓名@property (nonatomic, copy) NSString* name;@end 自定义单例.m文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#import &quot;nameObject.h&quot;@implementation nameObjectstatic nameObject* kNameObject = nil;/** 单例类方法 */// GCD+ (instancetype)sharedInstance &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; &lt;!-- if (kNameObject == nil) &#123; --&gt; kNameObject = [[super allocWithZone:NULL] init]; &lt;!-- &#125; --&gt; &#125;); return kNameObject;&#125;// 同步锁/*+ (instancetype)sharedInstance &#123; volatile static LaunchIntroductionView *singleInstance = nil; if (singleInstance == nil) &#123; @synchronized(self) &#123; if (singleInstance == nil) &#123; singleInstance = [[LaunchIntroductionView alloc] init]; &#125; &#125; &#125; return singleInstance;&#125;*/+ (id)allocWithZone:(struct _NSZone *)zone &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; kNameObject = [super allocWithZone:zone]; &#125;); return kNameObject; &lt;!-- return [self sharedInstance]; --&gt;&#125;- (id)copy &#123; &lt;!-- return self; --&gt; return kNameObject;&#125;- (id)muntableCope &#123; &lt;!-- return self; --&gt; return kNameObject;&#125;@end 单例传值使用 123456- (void)viewDidLoad &#123; [super viewDidLoad]; // [nameObject sharedInstance].name &#125; 7. 通知传值编写通知命名12UIKIT_EXTERN NSNotificationName const ZOCFooDidBecomeBarNotificationNSNotificationName const ZOCFooDidBecomeBarNotification = @&quot;ZOCFooDidBecomeBarNotification&quot;; 通知.h文件,设置通知名字extern NSString * const aNotification; 1[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(requestName:) name:aNotification object:nil]; 通知.m文件,设置通知名字NSString * const aNotification = @&quot;aNotification&quot;; 实现requestName方法 dealloc移除通知 NSUserDefaults数据保存 统一方法保存12345+ (void)saveValueString:(NSString *)valueString withKey:(NSString *)keyString;+ (NSString *)getValueStringWithKey:(NSString *)keyString;+ (void)cleanValueStringWithKey:(NSString *)keyString; 统一方法实现 1234567891011121314151617+ (void)saveValueString:(NSString *)valueString withKey:(NSString *)keyString &#123; NSUserDefaults *uidDefaults = [NSUserDefaults standardUserDefaults]; [uidDefaults setObject:valueString forKey:keyString]; [uidDefaults synchronize];&#125;+ (NSString *)getValueStringWithKey:(NSString *)keyString &#123; NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; NSString *valueString = [userDefaults objectForKey:keyString]; return valueString;&#125;+ (void)cleanValueStringWithKey:(NSString *)keyString &#123; NSUserDefaults *UserLoginState = [NSUserDefaults standardUserDefaults]; [UserLoginState removeObjectForKey:keyString]; [UserLoginState synchronize];&#125;]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS熟悉@property和set方法和get方法]]></title>
    <url>%2F2018%2F06%2F05%2FiOS%E7%86%9F%E6%82%89-property%E5%92%8Cset%E6%96%B9%E6%B3%95%E5%92%8Cget%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言@property (nonatomic, assign) CGFloat height; @property声明了成员变量，没有自己去写它的set方法和get方法,Xcode系统会自动生成set和get方法。同时生成一个下划线成员变量 你调用的时候，赋值的值是多少就是多少 123Person *p = [[Person alloc] init];p.height = 170.0;NSLog(@&quot;%f&quot;,p.height); //打印得170.0 如果你自己写了set方法，却没有在里面做任何操作，会默认调用_height。所有的成员变量初始值都是0.所以即便你在调用set方法的时候赋值，打印出来也是0 Set方法 123- (void)setHeight:(CGFloat)height &#123;&#125; 123Person *p = [[Person alloc] init];p.height = 170.0;NSLog(@&quot;%f&quot;,p.height); //打印得0.0 如果你自己写了get方法，在里面return 180.0。你在调用get方法的时候赋值，打印出来也是就是你get方法里面返回的值180.0 Get方法 123- (CGFloat)height &#123; return 180.0;&#125; 123Person *p = [[Person alloc] init];p.height = 170.0;NSLog(@&quot;%f&quot;,p.height); //打印得180.0 =左边height是调用set方法 =右边height是调用get方法 如果你自己同时生成了set和get方法，那系统就不会生成下划线成员变量 手动实现set方法和get方法123456789@synthesize height = _height;- (void)setHeight:(CGFloat)height &#123; _height = height;&#125;- (CGFloat)height &#123; return _height;&#125; RuntimeRuntimekey值使用C语言字符串 static char imageURLKey = &amp;imageURLKey static char imageURLKey = &quot;imageURLKey&quot;]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS强制横屏实践]]></title>
    <url>%2F2018%2F06%2F04%2FiOS%E5%BC%BA%E5%88%B6%E6%A8%AA%E5%B1%8F%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[问题 在开发视频播放器的时候,需要视频全屏播放同时还能响应手机旋转 所以 通过资料查找,分为几种方案 方案一 View旋转 方案二 转场动画 方案三 强制横竖屏 实践 今天就考虑直接使用强制横竖屏来完成播放器的全屏播放 General配置 info.plist配置 横竖屏跳转的Controller 123456789101112- (void)interfaceOrientation:(UIInterfaceOrientation)orientation &#123; if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123; SEL selector = NSSelectorFromString(@&quot;setOrientation:&quot;); NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]]; [invocation setSelector:selector]; [invocation setTarget:[UIDevice currentDevice]]; int val = orientation; // 从2开始是因为0 1 两个参数已经被selector和target占用 [invocation setArgument:&amp;val atIndex:2]; [invocation invoke]; &#125;&#125; 重点,必须配置状态栏才能正确的跳转 1234// 跳转的Controller设置- (BOOL)shouldAutorotate &#123; return NO;&#125; 响应事件调用 1[self interfaceOrientation:UIInterfaceOrientationPortrait]; 一般我们都是UITabBarController和UINavigationController的结构来完成App的框架搭建 配置UITabBarController 123456789- (BOOL)shouldAutorotate&#123; return [self.selectedViewController shouldAutorotate];&#125;- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123; return [self.selectedViewController supportedInterfaceOrientations];&#125;- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123; return [self.selectedViewController preferredInterfaceOrientationForPresentation];&#125; 配置UINavigationController 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// viewDidLoad调用[[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(deviceOrientationDidChange) name:UIDeviceOrientationDidChangeNotification object:nil];// 方法一获取- (BOOL)shouldAutorotate&#123; return [[self.viewControllers lastObject]shouldAutorotate];&#125;- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123; return [[self.viewControllers lastObject]supportedInterfaceOrientations];&#125;- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123; return [[self.viewControllers lastObject] preferredInterfaceOrientationForPresentation];&#125;// 方法二获取- (BOOL)shouldAutorotate &#123; return [self.topViewController shouldAutorotate];&#125;- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123; return [self.topViewController supportedInterfaceOrientations];&#125;- (void)deviceOrientationDidChange &#123; NSLog(@&quot;NAV deviceOrientationDidChange:%ld&quot;,(long)[UIDevice currentDevice].orientation); if([UIDevice currentDevice].orientation == UIDeviceOrientationPortrait) &#123; [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationPortrait]; [self orientationChange:NO]; //注意： UIDeviceOrientationLandscapeLeft 与 UIInterfaceOrientationLandscapeRight &#125; else if ([UIDevice currentDevice].orientation == UIDeviceOrientationLandscapeLeft) &#123; [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationLandscapeRight]; [self orientationChange:YES]; &#125;&#125;- (void)orientationChange:(BOOL)landscapeRight &#123; CGFloat width = [UIScreen mainScreen].bounds.size.width; CGFloat height = [UIScreen mainScreen].bounds.size.height; if (landscapeRight) &#123; [UIView animateWithDuration:0.2f animations:^&#123; self.view.transform = CGAffineTransformMakeRotation(M_PI_2); self.view.bounds = CGRectMake(0, 0, width, height); &#125;]; &#125; else &#123; [UIView animateWithDuration:0.2f animations:^&#123; self.view.transform = CGAffineTransformMakeRotation(0); self.view.bounds = CGRectMake(0, 0, width, height); &#125;]; &#125;&#125; 最后 上面全部的代码配置好,iOS强制横屏就已经完成了,大伙自己实践一下!!!]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS仿淘宝详情页导航栏]]></title>
    <url>%2F2018%2F06%2F02%2FiOS%E4%BB%BF%E6%B7%98%E5%AE%9D%E8%AF%A6%E6%83%85%E9%A1%B5%E5%AF%BC%E8%88%AA%E6%A0%8F%2F</url>
    <content type="text"><![CDATA[前提 当看到好的App应用,都想好好的了解下他们的实现 分析 正常的App应用是不能分析App的结构的,所以我们只能借助越狱的手机,对App进行分析,如果没有越狱手机我们一样的可以分析App的结构 Mac下载PP助手程序,再越狱应用中搜索参考的App 下载参考的App,对App进行解压,获取应用安装包 安装工具,具体的工具自行搜索百度(逆向分析工具) 安装好工具,把应用安装包放入工具中,运行安装等等(更多的逆向自行搜索) 通过Xcode工具UI界面分析工具查看淘宝详情页的页面 了解,UI界面分析完成之后,大概知道了他的实现View,查看UI界面分析得到的淘宝详情页导航栏实现的View 实现 开始我们的实现,如上的的分析,我们得到了淘宝详情页的大致结构,跳转页面隐藏系统导航栏,添加导航栏View 看代码 隐藏导航栏(第一步) UINavigationControllerDelegate实现代理,侧滑的同时也不会隐藏导航栏的正确显示和隐藏 12345678910- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; self.navigationController.delegate = self;&#125;- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated &#123; // 判断要显示的控制器是否是自己 BOOL isShowHomePage = [viewController isKindOfClass:[self class]]; [self.navigationController setNavigationBarHidden:isShowHomePage animated:YES];&#125; 创建导航栏View(第二步) 创建导航栏View,里面放置详情页面需要的按钮信息和跳转逻辑,Controller添加完UITableView,只会添加导航栏View,他们都同样的添加的Controller的View上123456789101112 // tableView [self.view addSubview:self.tableView]; self.tableView.tableHeaderView = self.tableHeadLabel; // 导航栏View [self.view addSubview:self.floatView];- (void)viewWillLayoutSubviews &#123; [super viewWillLayoutSubviews]; // 让导航栏View显示最上层,backgroundView设置成透明 [self.view bringSubviewToFront:self.floatView];&#125; 完成上面的操作,是不能滑动tableView的 解决分析iOS我们通过响应链知识,导航栏View重写- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event方法,具体看代码12345678910111213141516171819- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;// UIView *tmpView = [super hitTest:point withEvent:event];// if (tmpView.superview == self) &#123;// return nil;// &#125;// return tmpView; // 处理的关键点在于判断条件//// tmpView.superview == self!//// 如果需要穿透UIView，则变更为tmpView == self UIView *tmpView = [super hitTest:point withEvent:event]; if (tmpView == self) &#123; return nil; &#125; return tmpView;&#125; 完成完成上面的操作,这个手势滑动导航栏View,就能响应tableView的手势了 上面的逻辑大致可以实现大部分功能了,所以多查查资料可以更好的提升自己的能力]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之UITableView滚动方向]]></title>
    <url>%2F2018%2F05%2F29%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8BUITableView%E6%BB%9A%E5%8A%A8%E6%96%B9%E5%90%91%2F</url>
    <content type="text"><![CDATA[iOS开发之UITableView, UICollectionView, UIScrollview,根据代理判断页面滚动方向 123456789- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; CGPoint point = [scrollView.panGestureRecognizer translationInView:self.view]; if (point.y &gt; 0 ) &#123; NSLog(@&quot;------往上滚动&quot;); &#125;else&#123; NSLog(@&quot;------往下滚动&quot;); &#125; &#125;]]></content>
      <categories>
        <category>iOS效率</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[熟悉UIScrollView的contentSize,contentOffset,contentInset]]></title>
    <url>%2F2018%2F05%2F17%2F%E7%86%9F%E6%82%89UIScrollView%E7%9A%84contentSize-contentOffset-contentInset%2F</url>
    <content type="text"><![CDATA[UIScrollView基础知识 UIScrollView中的contentSize,contentOffset,contentInset的知识点熟悉 contentSize contentSize是UIScrollView和继承于UIScrollView的子控件的属性，contentSize是确定UIScrollView上contentView宽（contentSize.width）和高（conteSize.height）的属性。 contentOffset contentOffset是UIScrollView和继承于UIScrollView的子控件的属性，contentOffset确定的是UIScrollView的顶点（左上角点）值相对于其父类视图的顶点值（即frame.origin）的距离 contentInset contentInset是UIScrollView和继承于UIScrollView的子控件的属性，contentInset确定的是contenView上下左右相对于UIScrollView扩展出来的区域大小。contentInset是UIEdgeInsets类型的，默认值为UIEdgeInsetsZero。 布局图 理解 scrollView.contentInset默认情况下其初始值都为0；当设置了初始值时（不为零），它相当于给scrollView的范围进行了扩大，并加了一堵墙，如果把scrollView中的图片理解为一个背景，将scrollView理解为一个镜头，通过改变scrollView.contentOffset的值就可以改变镜头的初始化位置，但是当你设置了scrollView.contentInset 后如果其改变的位置超过了你加的范围它的镜头最多移到你加范围的最大位置 参考文档熟悉UIScrollView的contentSize,contentOffset,contentInset]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS熟悉UIEdgeInsetsMake使用]]></title>
    <url>%2F2018%2F05%2F13%2FiOS%E7%86%9F%E6%82%89UIEdgeInsetsMake%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[理解UIEdgeInsetsMake Creates an edge inset for a button or view.开发文档中显示 定义调用方法UIEdgeInsets UIEdgeInsetsMake(CGFloat top, CGFloat left, CGFloat bottom, CGFloat right) 123typedef struct UIEdgeInsets &#123; CGFloat top, left, bottom, right; // specify amount to inset (positive) for each of the edges. values can be negative to &apos;outset&apos;&#125; UIEdgeInsets; 简单点说就是对视图的偏移 看黑板,使用说明 定义一个UIButton,对它的子视图对它进行布局 按钮titleLabel的titleEdgeInsets 按钮imageView的imageEdgeInsets 12[btn setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn.imageView.frame.size.width, 0, 0)];[btn setImageEdgeInsets:UIEdgeInsetsMake(0, 0, 0, -btn.titleLabel.intrinsicContentSize.width)]; 按钮图片文字居中 imageView在左，titleLabel在右 UIButton系统默认imageView在上，titleLabel在下123[btn setTitleEdgeInsets:UIEdgeInsetsMake(btn.titleLabel.intrinsicContentSize.height + 10, -btn.imageView.frame.size.width, 0, 0)];[btn setImageEdgeInsets:UIEdgeInsetsMake(0, 0, btn.imageView.frame.size.height + 10, -btn.titleLabel.intrinsicContentSize.width)];考虑间隙对图片和文字加了10的偏移量 按钮图片在上文字在下 imageView在下，titleLabel在上12[btn setTitleEdgeInsets:UIEdgeInsetsMake(-btn.titleLabel.intrinsicContentSize.height - 10, -btn.imageView.frame.size.width, 0, 0)];[btn setImageEdgeInsets:UIEdgeInsetsMake(0, 0, -btn.imageView.frame.size.height - 10, -btn.titleLabel.intrinsicContentSize.width)]; 按钮图片在下文字在上 imageView在右，titleLabel在左12[btn setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn.imageView.frame.size.width, 0, btn.imageView.frame.size.width)];[btn setImageEdgeInsets:UIEdgeInsetsMake(0, btn.titleLabel.intrinsicContentSize.width, 0, -btn.titleLabel.intrinsicContentSize.width)]; 按钮图片在右文字在左 imageView靠右，titleLabel靠左12[btn setImageEdgeInsets:UIEdgeInsetsMake(0, btn.frame.size.width - btn.imageView.frame.size.width, 0, -btn.titleLabel.intrinsicContentSize.width)];[btn setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn.imageView.frame.size.width, 0, btn.frame.size.width - btn.titleLabel.intrinsicContentSize.width)]; intrinsicContentSize是iOS 8时候获取的属性]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOSPush任意新页面]]></title>
    <url>%2F2018%2F05%2F10%2FiOSPush%E4%BB%BB%E6%84%8F%E6%96%B0%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[APP任意push新页面 平时push一般都是[self.navigationController pushViewController:newVC animated:YES]; 看黑板 现在通过UIApplication添加分类获取UINavigationController来实现push 123456789101112131415161718192021222324252627- (UIWindow *)mainWindow &#123; return self.delegate.window;&#125;- (UIViewController *)visibleViewController &#123; UIViewController *rootViewController = [self.mainWindow rootViewController]; return [self getVisibleViewControllerFrom:rootViewController];&#125;- (UIViewController *) getVisibleViewControllerFrom:(UIViewController *) vc &#123; if ([vc isKindOfClass:[UINavigationController class]]) &#123; return [self getVisibleViewControllerFrom:[((UINavigationController *) vc) visibleViewController]]; &#125; else if ([vc isKindOfClass:[UITabBarController class]]) &#123; return [self getVisibleViewControllerFrom:[((UITabBarController *) vc) selectedViewController]]; &#125; else &#123; if (vc.presentedViewController) &#123; return [self getVisibleViewControllerFrom:vc.presentedViewController]; &#125; else &#123; return vc; &#125; &#125;&#125;- (UINavigationController *)visibleNavigationController &#123; return [[self visibleViewController] navigationController];&#125; 调用12UINavigationController *navigationController = [[UIApplication sharedApplication] visibleNavigationController];[navigationController pushViewController:newVC animated:YES]; 参考文档iOS - APP任意push新页面那些事]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Masonry设置UIScrollView的contentSize,实现复杂页面开发]]></title>
    <url>%2F2018%2F05%2F08%2FMasonry%E8%AE%BE%E7%BD%AEUIScrollView%E7%9A%84contentSize%2F</url>
    <content type="text"><![CDATA[前言 开发项目中,遇到复杂页面开发,今天就使用Masonry+UIScrollView实现复杂页面开发 实例图 通过看上面的效果图,是否觉得这页面是否很复杂,不同的有不同的解答方法,今天,我就介绍下我个人的解决方案 看黑板 首先,我们先分析一波这个页面的具体内容和复杂程度,是否考虑使用UITableView或者UIScrollView来完成这个需求,我相信UITableView也是能实现这个方案,可能是我太懒! 我们可以分为三个模块,从顶部到联系客服下面的横线为第一个模块,简称TopView,第二个模块图文详情模块,简称CenterView,第三个模块腕表参数模块,简称BottomView,命名请忽视,我们可以自定义三个View,分别实现里面的内容显示 TopView 123456789101112131415161718192021[self addSubview:self.testLabel];[self.testLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.left.right.mas_equalTo(self).offset(0);&#125;];[self addSubview:self.testButton];[self.testButton mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.mas_equalTo(self.testLabel.mas_bottom).offset(0); make.left.right.mas_equalTo(self).offset(0);&#125;];[self addSubview:self.testImageView];[self.testImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.mas_equalTo(self.testButton.mas_bottom).offset(0); make.left.right.mas_equalTo(self).offset(0);&#125;];// 重点,必须设置这个约束,确定底部的位置[self mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.bottom.mas_equalTo(self.testImageView.mas_bottom).offset(0);&#125;]; CenterView和BottomView同样设置从顶部和底部控件位置,确定当前containerView(容器)底部约束这个尤为重要 Controller 父视图@property (nonatomic, strong) UIScrollView *scrollView; 容器视图@property (nonatomic, strong) UIView *containerView; 分别创建好这两个 1234567891011121314151617181920212223242526272829303132[self.view addSubview:self.scrollView];[self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(self.view);&#125;];[self.scrollView addSubview:self.containerView];[self.containerView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(self.scrollView); make.width.equalTo(self.scrollView);&#125;];[self.containerView addSubview:self.topView];[self.topView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.right.top.mas_equalTo(self.containerView).offset(0);&#125;];[self.containerView addSubview:self.centerView];[self.centerView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.mas_equalTo(self.topView.mas_bottom).offset(0); make.left.right.mas_equalTo(self.containerView).offset(0);&#125;];[self.containerView addSubview:self.bottomView];[self.bottomView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.mas_equalTo(self.centerView.mas_bottom).offset(0); make.left.right.bottom.mas_equalTo(self.containerView).offset(0);&#125;];// 这个很重要,controller里面同样需要确定containerView(容器)的底部约束[self.containerView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.bottom.mas_equalTo(self.bottomView.mas_bottom).offset(0);&#125;]; 最后 布局页面我们已经全部都完成了,就是数据填充问题了,这样我们实行UIScrollView复杂页面开发的实现 重要的事情说三遍 自定义View的子控件,约束必须是从top到bottom位置必须确定,接着确定自定义View的底部约束(就是自定义View底部控件的bottom的约束) 自定义View的子控件,约束必须是从top到bottom位置必须确定,接着确定自定义View的底部约束(就是自定义View底部控件的bottom的约束) 自定义View的子控件,约束必须是从top到bottom位置必须确定,接着确定自定义View的底部约束(就是自定义View底部控件的bottom的约束) 修改View约束动画12345678910111213141516171819202122232425262728293031323334- (void)updateConstraints &#123; // remake会将之前的全部移除，然后重新添加 __weak __typeof(self) weakSelf = self; [self.testButton mas_remakeConstraints:^(MASConstraintMaker *make) &#123; make.top.mas_equalTo(self.testLabel.mas_bottom).offset(0); make.left.right.mas_equalTo(self).offset(0); if (weakSelf.isExpanded) &#123; make.height.mas_equalTo(200); &#125; else &#123; make.height.mas_equalTo(40); &#125; &#125;]; [super updateConstraints];&#125;// 响应时间处理- (void)onGrowButtonTaped:(UIButton *)sender &#123; self.isExpanded = !self.isExpanded; if (!self.isExpanded) &#123; [self.testButton setTitle:@&quot;点我展开&quot; forState:UIControlStateNormal]; &#125; else &#123; [self.testButton setTitle:@&quot;点我收起&quot; forState:UIControlStateNormal]; &#125; // 告诉self.view约束需要更新 [self setNeedsUpdateConstraints]; // 调用此方法告诉self.view检测是否需要更新约束，若需要则更新，下面添加动画效果才起作用 [self updateConstraintsIfNeeded]; [UIView animateWithDuration:0.3 animations:^&#123; [self layoutIfNeeded]; &#125;];&#125;]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Masonry自适应tableHeaderView]]></title>
    <url>%2F2018%2F05%2F05%2FMasonry%E8%87%AA%E9%80%82%E5%BA%94tableHeaderView%2F</url>
    <content type="text"><![CDATA[如题 从苹果开发约束,方便了我们快速适配iPhone手机,看到Masonry之后,我们就想要适配所有开发中所遇到的问题,今天就适配Masonry自适应tableHeaderView 解答如果使用frame,计算的话肯定也是可以达到相同结果的,可是麻烦,所以今天就使用Masonry来完成这个需求 首先, 我们一般都是自定义View,在这个View设置好约束 重要 这个自定义View,里面的子控件一定要有从top到bottom连起来的那一条线,就像盖房子一样的,第一个子控件到最后的个子控件,让tableHeaderView知道top到bottom的位置 自定义View代码1234567891011121314151617// 这个是第一个子控件[self addSubview:self.oneLabel];[self.oneLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.left.right.mas_equalTo(self).offset(0);&#125;];// 这个是第二个子控件[self addSubview:self.oneImageView];[self.oneImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.mas_equalTo(self.oneLabel.mas_bottom).offset(0); make.left.right.mas_equalTo(self).offset(0);&#125;];// 重点,必须设置这个约束,告诉当前view的位置[self mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.bottom.mas_equalTo(self.oneImageView.mas_bottom).offset(0);&#125;]; Controller代码12345// 必须给headerView设置宽度,不然headView是不知道到底有宽self.tableView.tableHeaderView = self.headView;[self.headView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.width.equalTo(self.tableView);&#125;]; 方案二 如果确定子控件底部到父视图的位置,就不需要设置父视图底部位置,如果不确定底部位置就需要设置父视图底部位置 12345678910[self addSubview:self.oneImageView];[self.oneImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.mas_equalTo(self.oneLabel.mas_bottom).offset(0); make.left.right.bottom.mas_equalTo(self).offset(0);&#125;];// 重点,必须设置这个约束,告诉当前view的位置//[self mas_makeConstraints:^(MASConstraintMaker *make) &#123;// make.bottom.mas_equalTo(self.oneImageView.mas_bottom).offset(0);//&#125;]; 方案三 如果出现bug先设置好Masonry的TableHeadView,再调用View的layoutIfNeeded 123456789101112131415[self.view addSubview:self.tableView];[self.tableView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.mas_equalTo(self.view).insets(UIEdgeInsetsMake(0, 0, 0, 0));&#125;];self.tableView.tableHeaderView = self.headView;[self.headView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.width.equalTo(self.tableView);&#125;];[self.view setNeedsLayout];[self.view layoutIfNeeded];self.tableView.tableHeaderView = self.headView; 效果图]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo插入图片]]></title>
    <url>%2F2018%2F05%2F05%2FHexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[前言 当我们想在博客上上传图片,如果直接引用本地图片,会存在很多问题,图片损坏等 解决 在hexo文件夹中找到_config.yml里的post_asset_folder:这个选项设置为true 在hexo目录下执行这样一句话npm install hexo-asset-image --save命令,来安装一个可以上传图片的插件 命令创建hexo -n xxxx.md,执行完成之后,会在/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 最后把图片复杂到xxxx.md的文件夹中,按照这样的方式![你想输入的替代文字](xxxx/图片名.jpg) 举例 如果完成上面操作,会实现显示自己添加的图片,说明已经完成 参考文档hexo生成博文插入图片]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS偷懒_效率]]></title>
    <url>%2F2018%2F05%2F04%2FiOS%E5%81%B7%E6%87%92-%E6%95%88%E7%8E%87%2F</url>
    <content type="text"><![CDATA[import导入pod第三方库不提示问题 选择target &gt; BuildSettings &gt; search Paths下的User Header Search Paths 双击后面的空白区域 点击”+”号添加一项:并且输入:$(PODS_ROOT),选择:recursive(会在相应的目录递归搜索文件) 添加pch文件 Xcode正确创建pch文件 选择target &gt; BuildSettings &gt; Apple LLVM 8.0 -Language下的Prefix Header(或者搜索Prefix Header) 双击后面的空白区域 点击”+”号添加一项:并且输入:$(SRCROOT)/项目中创建.pch,选择:recursive(会在相应的目录递归搜索文件) Precompile Prefix Header为YES,预编译后的pch文件缓存起来 扩展随机颜色1[UIColor colorWithRed:arc4random_uniform(255) / 255.0 green:arc4random_uniform(255) / 255.0 blue:arc4random_uniform(255) / 255.0 alpha:1]; UIView常用setNeedsDisplay和setNeedsLayoutUIView的setNeedsDisplay和setNeedsLayout方法 首先两个方法都是异步执行的。而setNeedsDisplay会调用自动调用drawRect方法，这样可以拿到UIGraphicsGetCurrentContext，就可以画画了。而setNeedsLayout会默认调用layoutSubViews，就可以处理子视图中的一些数据。 综上所诉，setNeedsDisplay方便绘图，而layoutSubViews方便出来数据。 layoutSubviews在以下情况下会被调用： init初始化不会触发layoutSubviews。 addSubview会触发layoutSubviews。 设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。 滚动一个UIScrollView会触发layoutSubviews。 旋转Screen会触发父UIView上的layoutSubviews事件。 改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。 直接调用setLayoutSubviews。 drawRect在以下情况下会被调用： 如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect调用是在Controller-&gt;loadView, Controller-&gt;viewDidLoad两方法之后掉用的.所以不用担心在控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量值). 该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。 通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。 直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。 以上1,2推荐；而3,4不提倡 drawRect方法使用注意点： 若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或者 setNeedsDisplayInRect，让系统自动调该方法。 若使用calayer绘图，只能在drawInContext:中（类似于drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法 若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕 UIView调用 -(void)layoutSubviews -(void)layoutIfNeeded -(void)setNeedsLayout -(CGSize)sizeThatFits:(CGSize)size -(void)sizeToFit -(void)setNeedsDisplay -(void)drawRect layoutSubviews在以下情况下会被调用/被触发？？ init初始化不会触发layoutSubviews，但是是用initWithFrame进行初始化时，当rect的值 非CGRectZero时,也会触发。 addSubview会触发layoutSubviews 设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化 滚动一个UIScrollView会触发layoutSubviews 旋转Screen会触发父UIView上的layoutSubviews事件 改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件 (在苹果的官方文档中强调) You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.layoutSubviews,(当我们在某个类的内部调整子视图位置时，需要调用。反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。) 刷新子对象布局??什么时候，需要重写？ view是系统的，不需要重写 - (void)layoutSubviews view是自定义的，需要重写 - (void)layoutSubviews -layoutSubviews方法：这个方法，默认没有做任何事情，需要子类进行重写，自定义view时，手动重写，这里面只能写subview的frame限制。 手动调用这个方法，系统默认 我们不能手动直接调用这个方法，这能通过下列两种方式，调用/触发 - (void)layoutSubviews方法 -setNeedsLayout方法： 标记为需要重新布局，告诉系统未来某个时间点异步调用。不立即刷新，但layoutSubviews一定会被调用。 -layoutIfNeeded方法：如果，有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews） 若需要立即刷新view的frame更改：（同时调用，注意先后顺序） 先调用[view setNeedsLayout]，把标记设为需要布局 然后马上调用[view layoutIfNeeded]，实现布局 在初始化方法init..。、或者view第一次显示之前，标记总是“需要刷新”的，可以直接调用[view layoutIfNeeded] 重绘 -drawRect:(CGRect)rect方法：重写此方法，执行重绘任务 -setNeedsDisplay方法：标记为需要重绘，异步调用drawRect -setNeedsDisplayInRect:(CGRect)invalidRect方法：标记为需要局部重绘 （注意：sizeToFit会 自动调用sizeThatFits方法； sizeToFit不应该在子类中被重写，应该重写sizeThatFits） sizeThatFits传入的参数是receiver当前的size，返回一个适合的size sizeToFit可以被手动直接调用,注意(系统默认的一些控件可以通过调用sizeToFit方法使其有尺寸,egUIBarButtonItem,UITableView的组头,组尾,表头,表尾,,,……) sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己 layoutSubviews对subviews重新布局 layoutSubviews方法调用先于drawRect setNeedsLayout在receiver标上一个需要被重新布局的标记，在系统runloop的下一个周期自动调用layoutSubviews layoutIfNeeded方法如其名，UIKit会判断该receiver是否需要layout.根据Apple官方文档,layoutIfNeeded方法应该是这样的 layoutIfNeeded遍历的不是superview链，应该是subviews链 drawRect是对receiver的重绘，能获得context setNeedDisplay在receiver标上一个需要被重新绘图的标记，在下一个draw周期自动重绘，iphone device的刷新频率是60hz，也就是1/60秒后重绘 参考文档UIView常用的一些方法小记之setNeedsDisplay和setNeedsLayout]]></content>
      <categories>
        <category>iOS效率</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo教程]]></title>
    <url>%2F2018%2F05%2F03%2FHexo%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[配置Node.js环境Node.js: Node.js官网 下载成功之后是这样的一个文件: 安装 Node.js 和npm 终端下测试下Node.js是否可以使用: 1node -v 如果Node.js 成功安装，可以看到类似如下的信息: 12$ node -vv10.0.0 终端下测试下npm是否可以使用: 1npm -v 如果npm成功安装，可以看到类似如下的信息: 12$ npm -v5.6.0 全部完成上面的配置,已经完成第一步 搭建GitHub博客进入GitHub,我们新建一个名为用户名.github.io的仓库,用户名其实就是你自己GitHub用户名 安装Hexo 终端中执行npm install hexo-cli -g 桌面或者自己熟悉的地方,通过终端创建mkdirhexo文件夹 进入hexo文件夹,执行hexo init 完成之后执行下面方法:12hexo generate 创建静态页面 hexo server 启动服务 缩写hexo g | hexo s 登录本地localhost:4000 启动服务,会显示下面页面 接下来,我们就是把创建好的hexo项目,配置上传GitHub的前提条件 找到hexo文件夹下面的_config.yml文件 配置Hexo主题 把这段代码放置_config.yml文件的最后面,其中GitHub用户名是你自己在GitHub中创建的仓库对于的信息 12345deploy: type: git repository: github: https://github.com/GitHub用户名/GitHub用户名.github.io.git branch: master 这样我们就完成了对hexo的基础搭建和配置 同步GitHub 终端执行npm install hexo-deployer-git --save 完成上面的全部操作,我们博客基本完成,相应的主题配置自行百度,Google 开始同步12345hexo cleanhexo generatehexo deployer 缩写hexo d -g执行 浏览器中输入https://GitHub用户名.github.io,如果成功会显示上面同样的页面 最后 如果你已经看到这里,说明已经完成了对博客的搭建,我们就可以开心的撸博客了!!!]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
