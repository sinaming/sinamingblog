<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蜡笔小新Zzz</title>
  
  <subtitle>天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-04T03:29:40.199Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>蜡笔小新Zzz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS强制横屏实践</title>
    <link href="http://yoursite.com/2018/06/04/iOS%E5%BC%BA%E5%88%B6%E6%A8%AA%E5%B1%8F%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/06/04/iOS强制横屏实践/</id>
    <published>2018-06-04T03:05:58.000Z</published>
    <updated>2018-06-04T03:29:40.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>在开发视频播放器的时候,需要视频全屏播放同时还能响应手机旋转</p></blockquote><h2 id="所以"><a href="#所以" class="headerlink" title="所以"></a>所以</h2><blockquote><p>通过资料查找,分为几种方案</p></blockquote><p><strong>方案一</strong></p><blockquote><p><code>View</code>旋转</p></blockquote><p><strong>方案二</strong></p><blockquote><p>转场动画</p></blockquote><p><strong>方案三</strong></p><blockquote><p>强制横竖屏</p></blockquote><a id="more"></a><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><blockquote><p>今天就考虑直接使用<strong>强制横竖屏</strong>来完成播放器的全屏播放</p></blockquote><ul><li><p>General配置<br><img src="/2018/06/04/iOS强制横屏实践/横竖屏1.png" alt="General配置"></p></li><li><p>info.plist配置<br><img src="/2018/06/04/iOS强制横屏实践/横竖屏2.png" alt="info.plist配置"></p></li></ul><blockquote><p>横竖屏跳转的<code>Controller</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)interfaceOrientation:(UIInterfaceOrientation)orientation &#123;</span><br><span class="line">    if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123;</span><br><span class="line">        SEL selector             = NSSelectorFromString(@&quot;setOrientation:&quot;);</span><br><span class="line">        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];</span><br><span class="line">        [invocation setSelector:selector];</span><br><span class="line">        [invocation setTarget:[UIDevice currentDevice]];</span><br><span class="line">        int val                  = orientation;</span><br><span class="line">        // 从2开始是因为0 1 两个参数已经被selector和target占用</span><br><span class="line">        [invocation setArgument:&amp;val atIndex:2];</span><br><span class="line">        [invocation invoke];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重点,必须配置状态栏才能正确的跳转</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 跳转的Controller设置</span><br><span class="line">- (BOOL)shouldAutorotate &#123;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>响应事件调用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self interfaceOrientation:UIInterfaceOrientationPortrait];</span><br></pre></td></tr></table></figure><ul><li>一般我们都是<code>UITabBarController</code>和<code>UINavigationController</code>的结构来完成<code>App</code>的框架搭建</li></ul><blockquote><p>配置<code>UITabBarController</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)shouldAutorotate&#123;</span><br><span class="line">    return [self.selectedViewController shouldAutorotate];</span><br><span class="line">&#125;</span><br><span class="line">- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123;</span><br><span class="line">    return [self.selectedViewController supportedInterfaceOrientations];</span><br><span class="line">&#125;</span><br><span class="line">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123;</span><br><span class="line">    return [self.selectedViewController preferredInterfaceOrientationForPresentation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置<code>UINavigationController</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// viewDidLoad调用</span><br><span class="line">[[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications];</span><br><span class="line">    </span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(deviceOrientationDidChange) name:UIDeviceOrientationDidChangeNotification object:nil];</span><br><span class="line"></span><br><span class="line">// 方法一获取</span><br><span class="line">- (BOOL)shouldAutorotate&#123;</span><br><span class="line">    return [[self.viewControllers lastObject]shouldAutorotate];</span><br><span class="line">&#125;</span><br><span class="line">- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123;</span><br><span class="line">    return [[self.viewControllers lastObject]supportedInterfaceOrientations];</span><br><span class="line">&#125;</span><br><span class="line">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123;</span><br><span class="line">    return [[self.viewControllers lastObject] preferredInterfaceOrientationForPresentation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法二获取</span><br><span class="line">- (BOOL)shouldAutorotate &#123;</span><br><span class="line">    return [self.topViewController shouldAutorotate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</span><br><span class="line">    return [self.topViewController supportedInterfaceOrientations];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)deviceOrientationDidChange &#123;</span><br><span class="line">    NSLog(@&quot;NAV deviceOrientationDidChange:%ld&quot;,(long)[UIDevice currentDevice].orientation);</span><br><span class="line">    if([UIDevice currentDevice].orientation == UIDeviceOrientationPortrait) &#123;</span><br><span class="line">        [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationPortrait];</span><br><span class="line">        [self orientationChange:NO];</span><br><span class="line">        //注意： UIDeviceOrientationLandscapeLeft 与 UIInterfaceOrientationLandscapeRight</span><br><span class="line">    &#125; else if ([UIDevice currentDevice].orientation == UIDeviceOrientationLandscapeLeft) &#123;</span><br><span class="line">        [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationLandscapeRight];</span><br><span class="line">        [self orientationChange:YES];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)orientationChange:(BOOL)landscapeRight &#123;</span><br><span class="line">    CGFloat width = [UIScreen mainScreen].bounds.size.width;</span><br><span class="line">    CGFloat height = [UIScreen mainScreen].bounds.size.height;</span><br><span class="line"></span><br><span class="line">    if (landscapeRight) &#123;</span><br><span class="line">        [UIView animateWithDuration:0.2f animations:^&#123;</span><br><span class="line">            self.view.transform = CGAffineTransformMakeRotation(M_PI_2);</span><br><span class="line">            self.view.bounds = CGRectMake(0, 0, width, height);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [UIView animateWithDuration:0.2f animations:^&#123;</span><br><span class="line">            self.view.transform = CGAffineTransformMakeRotation(0);</span><br><span class="line">            self.view.bounds = CGRectMake(0, 0, width, height);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote><p>上面全部的代码配置好,iOS强制横屏就已经完成了,大伙自己实践一下!!!</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在开发视频播放器的时候,需要视频全屏播放同时还能响应手机旋转&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;所以&quot;&gt;&lt;a href=&quot;#所以&quot; class=&quot;headerlink&quot; title=&quot;所以&quot;&gt;&lt;/a&gt;所以&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;通过资料查找,分为几种方案&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;方案一&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;View&lt;/code&gt;旋转&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;方案二&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;转场动画&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;方案三&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;强制横竖屏&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://yoursite.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS仿淘宝详情页导航栏</title>
    <link href="http://yoursite.com/2018/06/02/iOS%E4%BB%BF%E6%B7%98%E5%AE%9D%E8%AF%A6%E6%83%85%E9%A1%B5%E5%AF%BC%E8%88%AA%E6%A0%8F/"/>
    <id>http://yoursite.com/2018/06/02/iOS仿淘宝详情页导航栏/</id>
    <published>2018-06-02T08:41:58.000Z</published>
    <updated>2018-06-02T09:11:54.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><blockquote><p>当看到好的App应用,都想好好的了解下他们的实现</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p>正常的App应用是不能分析App的结构的,所以我们只能借助越狱的手机,对App进行分析,如果没有越狱手机我们一样的可以分析App的结构</p></blockquote><ol><li><p><code>Mac</code>下载<code>PP助手</code>程序,再越狱应用中搜索<code>参考的App</code></p></li><li><p>下载<code>参考的App</code>,对<code>App</code>进行解压,获取应用安装包</p></li><li><p>安装工具,具体的工具自行搜索百度(<code>逆向分析工具</code>)</p></li><li><p>安装好工具,把应用安装包放入工具中,运行安装等等(更多的逆向自行搜索)</p></li></ol><a id="more"></a><ol start="5"><li>通过Xcode工具UI界面分析工具查看淘宝详情页的页面</li></ol><blockquote><p>了解,UI界面分析完成之后,大概知道了他的实现View,查看UI界面分析得到的淘宝详情页导航栏实现的View</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>开始我们的实现,如上的的分析,我们得到了淘宝详情页的大致结构,跳转页面隐藏系统导航栏,添加导航栏View</p></blockquote><p><strong>看代码</strong></p><h3 id="隐藏导航栏-第一步"><a href="#隐藏导航栏-第一步" class="headerlink" title="隐藏导航栏(第一步)"></a>隐藏导航栏(第一步)</h3><blockquote><p><code>UINavigationControllerDelegate</code>实现代理,侧滑的同时也不会隐藏导航栏的正确显示和隐藏</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    self.navigationController.delegate = self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated &#123;</span><br><span class="line">    // 判断要显示的控制器是否是自己</span><br><span class="line">    BOOL isShowHomePage = [viewController isKindOfClass:[self class]];</span><br><span class="line">    [self.navigationController setNavigationBarHidden:isShowHomePage animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建导航栏View-第二步"><a href="#创建导航栏View-第二步" class="headerlink" title="创建导航栏View(第二步)"></a>创建导航栏View(第二步)</h3><blockquote><p>创建导航栏View,里面放置详情页面需要的按钮信息和跳转逻辑,<code>Controller</code>添加完<code>UITableView</code>,只会添加导航栏View,他们都同样的添加的<code>Controller</code>的View上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  // tableView</span><br><span class="line">  [self.view addSubview:self.tableView];</span><br><span class="line"></span><br><span class="line">  self.tableView.tableHeaderView = self.tableHeadLabel;</span><br><span class="line">  // 导航栏View</span><br><span class="line">  [self.view addSubview:self.floatView];</span><br><span class="line"></span><br><span class="line">- (void)viewWillLayoutSubviews &#123;</span><br><span class="line">    [super viewWillLayoutSubviews];</span><br><span class="line">    // 让导航栏View显示最上层,backgroundView设置成透明</span><br><span class="line">    [self.view bringSubviewToFront:self.floatView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>完成上面的操作,是不能滑动tableView的</p></blockquote><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p><strong>分析iOS</strong>我们通过响应链知识,导航栏View重写<code>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</code>方法,具体看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">//    UIView *tmpView = [super hitTest:point withEvent:event];</span><br><span class="line">//    if (tmpView.superview == self) &#123;</span><br><span class="line">//        return nil;</span><br><span class="line">//    &#125;</span><br><span class="line">//    return tmpView;</span><br><span class="line">    </span><br><span class="line">//    处理的关键点在于判断条件</span><br><span class="line">//</span><br><span class="line">//    tmpView.superview == self!</span><br><span class="line">//</span><br><span class="line">//    如果需要穿透UIView，则变更为tmpView == self</span><br><span class="line">    </span><br><span class="line">    UIView *tmpView = [super hitTest:point withEvent:event];</span><br><span class="line">    if (tmpView == self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return tmpView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>完成上面的操作,这个手势滑动导航栏View,就能响应<code>tableView</code>的手势了</p><blockquote><p>上面的逻辑大致可以实现大部分功能了,所以多查查资料可以更好的提升自己的能力</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;当看到好的App应用,都想好好的了解下他们的实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;正常的App应用是不能分析App的结构的,所以我们只能借助越狱的手机,对App进行分析,如果没有越狱手机我们一样的可以分析App的结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Mac&lt;/code&gt;下载&lt;code&gt;PP助手&lt;/code&gt;程序,再越狱应用中搜索&lt;code&gt;参考的App&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载&lt;code&gt;参考的App&lt;/code&gt;,对&lt;code&gt;App&lt;/code&gt;进行解压,获取应用安装包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装工具,具体的工具自行搜索百度(&lt;code&gt;逆向分析工具&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装好工具,把应用安装包放入工具中,运行安装等等(更多的逆向自行搜索)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://yoursite.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发之UITableView滚动方向</title>
    <link href="http://yoursite.com/2018/05/29/iOS%E5%BC%80%E5%8F%91%E4%B9%8BUITableView%E6%BB%9A%E5%8A%A8%E6%96%B9%E5%90%91/"/>
    <id>http://yoursite.com/2018/05/29/iOS开发之UITableView滚动方向/</id>
    <published>2018-05-29T08:45:41.000Z</published>
    <updated>2018-05-29T08:48:17.344Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>iOS开发之<code>UITableView</code>, <code>UICollectionView</code>, <code>UIScrollview</code>,根据代理判断页面滚动方向</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;  </span><br><span class="line">   CGPoint point =  [scrollView.panGestureRecognizer translationInView:self.view];  </span><br><span class="line">    if (point.y &gt; 0 ) &#123;  </span><br><span class="line">        NSLog(@&quot;------往上滚动&quot;);  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">        NSLog(@&quot;------往下滚动&quot;);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;iOS开发之&lt;code&gt;UITableView&lt;/code&gt;, &lt;code&gt;UICollectionView&lt;/code&gt;, &lt;code&gt;UIScrollview&lt;/code&gt;,根据代理判断页面滚动方向&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)scrollViewDidScroll:(UIScrollView *)scrollView &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   CGPoint point =  [scrollView.panGestureRecognizer translationInView:self.view];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (point.y &amp;gt; 0 ) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;------往上滚动&amp;quot;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;else&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;------往下滚动&amp;quot;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS效率" scheme="http://yoursite.com/categories/iOS%E6%95%88%E7%8E%87/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>熟悉UIScrollView的contentSize,contentOffset,contentInset</title>
    <link href="http://yoursite.com/2018/05/17/%E7%86%9F%E6%82%89UIScrollView%E7%9A%84contentSize-contentOffset-contentInset/"/>
    <id>http://yoursite.com/2018/05/17/熟悉UIScrollView的contentSize-contentOffset-contentInset/</id>
    <published>2018-05-17T09:39:45.000Z</published>
    <updated>2018-05-17T09:54:24.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UIScrollView基础知识"><a href="#UIScrollView基础知识" class="headerlink" title="UIScrollView基础知识"></a>UIScrollView基础知识</h2><blockquote><p><code>UIScrollView</code>中的<code>contentSize</code>,<code>contentOffset</code>,<code>contentInset</code>的知识点熟悉</p></blockquote><h3 id="contentSize"><a href="#contentSize" class="headerlink" title="contentSize"></a>contentSize</h3><blockquote><p><code>contentSize</code>是<code>UIScrollView</code>和继承于<code>UIScrollView</code>的子控件的属性，<code>contentSize</code>是确定<code>UIScrollView</code>上<code>contentView</code>宽<code>（contentSize.width）</code>和高<code>（conteSize.height）</code>的属性。</p></blockquote><a id="more"></a><h3 id="contentOffset"><a href="#contentOffset" class="headerlink" title="contentOffset"></a>contentOffset</h3><blockquote><p><code>contentOffset</code>是<code>UIScrollView</code>和继承于<code>UIScrollView</code>的子控件的属性，<code>contentOffset</code>确定的是<code>UIScrollView</code>的顶点（左上角点）值相对于其父类视图的顶点值（即<code>frame.origin</code>）的距离</p></blockquote><h3 id="contentInset"><a href="#contentInset" class="headerlink" title="contentInset"></a>contentInset</h3><blockquote><p><code>contentInset</code>是<code>UIScrollView</code>和继承于<code>UIScrollView</code>的子控件的属性，<code>contentInset</code>确定的是<code>contenView</code>上下左右相对于<code>UIScrollView</code>扩展出来的区域大小。<code>contentInset</code>是<code>UIEdgeInsets</code>类型的，默认值为<code>UIEdgeInsetsZero</code>。</p></blockquote><h2 id="布局图"><a href="#布局图" class="headerlink" title="布局图"></a>布局图</h2><p><img src="/2018/05/17/熟悉UIScrollView的contentSize-contentOffset-contentInset/UIScrollView偏移图.png" alt="contentSize"></p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><blockquote><p><code>scrollView.contentInset</code>默认情况下其初始值都为0；当设置了初始值时（不为零），它相当于给<code>scrollView</code>的范围进行了扩大，并加了一堵墙，如果把<code>scrollView</code>中的图片理解为一个背景，将<code>scrollView</code>理解为一个镜头，通过改变<code>scrollView.contentOffset</code>的值就可以改变镜头的初始化位置，但是当你设置了<code>scrollView.contentInset</code> 后如果其改变的位置超过了你加的范围它的镜头最多移到你加范围的最大位置</p></blockquote><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.cnblogs.com/Jenaral/p/5540422.html" target="_blank" rel="noopener">熟悉UIScrollView的contentSize,contentOffset,contentInset</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;UIScrollView基础知识&quot;&gt;&lt;a href=&quot;#UIScrollView基础知识&quot; class=&quot;headerlink&quot; title=&quot;UIScrollView基础知识&quot;&gt;&lt;/a&gt;UIScrollView基础知识&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;UIScrollView&lt;/code&gt;中的&lt;code&gt;contentSize&lt;/code&gt;,&lt;code&gt;contentOffset&lt;/code&gt;,&lt;code&gt;contentInset&lt;/code&gt;的知识点熟悉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;contentSize&quot;&gt;&lt;a href=&quot;#contentSize&quot; class=&quot;headerlink&quot; title=&quot;contentSize&quot;&gt;&lt;/a&gt;contentSize&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;contentSize&lt;/code&gt;是&lt;code&gt;UIScrollView&lt;/code&gt;和继承于&lt;code&gt;UIScrollView&lt;/code&gt;的子控件的属性，&lt;code&gt;contentSize&lt;/code&gt;是确定&lt;code&gt;UIScrollView&lt;/code&gt;上&lt;code&gt;contentView&lt;/code&gt;宽&lt;code&gt;（contentSize.width）&lt;/code&gt;和高&lt;code&gt;（conteSize.height）&lt;/code&gt;的属性。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS基础" scheme="http://yoursite.com/categories/iOS%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS熟悉UIEdgeInsetsMake使用</title>
    <link href="http://yoursite.com/2018/05/13/iOS%E7%86%9F%E6%82%89UIEdgeInsetsMake%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/05/13/iOS熟悉UIEdgeInsetsMake使用/</id>
    <published>2018-05-13T07:28:14.000Z</published>
    <updated>2018-05-15T06:58:38.159Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理解UIEdgeInsetsMake"><a href="#理解UIEdgeInsetsMake" class="headerlink" title="理解UIEdgeInsetsMake"></a>理解UIEdgeInsetsMake</h2><blockquote><p><code>Creates an edge inset for a button or view.</code>开发文档中显示</p></blockquote><blockquote><p>定义调用方法<code>UIEdgeInsets UIEdgeInsetsMake(CGFloat top, CGFloat left, CGFloat bottom, CGFloat right)</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct UIEdgeInsets &#123;</span><br><span class="line">    CGFloat top, left, bottom, right;  // specify amount to inset (positive) for each of the edges. values can be negative to &apos;outset&apos;</span><br><span class="line">&#125; UIEdgeInsets;</span><br></pre></td></tr></table></figure><p><strong>简单点说就是对视图的偏移</strong></p><h2 id="看黑板-使用说明"><a href="#看黑板-使用说明" class="headerlink" title="看黑板,使用说明"></a>看黑板,使用说明</h2><ol><li><p>定义一个<code>UIButton</code>,对它的子视图对它进行布局</p></li><li><p>按钮<code>titleLabel</code>的<code>titleEdgeInsets</code></p></li><li><p>按钮<code>imageView</code>的<code>imageEdgeInsets</code></p></li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[btn setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn.imageView.frame.size.width, 0, 0)];</span><br><span class="line">[btn setImageEdgeInsets:UIEdgeInsetsMake(0, 0, 0, -btn.titleLabel.intrinsicContentSize.width)];</span><br></pre></td></tr></table></figure><blockquote><p><strong>按钮图片文字居中</strong><br><img src="/2018/05/13/iOS熟悉UIEdgeInsetsMake使用/按钮图片文字居中.png" alt="按钮图片文字居中"></p></blockquote><h3 id="imageView在左，titleLabel在右-UIButton系统默认"><a href="#imageView在左，titleLabel在右-UIButton系统默认" class="headerlink" title="imageView在左，titleLabel在右 UIButton系统默认"></a><code>imageView</code>在左，<code>titleLabel</code>在右 <code>UIButton</code>系统默认</h3><h3 id="imageView在上，titleLabel在下"><a href="#imageView在上，titleLabel在下" class="headerlink" title="imageView在上，titleLabel在下"></a><code>imageView</code>在上，<code>titleLabel</code>在下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[btn setTitleEdgeInsets:UIEdgeInsetsMake(btn.titleLabel.intrinsicContentSize.height + 10, -btn.imageView.frame.size.width, 0, 0)];</span><br><span class="line">[btn setImageEdgeInsets:UIEdgeInsetsMake(0, 0, btn.imageView.frame.size.height + 10, -btn.titleLabel.intrinsicContentSize.width)];</span><br><span class="line">考虑间隙对图片和文字加了10的偏移量</span><br></pre></td></tr></table></figure><blockquote><p><strong>按钮图片在上文字在下</strong><br><img src="/2018/05/13/iOS熟悉UIEdgeInsetsMake使用/按钮图片在上文字在下.png" alt="按钮图片在上文字在下"></p></blockquote><h3 id="imageView在下，titleLabel在上"><a href="#imageView在下，titleLabel在上" class="headerlink" title="imageView在下，titleLabel在上"></a><code>imageView</code>在下，<code>titleLabel</code>在上</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[btn setTitleEdgeInsets:UIEdgeInsetsMake(-btn.titleLabel.intrinsicContentSize.height - 10, -btn.imageView.frame.size.width, 0, 0)];</span><br><span class="line">[btn setImageEdgeInsets:UIEdgeInsetsMake(0, 0, -btn.imageView.frame.size.height - 10, -btn.titleLabel.intrinsicContentSize.width)];</span><br></pre></td></tr></table></figure><blockquote><p><strong>按钮图片在下文字在上</strong><br><img src="/2018/05/13/iOS熟悉UIEdgeInsetsMake使用/按钮图片在下文字在上.png" alt="按钮图片在下文字在上"></p></blockquote><h3 id="imageView在右，titleLabel在左"><a href="#imageView在右，titleLabel在左" class="headerlink" title="imageView在右，titleLabel在左"></a><code>imageView</code>在右，<code>titleLabel</code>在左</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[btn setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn.imageView.frame.size.width, 0, btn.imageView.frame.size.width)];</span><br><span class="line">[btn setImageEdgeInsets:UIEdgeInsetsMake(0, btn.titleLabel.intrinsicContentSize.width, 0, -btn.titleLabel.intrinsicContentSize.width)];</span><br></pre></td></tr></table></figure><blockquote><p><strong>按钮图片在右文字在左</strong><br><img src="/2018/05/13/iOS熟悉UIEdgeInsetsMake使用/按钮图片在右文字在左.png" alt="按钮图片在右文字在左"></p></blockquote><h3 id="imageView靠右，titleLabel靠左"><a href="#imageView靠右，titleLabel靠左" class="headerlink" title="imageView靠右，titleLabel靠左"></a><code>imageView</code>靠右，<code>titleLabel</code>靠左</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[btn setImageEdgeInsets:UIEdgeInsetsMake(0, btn.frame.size.width - btn.imageView.frame.size.width, 0, -btn.titleLabel.intrinsicContentSize.width)];</span><br><span class="line">[btn setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn.imageView.frame.size.width, 0, btn.frame.size.width - btn.titleLabel.intrinsicContentSize.width)];</span><br></pre></td></tr></table></figure><p><strong><code>intrinsicContentSize</code>是iOS 8时候获取的属性</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;理解UIEdgeInsetsMake&quot;&gt;&lt;a href=&quot;#理解UIEdgeInsetsMake&quot; class=&quot;headerlink&quot; title=&quot;理解UIEdgeInsetsMake&quot;&gt;&lt;/a&gt;理解UIEdgeInsetsMake&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Creates an edge inset for a button or view.&lt;/code&gt;开发文档中显示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;定义调用方法&lt;code&gt;UIEdgeInsets UIEdgeInsetsMake(CGFloat top, CGFloat left, CGFloat bottom, CGFloat right)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef struct UIEdgeInsets &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CGFloat top, left, bottom, right;  // specify amount to inset (positive) for each of the edges. values can be negative to &amp;apos;outset&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; UIEdgeInsets;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;简单点说就是对视图的偏移&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;看黑板-使用说明&quot;&gt;&lt;a href=&quot;#看黑板-使用说明&quot; class=&quot;headerlink&quot; title=&quot;看黑板,使用说明&quot;&gt;&lt;/a&gt;看黑板,使用说明&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义一个&lt;code&gt;UIButton&lt;/code&gt;,对它的子视图对它进行布局&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按钮&lt;code&gt;titleLabel&lt;/code&gt;的&lt;code&gt;titleEdgeInsets&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按钮&lt;code&gt;imageView&lt;/code&gt;的&lt;code&gt;imageEdgeInsets&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://yoursite.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOSPush任意新页面</title>
    <link href="http://yoursite.com/2018/05/10/iOSPush%E4%BB%BB%E6%84%8F%E6%96%B0%E9%A1%B5%E9%9D%A2/"/>
    <id>http://yoursite.com/2018/05/10/iOSPush任意新页面/</id>
    <published>2018-05-10T02:19:01.000Z</published>
    <updated>2018-05-10T02:25:03.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="APP任意push新页面"><a href="#APP任意push新页面" class="headerlink" title="APP任意push新页面"></a>APP任意push新页面</h2><blockquote><p>平时<code>push</code>一般都是<code>[self.navigationController pushViewController:newVC animated:YES];</code></p></blockquote><h2 id="看黑板"><a href="#看黑板" class="headerlink" title="看黑板"></a>看黑板</h2><blockquote><p>现在通过<code>UIApplication</code>添加分类获取<code>UINavigationController</code>来实现<code>push</code></p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (UIWindow *)mainWindow &#123;</span><br><span class="line">    return self.delegate.window;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIViewController *)visibleViewController &#123;</span><br><span class="line">    UIViewController *rootViewController = [self.mainWindow rootViewController];</span><br><span class="line">    return [self getVisibleViewControllerFrom:rootViewController];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIViewController *) getVisibleViewControllerFrom:(UIViewController *) vc &#123;</span><br><span class="line">    if ([vc isKindOfClass:[UINavigationController class]]) &#123;</span><br><span class="line">        return [self getVisibleViewControllerFrom:[((UINavigationController *) vc) visibleViewController]];</span><br><span class="line">    &#125; else if ([vc isKindOfClass:[UITabBarController class]]) &#123;</span><br><span class="line">        return [self getVisibleViewControllerFrom:[((UITabBarController *) vc) selectedViewController]];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (vc.presentedViewController) &#123;</span><br><span class="line">            return [self getVisibleViewControllerFrom:vc.presentedViewController];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return vc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UINavigationController *)visibleNavigationController &#123;</span><br><span class="line">    return [[self visibleViewController] navigationController];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UINavigationController *navigationController = [[UIApplication sharedApplication] visibleNavigationController];</span><br><span class="line">[navigationController pushViewController:newVC animated:YES];</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://blog.csdn.net/qq_34047841/article/details/59482767" target="_blank" rel="noopener">iOS - APP任意push新页面那些事</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;APP任意push新页面&quot;&gt;&lt;a href=&quot;#APP任意push新页面&quot; class=&quot;headerlink&quot; title=&quot;APP任意push新页面&quot;&gt;&lt;/a&gt;APP任意push新页面&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;平时&lt;code&gt;push&lt;/code&gt;一般都是&lt;code&gt;[self.navigationController pushViewController:newVC animated:YES];&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;看黑板&quot;&gt;&lt;a href=&quot;#看黑板&quot; class=&quot;headerlink&quot; title=&quot;看黑板&quot;&gt;&lt;/a&gt;看黑板&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;现在通过&lt;code&gt;UIApplication&lt;/code&gt;添加分类获取&lt;code&gt;UINavigationController&lt;/code&gt;来实现&lt;code&gt;push&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://yoursite.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Masonry设置UIScrollView的contentSize,实现复杂页面开发</title>
    <link href="http://yoursite.com/2018/05/08/Masonry%E8%AE%BE%E7%BD%AEUIScrollView%E7%9A%84contentSize/"/>
    <id>http://yoursite.com/2018/05/08/Masonry设置UIScrollView的contentSize/</id>
    <published>2018-05-08T07:09:22.000Z</published>
    <updated>2018-05-08T07:44:05.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>开发项目中,遇到复杂页面开发,今天就使用<code>Masonry+UIScrollView</code>实现复杂页面开发</p></blockquote><h2 id="实例图"><a href="#实例图" class="headerlink" title="实例图"></a>实例图</h2><p><img src="/2018/05/08/Masonry设置UIScrollView的contentSize/复杂UIScrollView.gif" alt="复杂UIScrollView"></p><a id="more"></a><ul><li>通过看上面的效果图,是否觉得这页面是否很复杂,不同的有不同的解答方法,今天,我就介绍下我个人的解决方案</li></ul><h2 id="看黑板"><a href="#看黑板" class="headerlink" title="看黑板"></a>看黑板</h2><blockquote><p>首先,我们先分析一波这个页面的具体内容和复杂程度,是否考虑使用<code>UITableView</code>或者<code>UIScrollView</code>来完成这个需求,我相信<code>UITableView</code>也是能实现这个方案,可能是我太懒!</p></blockquote><blockquote><p>我们可以分为三个模块,从顶部到联系客服下面的横线为第一个模块,简称<code>TopView</code>,第二个模块图文详情模块,简称<code>CenterView</code>,第三个模块腕表参数模块,简称<code>BottomView</code>,命名请忽视,我们可以自定义三个View,分别实现里面的内容显示</p></blockquote><p><strong><code>TopView</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[self addSubview:self.testLabel];</span><br><span class="line">[self.testLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.left.right.mas_equalTo(self).offset(0);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[self addSubview:self.testButton];</span><br><span class="line">[self.testButton mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.mas_equalTo(self.testLabel.mas_bottom).offset(0);</span><br><span class="line">    make.left.right.mas_equalTo(self).offset(0);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[self addSubview:self.testImageView];</span><br><span class="line">[self.testImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.mas_equalTo(self.testButton.mas_bottom).offset(0);</span><br><span class="line">    make.left.right.mas_equalTo(self).offset(0);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 重点,必须设置这个约束,确定底部的位置</span><br><span class="line">[self mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.bottom.mas_equalTo(self.testImageView.mas_bottom).offset(0);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><ul><li><code>CenterView</code>和<code>BottomView</code>同样设置从顶部和底部控件位置,确定当前<code>containerView</code>(容器)底部约束<strong>这个尤为重要</strong></li></ul><p><strong>Controller</strong></p><blockquote><p>父视图<br><code>@property (nonatomic, strong) UIScrollView *scrollView;</code></p></blockquote><blockquote><p>容器视图<br><code>@property (nonatomic, strong) UIView *containerView;</code></p></blockquote><blockquote><p>分别创建好这两个</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[self.view addSubview:self.scrollView];</span><br><span class="line">[self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.edges.equalTo(self.view);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[self.scrollView addSubview:self.containerView];</span><br><span class="line">[self.containerView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.edges.equalTo(self.scrollView);</span><br><span class="line">    make.width.equalTo(self.scrollView);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[self.containerView addSubview:self.topView];</span><br><span class="line">[self.topView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.left.right.top.mas_equalTo(self.containerView).offset(0);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[self.containerView addSubview:self.centerView];</span><br><span class="line">[self.centerView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.mas_equalTo(self.topView.mas_bottom).offset(0);</span><br><span class="line">    make.left.right.mas_equalTo(self.containerView).offset(0);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[self.containerView addSubview:self.bottomView];</span><br><span class="line">[self.bottomView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.mas_equalTo(self.centerView.mas_bottom).offset(0);</span><br><span class="line">    make.left.right.bottom.mas_equalTo(self.containerView).offset(0);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 这个很重要,controller里面同样需要确定containerView(容器)的底部约束</span><br><span class="line">[self.containerView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">   make.bottom.mas_equalTo(self.bottomView.mas_bottom).offset(0);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li>布局页面我们已经全部都完成了,就是数据填充问题了,这样我们实行UIScrollView复杂页面开发的实现</li></ul><p><strong>重要的事情说三遍</strong></p><ol><li><p>自定义<code>View</code>的子控件,约束必须是从<code>top</code>到<code>bottom</code>位置必须确定,接着确定自定义<code>View</code>的底部约束(就是自定义<code>View</code>底部控件的<code>bottom</code>的约束)</p></li><li><p>自定义<code>View</code>的子控件,约束必须是从<code>top</code>到<code>bottom</code>位置必须确定,接着确定自定义<code>View</code>的底部约束(就是自定义<code>View</code>底部控件的<code>bottom</code>的约束)</p></li><li><p>自定义<code>View</code>的子控件,约束必须是从<code>top</code>到<code>bottom</code>位置必须确定,接着确定自定义<code>View</code>的底部约束(就是自定义<code>View</code>底部控件的<code>bottom</code>的约束)</p></li></ol><h2 id="修改View约束动画"><a href="#修改View约束动画" class="headerlink" title="修改View约束动画"></a>修改<code>View</code>约束动画</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)updateConstraints &#123;</span><br><span class="line">    // remake会将之前的全部移除，然后重新添加</span><br><span class="line">    __weak __typeof(self) weakSelf = self;</span><br><span class="line">    [self.testButton mas_remakeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.top.mas_equalTo(self.testLabel.mas_bottom).offset(0);</span><br><span class="line">        make.left.right.mas_equalTo(self).offset(0);</span><br><span class="line">        if (weakSelf.isExpanded) &#123;</span><br><span class="line">            make.height.mas_equalTo(200);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            make.height.mas_equalTo(40);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [super updateConstraints];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 响应时间处理</span><br><span class="line">- (void)onGrowButtonTaped:(UIButton *)sender &#123;</span><br><span class="line">    self.isExpanded = !self.isExpanded;</span><br><span class="line">    if (!self.isExpanded) &#123;</span><br><span class="line">        [self.testButton setTitle:@&quot;点我展开&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self.testButton setTitle:@&quot;点我收起&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 告诉self.view约束需要更新</span><br><span class="line">    [self setNeedsUpdateConstraints];</span><br><span class="line">    // 调用此方法告诉self.view检测是否需要更新约束，若需要则更新，下面添加动画效果才起作用</span><br><span class="line">    [self updateConstraintsIfNeeded];</span><br><span class="line"></span><br><span class="line">    [UIView animateWithDuration:0.3 animations:^&#123;</span><br><span class="line">        [self layoutIfNeeded];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;开发项目中,遇到复杂页面开发,今天就使用&lt;code&gt;Masonry+UIScrollView&lt;/code&gt;实现复杂页面开发&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;实例图&quot;&gt;&lt;a href=&quot;#实例图&quot; class=&quot;headerlink&quot; title=&quot;实例图&quot;&gt;&lt;/a&gt;实例图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2018/05/08/Masonry设置UIScrollView的contentSize/复杂UIScrollView.gif&quot; alt=&quot;复杂UIScrollView&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://yoursite.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Masonry自适应tableHeaderView</title>
    <link href="http://yoursite.com/2018/05/05/Masonry%E8%87%AA%E9%80%82%E5%BA%94tableHeaderView/"/>
    <id>http://yoursite.com/2018/05/05/Masonry自适应tableHeaderView/</id>
    <published>2018-05-05T07:40:45.000Z</published>
    <updated>2018-05-30T07:12:44.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如题"><a href="#如题" class="headerlink" title="如题"></a>如题</h2><blockquote><p>从苹果开发约束,方便了我们快速适配iPhone手机,看到<code>Masonry</code>之后,我们就想要适配所有开发中所遇到的问题,今天就适配<code>Masonry</code>自适应<code>tableHeaderView</code></p></blockquote><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>如果使用frame,计算的话肯定也是可以达到相同结果的,可是<code>麻烦</code>,所以今天就使用<code>Masonry</code>来完成这个需求</p><ul><li>首先, 我们一般都是自定义<code>View</code>,在这个<code>View</code>设置好约束</li></ul><a id="more"></a><p><strong>重要</strong></p><ul><li>这个自定义<code>View</code>,里面的子控件一定要有从<code>top</code>到<code>bottom</code>连起来的那一条线,就像盖房子一样的,第一个子控件到最后的个子控件,让<code>tableHeaderView</code>知道<code>top</code>到<code>bottom</code>的位置</li></ul><h2 id="自定义View代码"><a href="#自定义View代码" class="headerlink" title="自定义View代码"></a>自定义<code>View</code>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 这个是第一个子控件</span><br><span class="line">[self addSubview:self.oneLabel];</span><br><span class="line">[self.oneLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.left.right.mas_equalTo(self).offset(0);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 这个是第二个子控件</span><br><span class="line">[self addSubview:self.oneImageView];</span><br><span class="line">[self.oneImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.mas_equalTo(self.oneLabel.mas_bottom).offset(0);</span><br><span class="line">    make.left.right.mas_equalTo(self).offset(0);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 重点,必须设置这个约束,告诉当前view的位置</span><br><span class="line">[self mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.bottom.mas_equalTo(self.oneImageView.mas_bottom).offset(0);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="Controller代码"><a href="#Controller代码" class="headerlink" title="Controller代码"></a><code>Controller</code>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 必须给headerView设置宽度,不然headView是不知道到底有宽</span><br><span class="line">self.tableView.tableHeaderView = self.headView;</span><br><span class="line">[self.headView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.width.equalTo(self.tableView);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><blockquote><p>如果确定子控件底部到父视图的位置,就不需要设置父视图底部位置,如果不确定底部位置就需要设置父视图底部位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[self addSubview:self.oneImageView];</span><br><span class="line">[self.oneImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.mas_equalTo(self.oneLabel.mas_bottom).offset(0);</span><br><span class="line">    make.left.right.bottom.mas_equalTo(self).offset(0);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 重点,必须设置这个约束,告诉当前view的位置</span><br><span class="line">//[self mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">//    make.bottom.mas_equalTo(self.oneImageView.mas_bottom).offset(0);</span><br><span class="line">//&#125;];</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="/2018/05/05/Masonry自适应tableHeaderView/tableHeaderView.gif" alt="Masonry"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如题&quot;&gt;&lt;a href=&quot;#如题&quot; class=&quot;headerlink&quot; title=&quot;如题&quot;&gt;&lt;/a&gt;如题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;从苹果开发约束,方便了我们快速适配iPhone手机,看到&lt;code&gt;Masonry&lt;/code&gt;之后,我们就想要适配所有开发中所遇到的问题,今天就适配&lt;code&gt;Masonry&lt;/code&gt;自适应&lt;code&gt;tableHeaderView&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;解答&quot;&gt;&lt;a href=&quot;#解答&quot; class=&quot;headerlink&quot; title=&quot;解答&quot;&gt;&lt;/a&gt;解答&lt;/h2&gt;&lt;p&gt;如果使用frame,计算的话肯定也是可以达到相同结果的,可是&lt;code&gt;麻烦&lt;/code&gt;,所以今天就使用&lt;code&gt;Masonry&lt;/code&gt;来完成这个需求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先, 我们一般都是自定义&lt;code&gt;View&lt;/code&gt;,在这个&lt;code&gt;View&lt;/code&gt;设置好约束&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://yoursite.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Hexo插入图片</title>
    <link href="http://yoursite.com/2018/05/05/Hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2018/05/05/Hexo插入图片/</id>
    <published>2018-05-05T02:10:12.000Z</published>
    <updated>2018-05-05T02:31:31.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>当我们想在博客上上传图片,如果直接引用本地图片,会存在很多问题,图片损坏等</p></blockquote><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul><li><p>在<code>hexo</code>文件夹中找到<code>_config.yml</code>里的<code>post_asset_folder</code>:这个选项设置为<code>true</code></p></li><li><p>在<code>hexo</code>目录下执行这样一句话<code>npm install hexo-asset-image --save</code>命令,来安装一个可以上传图片的插件</p></li></ul><a id="more"></a><ul><li><p>命令创建<code>hexo -n xxxx.md</code>,执行完成之后,会在<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹</p></li><li><p>最后把图片复杂到<code>xxxx.md</code>的文件夹中,按照这样的方式<code>![你想输入的替代文字](xxxx/图片名.jpg)</code></p></li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="/2018/05/05/Hexo插入图片/phone.jpg" alt="phone"></p><blockquote><p>如果完成上面操作,会实现显示自己添加的图片,说明已经完成</p></blockquote><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://blog.csdn.net/sugar_rainbow/article/details/57415705" target="_blank" rel="noopener">hexo生成博文插入图片</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;当我们想在博客上上传图片,如果直接引用本地图片,会存在很多问题,图片损坏等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;解决&quot;&gt;&lt;a href=&quot;#解决&quot; class=&quot;headerlink&quot; title=&quot;解决&quot;&gt;&lt;/a&gt;解决&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;hexo&lt;/code&gt;文件夹中找到&lt;code&gt;_config.yml&lt;/code&gt;里的&lt;code&gt;post_asset_folder&lt;/code&gt;:这个选项设置为&lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;hexo&lt;/code&gt;目录下执行这样一句话&lt;code&gt;npm install hexo-asset-image --save&lt;/code&gt;命令,来安装一个可以上传图片的插件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Hexo教程" scheme="http://yoursite.com/categories/Hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>iOS偷懒_效率</title>
    <link href="http://yoursite.com/2018/05/04/iOS%E5%81%B7%E6%87%92-%E6%95%88%E7%8E%87/"/>
    <id>http://yoursite.com/2018/05/04/iOS偷懒-效率/</id>
    <published>2018-05-04T03:05:36.000Z</published>
    <updated>2018-05-04T05:04:09.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="import导入pod第三方库不提示问题"><a href="#import导入pod第三方库不提示问题" class="headerlink" title="import导入pod第三方库不提示问题"></a><code>import</code>导入<code>pod</code>第三方库不提示问题</h2><ol><li><p>选择<code>target</code> &gt; <code>BuildSettings</code> &gt; <code>search Paths</code>下的<code>User Header Search Paths</code></p></li><li><p>双击后面的空白区域</p></li><li><p>点击”+”号添加一项:并且输入:<code>$(PODS_ROOT)</code>,选择:<code>recursive</code>(会在相应的目录递归搜索文件)</p></li></ol><a id="more"></a><h2 id="添加pch文件"><a href="#添加pch文件" class="headerlink" title="添加pch文件"></a>添加<code>pch</code>文件</h2><ol><li><p><code>Xcode</code>正确创建<code>pch</code>文件</p></li><li><p>选择<code>target</code> &gt; <code>BuildSettings</code> &gt; <code>Apple LLVM 8.0 -Language</code>下的<code>Prefix Header</code>(或者搜索<code>Prefix Header</code>)</p></li><li><p>双击后面的空白区域</p></li><li><p>点击”+”号添加一项:并且输入:<code>$(SRCROOT)/项目中创建.pch</code>,选择:<code>recursive</code>(会在相应的目录递归搜索文件)</p></li><li><p><code>Precompile Prefix Header</code>为<code>YES</code>,预编译后的pch文件缓存起来</p></li></ol><h2 id="扩展随机颜色"><a href="#扩展随机颜色" class="headerlink" title="扩展随机颜色"></a>扩展随机颜色</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[UIColor colorWithRed:arc4random_uniform(255) / 255.0 green:arc4random_uniform(255) / 255.0 blue:arc4random_uniform(255) / 255.0 alpha:1];</span><br></pre></td></tr></table></figure><h2 id="UIView常用setNeedsDisplay和setNeedsLayout"><a href="#UIView常用setNeedsDisplay和setNeedsLayout" class="headerlink" title="UIView常用setNeedsDisplay和setNeedsLayout"></a>UIView常用setNeedsDisplay和setNeedsLayout</h2><p><strong>UIView的setNeedsDisplay和setNeedsLayout方法</strong></p><blockquote><p>首先两个方法都是异步执行的。而<code>setNeedsDisplay</code>会调用自动调用<code>drawRect</code>方法，这样可以拿到<code>UIGraphicsGetCurrentContext</code>，就可以画画了。而<code>setNeedsLayout</code>会默认调用<code>layoutSubViews</code>，就可以处理子视图中的一些数据。</p></blockquote><blockquote><p>综上所诉，<code>setNeedsDisplay</code>方便绘图，而<code>layoutSubViews</code>方便出来数据。</p></blockquote><p><code>layoutSubviews</code>在以下情况下会被调用：</p><ul><li><code>init</code>初始化不会触发<code>layoutSubviews</code>。</li><li><code>addSubview</code>会触发<code>layoutSubviews</code>。</li><li>设置<code>view</code>的<code>Frame</code>会触发<code>layoutSubviews</code>，当然前提是<code>frame</code>的值设置前后发生了变化。</li><li>滚动一个<code>UIScrollView</code>会触发<code>layoutSubviews</code>。</li><li>旋转<code>Screen</code>会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件。</li><li>改变一个<code>UIView</code>大小的时候也会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件。</li><li>直接调用<code>setLayoutSubviews</code>。</li></ul><p><code>drawRect</code>在以下情况下会被调用：</p><ul><li>如果在<code>UIView</code>初始化时没有设置<code>rect</code>大小，将直接导致<code>drawRect</code>不被自动调用。<code>drawRect</code>调用是在<code>Controller-&gt;loadView, Controller-&gt;viewDidLoad</code>两方法之后掉用的.所以不用担心在控制器中,这些<code>View</code>的<code>drawRect</code>就开始画了.这样可以在控制器中设置一些值给<code>View</code>(如果这些<code>View draw</code>的时候需要用到某些变量值).</li><li>该方法在调用<code>sizeToFit</code>后被调用，所以可以先调用<code>sizeToFit</code>计算出<code>size</code>。然后系统自动调用<code>drawRect:</code>方法。</li><li>通过设置<code>contentMode</code>属性值为<code>UIViewContentModeRedraw</code>。那么将在每次设置或更改<code>frame</code>的时候自动调用<code>drawRect:</code>。</li><li>直接调用<code>setNeedsDisplay</code>，或者<code>setNeedsDisplayInRect:</code>触发<code>drawRect:</code>，但是有个前提条件是<code>rect</code>不能为0。</li><li>以上1,2推荐；而3,4不提倡</li></ul><p><code>drawRect</code>方法使用注意点：</p><ul><li>若使用<code>UIView</code>绘图，只能在<code>drawRect：</code>方法中获取相应的<code>contextRef</code>并绘图。如果在其他方法中获取将获取到一个<code>invalidate</code>的<code>ref</code>并且不能用于画图。<code>drawRect：</code>方法不能手动显示调用，必须通过调用<code>setNeedsDisplay</code> 或者 <code>setNeedsDisplayInRect</code>，让系统自动调该方法。</li><li>若使用<code>calayer</code>绘图，只能在<code>drawInContext:</code>中（类似于<code>drawRect</code>）绘制，或者在<code>delegate</code>中的相应方法绘制。同样也是调用<code>setNeedDisplay</code>等间接调用以上方法</li><li>若要实时画图，不能使用<code>gestureRecognizer</code>，只能使用<code>touchbegan</code>等方法来掉用<code>setNeedsDisplay</code>实时刷新屏幕</li></ul><h2 id="UIView调用"><a href="#UIView调用" class="headerlink" title="UIView调用"></a>UIView调用</h2><blockquote><p><code>-(void)layoutSubviews</code></p></blockquote><blockquote><p><code>-(void)layoutIfNeeded</code></p></blockquote><blockquote><p><code>-(void)setNeedsLayout</code></p></blockquote><blockquote><p><code>-(CGSize)sizeThatFits:(CGSize)size</code></p></blockquote><blockquote><p><code>-(void)sizeToFit</code></p></blockquote><blockquote><p><code>-(void)setNeedsDisplay</code></p></blockquote><blockquote><p><code>-(void)drawRect</code></p></blockquote><h3 id="layoutSubviews在以下情况下会被调用-被触发？？"><a href="#layoutSubviews在以下情况下会被调用-被触发？？" class="headerlink" title="layoutSubviews在以下情况下会被调用/被触发？？"></a><code>layoutSubviews</code>在以下情况下会被调用/被触发？？</h3><ol><li><p><code>init</code>初始化不会触发<code>layoutSubviews</code>，但是是用<code>initWithFrame</code>进行初始化时，当<code>rect</code>的值 非<code>CGRectZero</code>时,也会触发。</p></li><li><p><code>addSubview</code>会触发<code>layoutSubviews</code></p></li><li><p>设置<code>view</code>的<code>Frame</code>会触发<code>layoutSubviews</code>，当然前提是<code>frame</code>的值设置前后发生了变化</p></li><li><p>滚动一个<code>UIScrollView</code>会触发<code>layoutSubviews</code></p></li><li><p>旋转<code>Screen</code>会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件</p></li><li><p>改变一个<code>UIView</code>大小的时候也会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件</p></li></ol><p><strong>(在苹果的官方文档中强调)</strong></p><p><code>You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.layoutSubviews</code>,(当我们在某个类的内部调整子视图位置时，需要调用。反过来的意思就是说：如果你想要在外部设置<code>subviews</code>的位置，就不要重写。)</p><h2 id="刷新子对象布局"><a href="#刷新子对象布局" class="headerlink" title="刷新子对象布局??"></a>刷新子对象布局??</h2><h3 id="什么时候，需要重写？"><a href="#什么时候，需要重写？" class="headerlink" title="什么时候，需要重写？"></a>什么时候，需要重写？</h3><blockquote><p>view是系统的，不需要重写 <code>- (void)layoutSubviews</code></p></blockquote><blockquote><p>view是自定义的，需要重写  <code>- (void)layoutSubviews</code></p></blockquote><blockquote><p><code>-layoutSubviews</code>方法：这个方法，默认没有做任何事情，需要子类进行重写，自定义<code>view</code>时，手动重写，这里面只能写<code>subview</code>的<code>frame</code>限制。</p></blockquote><h3 id="手动调用这个方法，系统默认-我们不能手动直接调用这个方法，这能通过下列两种方式，调用-触发-void-layoutSubviews方法"><a href="#手动调用这个方法，系统默认-我们不能手动直接调用这个方法，这能通过下列两种方式，调用-触发-void-layoutSubviews方法" class="headerlink" title="手动调用这个方法，系统默认 我们不能手动直接调用这个方法，这能通过下列两种方式，调用/触发 - (void)layoutSubviews方法"></a>手动调用这个方法，系统默认 我们不能手动直接调用这个方法，这能通过下列两种方式，调用/触发 <code>- (void)layoutSubviews</code>方法</h3><blockquote><p><code>-setNeedsLayout</code>方法： 标记为需要重新布局，告诉系统未来某个时间点异步调用。不立即刷新，但<code>layoutSubviews</code>一定会被调用。</p></blockquote><blockquote><p><code>-layoutIfNeeded</code>方法：如果，有需要刷新的标记，立即调用<code>layoutSubviews</code>进行布局（如果没有标记，不会调用<code>layoutSubviews</code>）</p></blockquote><blockquote><p>若需要立即刷新<code>view</code>的<code>frame</code>更改：（同时调用，注意先后顺序）</p></blockquote><blockquote><p>先调用<code>[view setNeedsLayout]</code>，把标记设为需要布局</p></blockquote><blockquote><p>然后马上调用<code>[view layoutIfNeeded]</code>，实现布局</p></blockquote><blockquote><p>在初始化方法<code>init</code>..。、或者view第一次显示之前，标记总是“需要刷新”的，可以直接调用<code>[view layoutIfNeeded]</code></p></blockquote><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><blockquote><p><code>-drawRect:(CGRect)rect</code>方法：重写此方法，执行重绘任务</p></blockquote><blockquote><p><code>-setNeedsDisplay</code>方法：标记为需要重绘，异步调用<code>drawRect</code></p></blockquote><blockquote><p><code>-setNeedsDisplayInRect:(CGRect)invalidRect</code>方法：标记为需要局部重绘</p></blockquote><ul><li><strong>（注意：<code>sizeToFit</code>会 自动调用<code>sizeThatFits</code>方法；</strong></li></ul><p><code>sizeToFit</code>不应该在子类中被重写，应该重写<code>sizeThatFits</code>）</p><blockquote><p><code>sizeThatFits</code>传入的参数是<code>receiver</code>当前的<code>size</code>，返回一个适合的<code>size</code></p></blockquote><blockquote><p><code>sizeToFit</code>可以被手动直接调用,注意(系统默认的一些控件可以通过调用<code>sizeToFit</code>方法使其有尺寸,<code>egUIBarButtonItem,UITableView</code>的组头,组尾,表头,表尾,,,……)</p></blockquote><blockquote><p><code>sizeToFit</code>和<code>sizeThatFits</code>方法都没有递归，对<code>subviews</code>也不负责，只负责自己</p></blockquote><blockquote><p><code>layoutSubviews</code>对<code>subviews</code>重新布局</p></blockquote><blockquote><p><code>layoutSubviews</code>方法调用先于<code>drawRect</code></p></blockquote><blockquote><p><code>setNeedsLayout</code>在<code>receiver</code>标上一个需要被重新布局的标记，在系统<code>runloop</code>的下一个周期自动调用<code>layoutSubviews</code></p></blockquote><blockquote><p><code>layoutIfNeeded</code>方法如其名，<code>UIKit</code>会判断该<code>receiver</code>是否需要<code>layout</code>.根据Apple官方文档,<code>layoutIfNeeded</code>方法应该是这样的</p></blockquote><blockquote><p><code>layoutIfNeeded</code>遍历的不是<code>superview</code>链，应该是<code>subviews</code>链</p></blockquote><blockquote><p><code>drawRect</code>是对<code>receiver</code>的重绘，能获得<code>context</code></p></blockquote><blockquote><p><code>setNeedDisplay</code>在<code>receiver</code>标上一个需要被重新绘图的标记，在下一个<code>draw</code>周期自动重绘，<code>iphone device的刷新频率是60hz</code>，也就是<code>1/60</code>秒后重绘</p></blockquote><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://blog.sina.com.cn/s/blog_a573f7990101cdpe.html" target="_blank" rel="noopener">UIView常用的一些方法小记之setNeedsDisplay和setNeedsLayout</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;import导入pod第三方库不提示问题&quot;&gt;&lt;a href=&quot;#import导入pod第三方库不提示问题&quot; class=&quot;headerlink&quot; title=&quot;import导入pod第三方库不提示问题&quot;&gt;&lt;/a&gt;&lt;code&gt;import&lt;/code&gt;导入&lt;code&gt;pod&lt;/code&gt;第三方库不提示问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;选择&lt;code&gt;target&lt;/code&gt; &amp;gt; &lt;code&gt;BuildSettings&lt;/code&gt; &amp;gt; &lt;code&gt;search Paths&lt;/code&gt;下的&lt;code&gt;User Header Search Paths&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;双击后面的空白区域&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;点击”+”号添加一项:并且输入:&lt;code&gt;$(PODS_ROOT)&lt;/code&gt;,选择:&lt;code&gt;recursive&lt;/code&gt;(会在相应的目录递归搜索文件)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS效率" scheme="http://yoursite.com/categories/iOS%E6%95%88%E7%8E%87/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Hexo教程</title>
    <link href="http://yoursite.com/2018/05/03/Hexo%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/05/03/Hexo教程/</id>
    <published>2018-05-03T08:28:19.000Z</published>
    <updated>2018-05-04T02:38:39.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置Node-js环境"><a href="#配置Node-js环境" class="headerlink" title="配置Node.js环境"></a>配置Node.js环境</h2><p><strong>Node.js: <a href="https://nodejs.org/en/#download" target="_blank" rel="noopener">Node.js官网</a></strong></p><p><img src="http://upload-images.jianshu.io/upload_images/727768-fb3a458f1555ea46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p><a id="more"></a><p><strong>下载成功之后是这样的一个文件:</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/727768-de9f36c841717341.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p><h2 id="安装-Node-js-和npm"><a href="#安装-Node-js-和npm" class="headerlink" title="安装 Node.js 和npm"></a>安装 Node.js 和npm</h2><p><img src="http://upload-images.jianshu.io/upload_images/727768-2cf4a54b45c7bf90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p><p><strong>终端下测试下Node.js是否可以使用:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p><strong>如果Node.js 成功安装，可以看到类似如下的信息:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v10.0.0</span><br></pre></td></tr></table></figure><p><strong>终端下测试下npm是否可以使用:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><strong>如果npm成功安装，可以看到类似如下的信息:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm -v</span><br><span class="line">5.6.0</span><br></pre></td></tr></table></figure><blockquote><p>全部完成上面的配置,已经完成第一步</p></blockquote><h2 id="搭建GitHub博客"><a href="#搭建GitHub博客" class="headerlink" title="搭建GitHub博客"></a>搭建GitHub博客</h2><p>进入<code>GitHub</code>,我们新建一个名为<code>用户名.github.io</code>的仓库,<code>用户名</code>其实就是你自己<code>GitHub用户名</code></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><ul><li><p>终端中执行<code>npm install hexo-cli -g</code></p></li><li><p><code>桌面</code>或者<code>自己熟悉的地方</code>,通过<code>终端</code>创建mkdir<code>hexo</code>文件夹</p></li><li><p>进入<code>hexo</code>文件夹,执行<code>hexo init</code></p></li></ul><p><strong>完成之后执行下面方法:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate创建静态页面</span><br><span class="line">hexo server启动服务</span><br></pre></td></tr></table></figure></p><ul><li><p>缩写<code>hexo g | hexo s</code></p></li><li><p>登录本地<code>localhost:4000</code></p></li></ul><p><strong> 启动服务,会显示下面页面 </strong><br><img src="http://onq81n53u.bkt.clouddn.com/YY%E5%9B%BE%E7%89%8720180110175140.jpg" alt="图片"></p><ul><li><p>接下来,我们就是把创建好的<code>hexo</code>项目,配置上传<code>GitHub</code>的前提条件</p></li><li><p>找到<code>hexo</code>文件夹下面的<code>_config.yml</code>文件</p></li></ul><h2 id="配置Hexo主题"><a href="#配置Hexo主题" class="headerlink" title="配置Hexo主题"></a>配置Hexo主题</h2><ul><li>把这段代码放置<code>_config.yml</code>文件的最后面,其中<code>GitHub用户名</code>是你自己在<code>GitHub</code>中创建的仓库对于的<code>信息</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository:</span><br><span class="line">            github: https://github.com/GitHub用户名/GitHub用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><blockquote><p>这样我们就完成了对<code>hexo</code>的基础搭建和配置</p></blockquote><h2 id="同步GitHub"><a href="#同步GitHub" class="headerlink" title="同步GitHub"></a>同步GitHub</h2><ul><li><p>终端执行<code>npm install hexo-deployer-git --save</code></p></li><li><p>完成上面的全部操作,我们博客基本完成,相应的主题配置自行<code>百度</code>,<code>Google</code></p></li></ul><p><strong>开始同步</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line">hexo deployer</span><br></pre></td></tr></table></figure></p><ul><li><p>缩写<code>hexo d -g</code>执行</p></li><li><p>浏览器中输入<code>https://GitHub用户名.github.io</code>,如果成功会显示上面同样的页面</p></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li>如果你已经看到这里,说明已经完成了对博客的搭建,我们就可以开心的撸博客了!!!</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;配置Node-js环境&quot;&gt;&lt;a href=&quot;#配置Node-js环境&quot; class=&quot;headerlink&quot; title=&quot;配置Node.js环境&quot;&gt;&lt;/a&gt;配置Node.js环境&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Node.js: &lt;a href=&quot;https://nodejs.org/en/#download&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Node.js官网&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/727768-fb3a458f1555ea46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo教程" scheme="http://yoursite.com/categories/Hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
