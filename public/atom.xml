<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蜡笔小新Zzz</title>
  
  <subtitle>天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-05T08:05:52.850Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>蜡笔小新Zzz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Masonry自适应tableHeaderView</title>
    <link href="http://yoursite.com/2018/05/05/Masonry%E8%87%AA%E9%80%82%E5%BA%94tableHeaderView/"/>
    <id>http://yoursite.com/2018/05/05/Masonry自适应tableHeaderView/</id>
    <published>2018-05-05T07:40:45.000Z</published>
    <updated>2018-05-05T08:05:52.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如题"><a href="#如题" class="headerlink" title="如题"></a>如题</h2><blockquote><p>从苹果开发约束,方便了我们快速适配iPhone手机,看到<code>Masonry</code>之后,我们就想要适配所有开发中所遇到的问题,今天就适配<code>Masonry</code>自适应<code>tableHeaderView</code></p></blockquote><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>如果使用frame,计算的话肯定也是可以达到相同结果的,可是<code>麻烦</code>,所以今天就使用<code>Masonry</code>来完成这个需求</p><ul><li>首先, 我们一般都是自定义<code>View</code>,在这个<code>View</code>设置好约束</li></ul><a id="more"></a><p><strong>重要</strong></p><ul><li>这个自定义<code>View</code>,里面的子控件一定要有从<code>top</code>到<code>bottom</code>连起来的那一条线,就像盖房子一样的,第一个子控件到最后的个子控件,让<code>tableHeaderView</code>知道<code>top</code>到<code>bottom</code>的位置</li></ul><h2 id="自定义View代码"><a href="#自定义View代码" class="headerlink" title="自定义View代码"></a>自定义<code>View</code>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 这个是第一个子控件</span><br><span class="line">[self addSubview:self.oneLabel];</span><br><span class="line">[self.oneLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.left.right.mas_equalTo(self).offset(0);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 这个是第二个子控件</span><br><span class="line">[self addSubview:self.oneImageView];</span><br><span class="line">[self.oneImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.mas_equalTo(self.oneLabel.mas_bottom).offset(0);</span><br><span class="line">    make.left.right.mas_equalTo(self).offset(0);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 重点,必须设置这个约束,告诉当前view的位置</span><br><span class="line">[self mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.bottom.mas_equalTo(self.oneImageView.mas_bottom).offset(0);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="Controller代码"><a href="#Controller代码" class="headerlink" title="Controller代码"></a><code>Controller</code>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 必须给headerView设置宽度,不然headView是不知道到底有宽</span><br><span class="line">self.tableView.tableHeaderView = self.headView;</span><br><span class="line">[self.headView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.width.equalTo(self.tableView);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="/2018/05/05/Masonry自适应tableHeaderView/tableHeaderView.gif" alt="Masonry"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如题&quot;&gt;&lt;a href=&quot;#如题&quot; class=&quot;headerlink&quot; title=&quot;如题&quot;&gt;&lt;/a&gt;如题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;从苹果开发约束,方便了我们快速适配iPhone手机,看到&lt;code&gt;Masonry&lt;/code&gt;之后,我们就想要适配所有开发中所遇到的问题,今天就适配&lt;code&gt;Masonry&lt;/code&gt;自适应&lt;code&gt;tableHeaderView&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;解答&quot;&gt;&lt;a href=&quot;#解答&quot; class=&quot;headerlink&quot; title=&quot;解答&quot;&gt;&lt;/a&gt;解答&lt;/h2&gt;&lt;p&gt;如果使用frame,计算的话肯定也是可以达到相同结果的,可是&lt;code&gt;麻烦&lt;/code&gt;,所以今天就使用&lt;code&gt;Masonry&lt;/code&gt;来完成这个需求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先, 我们一般都是自定义&lt;code&gt;View&lt;/code&gt;,在这个&lt;code&gt;View&lt;/code&gt;设置好约束&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://yoursite.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Hexo插入图片</title>
    <link href="http://yoursite.com/2018/05/05/Hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2018/05/05/Hexo插入图片/</id>
    <published>2018-05-05T02:10:12.000Z</published>
    <updated>2018-05-05T02:31:31.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>当我们想在博客上上传图片,如果直接引用本地图片,会存在很多问题,图片损坏等</p></blockquote><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul><li><p>在<code>hexo</code>文件夹中找到<code>_config.yml</code>里的<code>post_asset_folder</code>:这个选项设置为<code>true</code></p></li><li><p>在<code>hexo</code>目录下执行这样一句话<code>npm install hexo-asset-image --save</code>命令,来安装一个可以上传图片的插件</p></li></ul><a id="more"></a><ul><li><p>命令创建<code>hexo -n xxxx.md</code>,执行完成之后,会在<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹</p></li><li><p>最后把图片复杂到<code>xxxx.md</code>的文件夹中,按照这样的方式<code>![你想输入的替代文字](xxxx/图片名.jpg)</code></p></li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="/2018/05/05/Hexo插入图片/phone.jpg" alt="phone"></p><blockquote><p>如果完成上面操作,会实现显示自己添加的图片,说明已经完成</p></blockquote><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://blog.csdn.net/sugar_rainbow/article/details/57415705" target="_blank" rel="noopener">hexo生成博文插入图片</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;当我们想在博客上上传图片,如果直接引用本地图片,会存在很多问题,图片损坏等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;解决&quot;&gt;&lt;a href=&quot;#解决&quot; class=&quot;headerlink&quot; title=&quot;解决&quot;&gt;&lt;/a&gt;解决&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;hexo&lt;/code&gt;文件夹中找到&lt;code&gt;_config.yml&lt;/code&gt;里的&lt;code&gt;post_asset_folder&lt;/code&gt;:这个选项设置为&lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;hexo&lt;/code&gt;目录下执行这样一句话&lt;code&gt;npm install hexo-asset-image --save&lt;/code&gt;命令,来安装一个可以上传图片的插件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Hexo教程" scheme="http://yoursite.com/categories/Hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>iOS偷懒_效率</title>
    <link href="http://yoursite.com/2018/05/04/iOS%E5%81%B7%E6%87%92-%E6%95%88%E7%8E%87/"/>
    <id>http://yoursite.com/2018/05/04/iOS偷懒-效率/</id>
    <published>2018-05-04T03:05:36.000Z</published>
    <updated>2018-05-04T05:04:09.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="import导入pod第三方库不提示问题"><a href="#import导入pod第三方库不提示问题" class="headerlink" title="import导入pod第三方库不提示问题"></a><code>import</code>导入<code>pod</code>第三方库不提示问题</h2><ol><li><p>选择<code>target</code> &gt; <code>BuildSettings</code> &gt; <code>search Paths</code>下的<code>User Header Search Paths</code></p></li><li><p>双击后面的空白区域</p></li><li><p>点击”+”号添加一项:并且输入:<code>$(PODS_ROOT)</code>,选择:<code>recursive</code>(会在相应的目录递归搜索文件)</p></li></ol><a id="more"></a><h2 id="添加pch文件"><a href="#添加pch文件" class="headerlink" title="添加pch文件"></a>添加<code>pch</code>文件</h2><ol><li><p><code>Xcode</code>正确创建<code>pch</code>文件</p></li><li><p>选择<code>target</code> &gt; <code>BuildSettings</code> &gt; <code>Apple LLVM 8.0 -Language</code>下的<code>Prefix Header</code>(或者搜索<code>Prefix Header</code>)</p></li><li><p>双击后面的空白区域</p></li><li><p>点击”+”号添加一项:并且输入:<code>$(SRCROOT)/项目中创建.pch</code>,选择:<code>recursive</code>(会在相应的目录递归搜索文件)</p></li><li><p><code>Precompile Prefix Header</code>为<code>YES</code>,预编译后的pch文件缓存起来</p></li></ol><h2 id="扩展随机颜色"><a href="#扩展随机颜色" class="headerlink" title="扩展随机颜色"></a>扩展随机颜色</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[UIColor colorWithRed:arc4random_uniform(255) / 255.0 green:arc4random_uniform(255) / 255.0 blue:arc4random_uniform(255) / 255.0 alpha:1];</span><br></pre></td></tr></table></figure><h2 id="UIView常用setNeedsDisplay和setNeedsLayout"><a href="#UIView常用setNeedsDisplay和setNeedsLayout" class="headerlink" title="UIView常用setNeedsDisplay和setNeedsLayout"></a>UIView常用setNeedsDisplay和setNeedsLayout</h2><p><strong>UIView的setNeedsDisplay和setNeedsLayout方法</strong></p><blockquote><p>首先两个方法都是异步执行的。而<code>setNeedsDisplay</code>会调用自动调用<code>drawRect</code>方法，这样可以拿到<code>UIGraphicsGetCurrentContext</code>，就可以画画了。而<code>setNeedsLayout</code>会默认调用<code>layoutSubViews</code>，就可以处理子视图中的一些数据。</p></blockquote><blockquote><p>综上所诉，<code>setNeedsDisplay</code>方便绘图，而<code>layoutSubViews</code>方便出来数据。</p></blockquote><p><code>layoutSubviews</code>在以下情况下会被调用：</p><ul><li><code>init</code>初始化不会触发<code>layoutSubviews</code>。</li><li><code>addSubview</code>会触发<code>layoutSubviews</code>。</li><li>设置<code>view</code>的<code>Frame</code>会触发<code>layoutSubviews</code>，当然前提是<code>frame</code>的值设置前后发生了变化。</li><li>滚动一个<code>UIScrollView</code>会触发<code>layoutSubviews</code>。</li><li>旋转<code>Screen</code>会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件。</li><li>改变一个<code>UIView</code>大小的时候也会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件。</li><li>直接调用<code>setLayoutSubviews</code>。</li></ul><p><code>drawRect</code>在以下情况下会被调用：</p><ul><li>如果在<code>UIView</code>初始化时没有设置<code>rect</code>大小，将直接导致<code>drawRect</code>不被自动调用。<code>drawRect</code>调用是在<code>Controller-&gt;loadView, Controller-&gt;viewDidLoad</code>两方法之后掉用的.所以不用担心在控制器中,这些<code>View</code>的<code>drawRect</code>就开始画了.这样可以在控制器中设置一些值给<code>View</code>(如果这些<code>View draw</code>的时候需要用到某些变量值).</li><li>该方法在调用<code>sizeToFit</code>后被调用，所以可以先调用<code>sizeToFit</code>计算出<code>size</code>。然后系统自动调用<code>drawRect:</code>方法。</li><li>通过设置<code>contentMode</code>属性值为<code>UIViewContentModeRedraw</code>。那么将在每次设置或更改<code>frame</code>的时候自动调用<code>drawRect:</code>。</li><li>直接调用<code>setNeedsDisplay</code>，或者<code>setNeedsDisplayInRect:</code>触发<code>drawRect:</code>，但是有个前提条件是<code>rect</code>不能为0。</li><li>以上1,2推荐；而3,4不提倡</li></ul><p><code>drawRect</code>方法使用注意点：</p><ul><li>若使用<code>UIView</code>绘图，只能在<code>drawRect：</code>方法中获取相应的<code>contextRef</code>并绘图。如果在其他方法中获取将获取到一个<code>invalidate</code>的<code>ref</code>并且不能用于画图。<code>drawRect：</code>方法不能手动显示调用，必须通过调用<code>setNeedsDisplay</code> 或者 <code>setNeedsDisplayInRect</code>，让系统自动调该方法。</li><li>若使用<code>calayer</code>绘图，只能在<code>drawInContext:</code>中（类似于<code>drawRect</code>）绘制，或者在<code>delegate</code>中的相应方法绘制。同样也是调用<code>setNeedDisplay</code>等间接调用以上方法</li><li>若要实时画图，不能使用<code>gestureRecognizer</code>，只能使用<code>touchbegan</code>等方法来掉用<code>setNeedsDisplay</code>实时刷新屏幕</li></ul><h2 id="UIView调用"><a href="#UIView调用" class="headerlink" title="UIView调用"></a>UIView调用</h2><blockquote><p><code>-(void)layoutSubviews</code></p></blockquote><blockquote><p><code>-(void)layoutIfNeeded</code></p></blockquote><blockquote><p><code>-(void)setNeedsLayout</code></p></blockquote><blockquote><p><code>-(CGSize)sizeThatFits:(CGSize)size</code></p></blockquote><blockquote><p><code>-(void)sizeToFit</code></p></blockquote><blockquote><p><code>-(void)setNeedsDisplay</code></p></blockquote><blockquote><p><code>-(void)drawRect</code></p></blockquote><h3 id="layoutSubviews在以下情况下会被调用-被触发？？"><a href="#layoutSubviews在以下情况下会被调用-被触发？？" class="headerlink" title="layoutSubviews在以下情况下会被调用/被触发？？"></a><code>layoutSubviews</code>在以下情况下会被调用/被触发？？</h3><ol><li><p><code>init</code>初始化不会触发<code>layoutSubviews</code>，但是是用<code>initWithFrame</code>进行初始化时，当<code>rect</code>的值 非<code>CGRectZero</code>时,也会触发。</p></li><li><p><code>addSubview</code>会触发<code>layoutSubviews</code></p></li><li><p>设置<code>view</code>的<code>Frame</code>会触发<code>layoutSubviews</code>，当然前提是<code>frame</code>的值设置前后发生了变化</p></li><li><p>滚动一个<code>UIScrollView</code>会触发<code>layoutSubviews</code></p></li><li><p>旋转<code>Screen</code>会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件</p></li><li><p>改变一个<code>UIView</code>大小的时候也会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件</p></li></ol><p><strong>(在苹果的官方文档中强调)</strong></p><p><code>You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.layoutSubviews</code>,(当我们在某个类的内部调整子视图位置时，需要调用。反过来的意思就是说：如果你想要在外部设置<code>subviews</code>的位置，就不要重写。)</p><h2 id="刷新子对象布局"><a href="#刷新子对象布局" class="headerlink" title="刷新子对象布局??"></a>刷新子对象布局??</h2><h3 id="什么时候，需要重写？"><a href="#什么时候，需要重写？" class="headerlink" title="什么时候，需要重写？"></a>什么时候，需要重写？</h3><blockquote><p>view是系统的，不需要重写 <code>- (void)layoutSubviews</code></p></blockquote><blockquote><p>view是自定义的，需要重写  <code>- (void)layoutSubviews</code></p></blockquote><blockquote><p><code>-layoutSubviews</code>方法：这个方法，默认没有做任何事情，需要子类进行重写，自定义<code>view</code>时，手动重写，这里面只能写<code>subview</code>的<code>frame</code>限制。</p></blockquote><h3 id="手动调用这个方法，系统默认-我们不能手动直接调用这个方法，这能通过下列两种方式，调用-触发-void-layoutSubviews方法"><a href="#手动调用这个方法，系统默认-我们不能手动直接调用这个方法，这能通过下列两种方式，调用-触发-void-layoutSubviews方法" class="headerlink" title="手动调用这个方法，系统默认 我们不能手动直接调用这个方法，这能通过下列两种方式，调用/触发 - (void)layoutSubviews方法"></a>手动调用这个方法，系统默认 我们不能手动直接调用这个方法，这能通过下列两种方式，调用/触发 <code>- (void)layoutSubviews</code>方法</h3><blockquote><p><code>-setNeedsLayout</code>方法： 标记为需要重新布局，告诉系统未来某个时间点异步调用。不立即刷新，但<code>layoutSubviews</code>一定会被调用。</p></blockquote><blockquote><p><code>-layoutIfNeeded</code>方法：如果，有需要刷新的标记，立即调用<code>layoutSubviews</code>进行布局（如果没有标记，不会调用<code>layoutSubviews</code>）</p></blockquote><blockquote><p>若需要立即刷新<code>view</code>的<code>frame</code>更改：（同时调用，注意先后顺序）</p></blockquote><blockquote><p>先调用<code>[view setNeedsLayout]</code>，把标记设为需要布局</p></blockquote><blockquote><p>然后马上调用<code>[view layoutIfNeeded]</code>，实现布局</p></blockquote><blockquote><p>在初始化方法<code>init</code>..。、或者view第一次显示之前，标记总是“需要刷新”的，可以直接调用<code>[view layoutIfNeeded]</code></p></blockquote><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><blockquote><p><code>-drawRect:(CGRect)rect</code>方法：重写此方法，执行重绘任务</p></blockquote><blockquote><p><code>-setNeedsDisplay</code>方法：标记为需要重绘，异步调用<code>drawRect</code></p></blockquote><blockquote><p><code>-setNeedsDisplayInRect:(CGRect)invalidRect</code>方法：标记为需要局部重绘</p></blockquote><ul><li><strong>（注意：<code>sizeToFit</code>会 自动调用<code>sizeThatFits</code>方法；</strong></li></ul><p><code>sizeToFit</code>不应该在子类中被重写，应该重写<code>sizeThatFits</code>）</p><blockquote><p><code>sizeThatFits</code>传入的参数是<code>receiver</code>当前的<code>size</code>，返回一个适合的<code>size</code></p></blockquote><blockquote><p><code>sizeToFit</code>可以被手动直接调用,注意(系统默认的一些控件可以通过调用<code>sizeToFit</code>方法使其有尺寸,<code>egUIBarButtonItem,UITableView</code>的组头,组尾,表头,表尾,,,……)</p></blockquote><blockquote><p><code>sizeToFit</code>和<code>sizeThatFits</code>方法都没有递归，对<code>subviews</code>也不负责，只负责自己</p></blockquote><blockquote><p><code>layoutSubviews</code>对<code>subviews</code>重新布局</p></blockquote><blockquote><p><code>layoutSubviews</code>方法调用先于<code>drawRect</code></p></blockquote><blockquote><p><code>setNeedsLayout</code>在<code>receiver</code>标上一个需要被重新布局的标记，在系统<code>runloop</code>的下一个周期自动调用<code>layoutSubviews</code></p></blockquote><blockquote><p><code>layoutIfNeeded</code>方法如其名，<code>UIKit</code>会判断该<code>receiver</code>是否需要<code>layout</code>.根据Apple官方文档,<code>layoutIfNeeded</code>方法应该是这样的</p></blockquote><blockquote><p><code>layoutIfNeeded</code>遍历的不是<code>superview</code>链，应该是<code>subviews</code>链</p></blockquote><blockquote><p><code>drawRect</code>是对<code>receiver</code>的重绘，能获得<code>context</code></p></blockquote><blockquote><p><code>setNeedDisplay</code>在<code>receiver</code>标上一个需要被重新绘图的标记，在下一个<code>draw</code>周期自动重绘，<code>iphone device的刷新频率是60hz</code>，也就是<code>1/60</code>秒后重绘</p></blockquote><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://blog.sina.com.cn/s/blog_a573f7990101cdpe.html" target="_blank" rel="noopener">UIView常用的一些方法小记之setNeedsDisplay和setNeedsLayout</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;import导入pod第三方库不提示问题&quot;&gt;&lt;a href=&quot;#import导入pod第三方库不提示问题&quot; class=&quot;headerlink&quot; title=&quot;import导入pod第三方库不提示问题&quot;&gt;&lt;/a&gt;&lt;code&gt;import&lt;/code&gt;导入&lt;code&gt;pod&lt;/code&gt;第三方库不提示问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;选择&lt;code&gt;target&lt;/code&gt; &amp;gt; &lt;code&gt;BuildSettings&lt;/code&gt; &amp;gt; &lt;code&gt;search Paths&lt;/code&gt;下的&lt;code&gt;User Header Search Paths&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;双击后面的空白区域&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;点击”+”号添加一项:并且输入:&lt;code&gt;$(PODS_ROOT)&lt;/code&gt;,选择:&lt;code&gt;recursive&lt;/code&gt;(会在相应的目录递归搜索文件)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS效率" scheme="http://yoursite.com/categories/iOS%E6%95%88%E7%8E%87/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Hexo教程</title>
    <link href="http://yoursite.com/2018/05/03/Hexo%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/05/03/Hexo教程/</id>
    <published>2018-05-03T08:28:19.000Z</published>
    <updated>2018-05-04T02:38:39.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置Node-js环境"><a href="#配置Node-js环境" class="headerlink" title="配置Node.js环境"></a>配置Node.js环境</h2><p><strong>Node.js: <a href="https://nodejs.org/en/#download" target="_blank" rel="noopener">Node.js官网</a></strong></p><p><img src="http://upload-images.jianshu.io/upload_images/727768-fb3a458f1555ea46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p><a id="more"></a><p><strong>下载成功之后是这样的一个文件:</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/727768-de9f36c841717341.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p><h2 id="安装-Node-js-和npm"><a href="#安装-Node-js-和npm" class="headerlink" title="安装 Node.js 和npm"></a>安装 Node.js 和npm</h2><p><img src="http://upload-images.jianshu.io/upload_images/727768-2cf4a54b45c7bf90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p><p><strong>终端下测试下Node.js是否可以使用:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p><strong>如果Node.js 成功安装，可以看到类似如下的信息:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v10.0.0</span><br></pre></td></tr></table></figure><p><strong>终端下测试下npm是否可以使用:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><strong>如果npm成功安装，可以看到类似如下的信息:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm -v</span><br><span class="line">5.6.0</span><br></pre></td></tr></table></figure><blockquote><p>全部完成上面的配置,已经完成第一步</p></blockquote><h2 id="搭建GitHub博客"><a href="#搭建GitHub博客" class="headerlink" title="搭建GitHub博客"></a>搭建GitHub博客</h2><p>进入<code>GitHub</code>,我们新建一个名为<code>用户名.github.io</code>的仓库,<code>用户名</code>其实就是你自己<code>GitHub用户名</code></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><ul><li><p>终端中执行<code>npm install hexo-cli -g</code></p></li><li><p><code>桌面</code>或者<code>自己熟悉的地方</code>,通过<code>终端</code>创建mkdir<code>hexo</code>文件夹</p></li><li><p>进入<code>hexo</code>文件夹,执行<code>hexo init</code></p></li></ul><p><strong>完成之后执行下面方法:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate创建静态页面</span><br><span class="line">hexo server启动服务</span><br></pre></td></tr></table></figure></p><ul><li><p>缩写<code>hexo g | hexo s</code></p></li><li><p>登录本地<code>localhost:4000</code></p></li></ul><p><strong> 启动服务,会显示下面页面 </strong><br><img src="http://onq81n53u.bkt.clouddn.com/YY%E5%9B%BE%E7%89%8720180110175140.jpg" alt="图片"></p><ul><li><p>接下来,我们就是把创建好的<code>hexo</code>项目,配置上传<code>GitHub</code>的前提条件</p></li><li><p>找到<code>hexo</code>文件夹下面的<code>_config.yml</code>文件</p></li></ul><h2 id="配置Hexo主题"><a href="#配置Hexo主题" class="headerlink" title="配置Hexo主题"></a>配置Hexo主题</h2><ul><li>把这段代码放置<code>_config.yml</code>文件的最后面,其中<code>GitHub用户名</code>是你自己在<code>GitHub</code>中创建的仓库对于的<code>信息</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository:</span><br><span class="line">            github: https://github.com/GitHub用户名/GitHub用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><blockquote><p>这样我们就完成了对<code>hexo</code>的基础搭建和配置</p></blockquote><h2 id="同步GitHub"><a href="#同步GitHub" class="headerlink" title="同步GitHub"></a>同步GitHub</h2><ul><li><p>终端执行<code>npm install hexo-deployer-git --save</code></p></li><li><p>完成上面的全部操作,我们博客基本完成,相应的主题配置自行<code>百度</code>,<code>Google</code></p></li></ul><p><strong>开始同步</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line">hexo deployer</span><br></pre></td></tr></table></figure></p><ul><li><p>缩写<code>hexo d -g</code>执行</p></li><li><p>浏览器中输入<code>https://GitHub用户名.github.io</code>,如果成功会显示上面同样的页面</p></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li>如果你已经看到这里,说明已经完成了对博客的搭建,我们就可以开心的撸博客了!!!</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;配置Node-js环境&quot;&gt;&lt;a href=&quot;#配置Node-js环境&quot; class=&quot;headerlink&quot; title=&quot;配置Node.js环境&quot;&gt;&lt;/a&gt;配置Node.js环境&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Node.js: &lt;a href=&quot;https://nodejs.org/en/#download&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Node.js官网&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/727768-fb3a458f1555ea46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo教程" scheme="http://yoursite.com/categories/Hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
